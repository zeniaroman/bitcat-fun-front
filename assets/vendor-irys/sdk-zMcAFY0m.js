var Te=Object.defineProperty;var _e=(o,t,e)=>t in o?Te(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var c=(o,t,e)=>_e(o,typeof t!="symbol"?t+"":t,e);import{a as W}from"../vendor-axios-Hz4xvOoZ.js";import{r as H}from"../vendor-async-retry-DWdC6xTk.js";import{b}from"../vendor-buffer-DVXvU5G6.js";import{C as ye,c as xe}from"../vendor-crypto-browserify-NMg_40A5.js";import{b as $}from"../vendor-base64url-D1J1q9RC.js";import{B as g}from"../vendor-bignumber.js-Dj_rIxHg.js";import{Q as Z}from"./query-BJ-9co3k.js";import{D as Se,b as Ce,c as Ee,d as Ie,g as me,I as be,N as ee,a as te,A as ve}from"../vendor-arbundles-CR3XhIxB.js";import{B as re}from"../vendor-ethersproject/bignumber-DuyZ-PBD.js";import{l as Pe}from"../vendor-near-js/crypto-DYaHgGqH.js";import{l as Be}from"../vendor-near-js/keystores-browser-C7Ipq7jt.js";import{l as z}from"../vendor-near-js/transactions-CNW8gb_X.js";import{g as Ae,S as Re}from"../solana-vendors-DGPAp7Fj.js";import{l as $e}from"../vendor-borsh-uT6VLZDJ.js";import{B as Ue}from"../vendor-bn.js-CN51n21Z.js";import{s as De}from"../vendor-js-sha256-J9Bkl3or.js";import"../vendor-base64-js-C2zTC7ec.js";import{s as Ne}from"./arweave-CO_npObX.js";import"../vendor-noble/ed25519-DHS8bCE8.js";import"../vendor-bs58-DhqqakFZ.js";import"../vendor-secp256k1-gx_3s_gH.js";import{C as Ke}from"../vendor-ethersproject/contracts-BfB5cMkz.js";import{A as Fe,T as qe,a as ze,b as He}from"../vendor-aptos-COdaePwy.js";import{s as Le}from"../vendor-js-sha3-DkKfOMXT.js";import{d as Me}from"../vendor-supercharge/promise-pool-CxlJr3BL.js";import{s as ae}from"../vendor-stream-browserify-BiXhMpOM.js";import{e as Oe}from"../vendor-events-cQ9mhZQJ.js";const L=()=>{throw new Error("Unimplemented")};globalThis.crypto??(globalThis.crypto={});var he;(he=globalThis.crypto).subtle??(he.subtle={});var le;(le=globalThis.crypto.subtle).generateKey??(le.generateKey=L);var ge;(ge=globalThis.crypto.subtle).importKey??(ge.importKey=L);var pe;(pe=globalThis.crypto.subtle).exportKey??(pe.exportKey=L);var we;(we=globalThis.crypto.subtle).digest??(we.digest=L);var fe;(fe=globalThis.crypto.subtle).sign??(fe.sign=L);function Ge(o){class t extends o.arbundles.DataItem{constructor(a,n,i){super((i==null?void 0:i.dataIsRawTransaction)===!0?b.Buffer.from(a):n.arbundles.createData(a,n.tokenConfig.getSigner(),{...i,anchor:(i==null?void 0:i.anchor)??ye.randomBytes(32).toString("base64").slice(0,32)}).getRaw());c(this,"Irys");c(this,"signer");this.Irys=n,this.signer=n.tokenConfig.getSigner()}sign(){return super.sign(this.signer)}get size(){return this.getRaw().length}async uploadWithReceipt(a){return(await this.Irys.uploader.uploadTransaction(this,{...a,getReceiptSignature:!0})).data}async upload(a){return(await this.Irys.uploader.uploadTransaction(this,a)).data}async getPrice(){return this.Irys.utils.getPrice(this.Irys.tokenConfig.name,this.size)}async isValid(){return o.arbundles.DataItem.verify(this.getRaw())}}return t}g.set({DECIMAL_PLACES:50});const ne=o=>new Promise(t=>setTimeout(t,o));class S{constructor(t,e,r){c(this,"api");c(this,"token");c(this,"tokenConfig");c(this,"arbundles");this.api=t,this.token=e,this.tokenConfig=r,this.arbundles=this.tokenConfig.irys.arbundles}static checkAndThrow(t,e,r){if(t!=null&&t.status&&!(r??[]).includes(t.status)&&t.status!=200)throw new Error(`HTTP Error: ${e}: ${t.status} ${typeof t.data!="string"?t.statusText:t.data}`)}async getNonce(){const t=await this.api.get(`/account/withdrawals/${this.tokenConfig.name}?address=${this.tokenConfig.address}`);return S.checkAndThrow(t,"Getting withdrawal nonce"),t.data}async getBalance(t){const e=await this.api.get(`/account/balance/${this.tokenConfig.name}?address=${t}`);return S.checkAndThrow(e,"Getting balance"),new g(e.data.balance)}async getBundlerAddress(t){const e=await this.api.get("/info");S.checkAndThrow(e,"Getting Bundler address");const r=e.data.addresses[t];if(!r)throw new Error(`Specified bundler does not support token ${t}`);return r}async getPrice(t,e){const r=await this.api.get(`/price/${t}/${e}`);return S.checkAndThrow(r,"Getting storage cost"),new g(r.data)}async estimateFolderPrice(t){Array.isArray(t)&&(t={fileCount:t.length,totalBytes:t.reduce((i,s)=>i+s,0)});const e=t.headerSizeAvg??this.arbundles.createData("",this.tokenConfig.getSigner()).getRaw().length,a=(await this.getPrice(this.tokenConfig.name,e)).multipliedBy(t.fileCount);return(await this.getPrice(this.tokenConfig.name,t.totalBytes)).plus(a).decimalPlaces(0)}toAtomic(t){return new g(t).multipliedBy(this.tokenConfig.base[1])}fromAtomic(t){return new g(t).dividedBy(this.tokenConfig.base[1])}async confirmationPoll(t,e=30){if(this.tokenConfig.isSlow)return;e<0&&(e=0);let r,a;const n=async()=>{for(;!a;){if(await this.tokenConfig.getTx(t).then(u=>u==null?void 0:u.confirmed).catch(u=>(r=u,!1)))return!0;await ne(1e3)}return!1},i=async()=>(await ne(e*1e3),a=!0,"RACE"),s=await Promise.race([i(),n()]);return s==="RACE"?(console.warn(`Tx ${t} didn't finalize after ${e} seconds ${r?` - ${r}`:""}`),r):s}unitConverter(t){return new g(t).dividedBy(this.tokenConfig.base[1])}async verifyReceipt(t){return S.verifyReceipt(this.arbundles,t)}static async verifyReceipt(t,e){const{id:r,deadlineHeight:a,timestamp:n,public:i,signature:s,version:d}=e,u=await t.deepHash([t.stringToBuffer("Bundlr"),t.stringToBuffer(d),t.stringToBuffer(r),t.stringToBuffer(a.toString()),t.stringToBuffer(n.toString())]);return await t.getCryptoDriver().verify(i,u,$.toBuffer(s))}async getReceipt(t){var s,d,u,p,h,_;const e=`query {
      transactions(ids: ["${t}"]) {
        edges {
          node {
            receipt {
              signature
              timestamp
              version
              deadlineHeight
            }
          }
        }
      }
    }`,r=await H(async()=>await this.api.post("/graphql",{query:e},{headers:{"content-type":"application/json"},validateStatus:E=>E===200})),a=(_=(h=(p=(u=(d=(s=r==null?void 0:r.data)==null?void 0:s.data)==null?void 0:d.transactions)==null?void 0:u.edges)==null?void 0:p.at(0))==null?void 0:h.node)==null?void 0:_.receipt;if(!a)throw new Error(`Missing required receipt data from node for tx: ${t}`);const i={public:(await this.api.get("/public")).data,version:a.version,id:t,timestamp:a.timestamp,validatorSignatures:[],signature:a.signature,deadlineHeight:a.deadlineHeight,verify:async()=>!1};return i.verify=async()=>this.verifyReceipt(i),i}}async function je(o,t,e){const r=o.tokenConfig,{deepHash:a,stringToBuffer:n}=r.irys.arbundles,s={publicKey:await r.getPublicKey(),currency:o.token,amount:new g(e).toString(),nonce:await o.getNonce(),signature:"",sigType:r.getSigner().signatureType},d=await a([n(s.currency),n(s.amount.toString()),n(s.nonce.toString())]);b.Buffer.isBuffer(s.publicKey)||(s.publicKey=b.Buffer.from(s.publicKey));const u=await r.sign(d),p=await r.verify(s.publicKey,d,u);s.publicKey=$.encode(s.publicKey),s.signature=$.encode(b.Buffer.from(u));const h=$.toBuffer(s.publicKey),_=$.toBuffer(s.signature),E=await a([n(s.currency),n(s.amount.toString()),n(s.nonce.toString())]),l=await r.verify(h,E,_),y=r.ownerToAddress(r.name=="arweave"?$.decode(s.publicKey):$.toBuffer(s.publicKey))===r.address;if(!(p||l||y))throw new Error(`Internal withdrawal validation failed - please report this!
Debug Info:${JSON.stringify(s)}`);const x=await t.post("/account/withdraw",s);if(x.status===202){const T=x.data.tx_id,f=await o.confirmationPoll(T);if(f!==!0)throw new Error(`Unable to confirm withdrawal tx ${T} ${f?f==null?void 0:f.toString():""}`)}else S.checkAndThrow(x,"Withdrawing balance");return x.data}class J{constructor({url:t,arbundles:e}){c(this,"api");c(this,"utils");c(this,"uploader");c(this,"funder");c(this,"address");c(this,"token");c(this,"tokenConfig");c(this,"provenance");c(this,"transactions");c(this,"_readyPromise");c(this,"url");c(this,"arbundles");c(this,"IrysTransaction");this.url=t,this.arbundles=e,this.IrysTransaction=Ge(this)}get signer(){return this.tokenConfig.getSigner()}get search(){const t=new Z({url:new URL("/graphql",this.url)});return t.search.bind(t)}query(t){return new Z(t??{url:this.url})}async withdrawBalance(t){return je(this.utils,this.api,t)}async getLoadedBalance(){if(!this.address)throw new Error("address is undefined");return this.utils.getBalance(this.address)}async getBalance(t){return this.utils.getBalance(t)}async fund(t,e){return this.funder.fund(t,e)}async getPrice(t){return this.utils.getPrice(this.token,t)}async verifyReceipt(t){return S.verifyReceipt(this.arbundles,t)}createTransaction(t,e){return new this.IrysTransaction(t,this,e)}getSigner(){return this.tokenConfig.getSigner()}async upload(t,e){return this.uploader.uploadData(t,e)}async uploadWithReceipt(t,e){return this.uploader.uploadData(t,{...e,upload:{getReceiptSignature:!0}})}async ready(){return this.tokenConfig.ready&&await this.tokenConfig.ready(),this.address=this.tokenConfig.address,this}get transaction(){const t=this;return{fromRaw(e){return new t.IrysTransaction(e,t,{dataIsRawTransaction:!0})}}}}c(J,"VERSION","0.0.2");class Ve{constructor(t){c(this,"_instance");c(this,"cookieMap",new Map);c(this,"config");t&&this.applyConfig(t)}applyConfig(t){this.config=this.mergeDefaults(t),this._instance=void 0}getConfig(){return this.config}async requestInterceptor(t){const e=this.cookieMap.get(new URL(t.baseURL??"").host);return e&&(t.headers.cookie=e),t}async responseInterceptor(t){var r;const e=(r=t.headers)==null?void 0:r["set-cookie"];return e&&this.cookieMap.set(t.request.host,e),t}mergeDefaults(t){return{url:t.url,timeout:t.timeout??2e4,logging:t.logging??!1,logger:t.logger??console.log,headers:{...t.headers,"x-irys-js-sdk-version":J.VERSION},withCredentials:t.withCredentials??!1,retry:{retries:3,maxTimeout:5e3}}}async get(t,e){var r;try{return await this.request(t,{...e,method:"GET"})}catch(a){if((r=a.response)!=null&&r.status)return a.response;throw a}}async post(t,e,r){var a;try{return await this.request(t,{data:e,...r,method:"POST"})}catch(n){if((a=n.response)!=null&&a.status)return n.response;throw n}}get instance(){if(this._instance)return this._instance;const t=W.create({baseURL:this.config.url.toString(),timeout:this.config.timeout,maxContentLength:1024*1024*512,headers:this.config.headers,withCredentials:this.config.withCredentials});return this.config.withCredentials&&(t.interceptors.request.use(this.requestInterceptor.bind(this)),t.interceptors.response.use(this.responseInterceptor.bind(this))),this.config.logging&&(t.interceptors.request.use(e=>(this.config.logger(`Requesting: ${e.baseURL}/${e.url}`),e)),t.interceptors.response.use(e=>(this.config.logger(`Response: ${e.config.url} - ${e.status}`),e))),this._instance=t}async request(t,e){const r=this.instance,a=(e==null?void 0:e.url)??new URL(t,this.config.url).toString();return H(n=>r({...e,url:a}),{...this.config.retry,...e==null?void 0:e.retry})}}class We{constructor(t){c(this,"utils");this.utils=t}async fund(t,e=1){const r=new g(t);if(!r.isInteger())throw new Error("must use an integer for funding amount");const a=this.utils.tokenConfig,n=await this.utils.getBundlerAddress(this.utils.token);let i;if(a.needsFee){const h=await a.getFee(a.base[0]==="winston"?0:r,n);i=g.isBigNumber(h)?h.multipliedBy(e).integerValue(g.ROUND_CEIL):h}const s=await a.createTx(r,n,i);let d;try{d=await a.sendTx(s.tx)}catch(h){throw h}if(s.txId??(s.txId=d),!s.txId)throw new Error("Undefined transaction ID");S.checkAndThrow(d,`Sending transaction to the ${this.utils.token} network`);let u=await this.utils.confirmationPoll(s.txId);if(!await this.submitTransaction(s.txId).catch(h=>{u=h}))throw new Error(`failed to post funding tx - ${s.txId} - keep this id! 
 ${u?` - ${(u==null?void 0:u.message)??u}`:""}`);return{reward:g.isBigNumber(i)?i.toString():JSON.stringify(i),target:n,quantity:r.toString(),id:s.txId}}async submitTransaction(t){return await H(async()=>{const e=await this.utils.api.post(`/account/balance/${this.utils.token}`,{tx_id:t});return S.checkAndThrow(e,`Posting transaction ${t} information to the bundler`,[202]),e},{retries:5,maxTimeout:1e3,minTimeout:100,randomize:!0})}async submitFundTransaction(t){return this.submitTransaction(t)}}const Je=Object.freeze(Object.defineProperty({__proto__:null,DataItem:Se,bundleAndSignData:Ce,createData:Ee,deepHash:Ie,getCryptoDriver:me,stringToBuffer:Ne},Symbol.toStringTag,{value:"Module"}));class Q{constructor(t){c(this,"base");c(this,"wallet");c(this,"_address");c(this,"providerUrl");c(this,"providerInstance");c(this,"ticker");c(this,"name");c(this,"irys");c(this,"minConfirm",5);c(this,"isSlow",!1);c(this,"needsFee",!0);c(this,"inheritsRPC",!1);Object.assign(this,t)}get address(){return this._address}async ready(){this._address=this.wallet?this.ownerToAddress(await this.getPublicKey()):void 0}async getId(t){return $.encode(b.Buffer.from(await me().hash(await t.rawSignature())))}async price(){return ke(this.ticker)}}async function ke(o){const t=await W.get(`https://api.redstone.finance/prices?symbol=${o}&provider=redstone&limit=1`);return await S.checkAndThrow(t,"Getting price data"),t.data[0].value}const Qe=be;class O extends Q{constructor(e){super(e);c(this,"signer");c(this,"w3signer");c(this,"inheritsRPC",!0);this.base=["wei",1e18]}async getTx(e){const a=await this.providerInstance.getTransaction(e);if(!a)throw new Error("Tx doesn't exist");if(!a.to)throw new Error(`Unable to resolve transactions ${e} receiver`);return{from:a.from,to:a.to,blockHeight:a.blockNumber?new g(a.blockNumber):void 0,amount:new g(a.value.toHexString(),16),pending:!a.blockNumber,confirmed:a.confirmations>=this.minConfirm}}ownerToAddress(e){return e.toString().toLowerCase()}async sign(e){return(await this.getSigner()).sign(e)}getSigner(){return this.signer||(this.signer=new be(this.wallet)),this.signer}async verify(e,r,a){return Qe.verify(e,r,a)}async getCurrentHeight(){const r=await this.providerInstance.send("eth_blockNumber",[]);return new g(r,16)}async getFee(e,r){const a=this.providerInstance,n={to:r,from:this.address,value:"0x"+new g(e).toString(16)},i=await a.estimateGas(n),s=await a.getGasPrice();return new g(i.mul(s).toString())}async sendTx(e){const a=await this.w3signer.sendTransaction(e);return a?a.hash:void 0}async createTx(e,r,a){const n=re.from(new g(e).toFixed()),i=this.w3signer,s=await i.estimateGas({to:r,from:this.address,value:n.toHexString()});let d=await i.getGasPrice();return this.name==="matic"&&(d=re.from(new g(d.toString()).multipliedBy(10).decimalPlaces(0).toString())),{txId:void 0,tx:await i.populateTransaction({to:r,from:this.address,value:n.toHexString(),gasPrice:d,gasLimit:s})}}async getPublicKey(){return this.address}async ready(){var e,r;this.w3signer=await this.wallet.getSigner(),this._address=(await this.w3signer.getAddress()).toString().toLowerCase(),await this.getSigner().ready(),this.providerInstance=this.wallet,await((r=(e=this.providerInstance)==null?void 0:e._ready)==null?void 0:r.call(e))}}var j,se;function Xe(){if(se)return j;se=1;function o(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var a=0;a<t.length;a++){var n=t.charAt(a),i=n.charCodeAt(0);if(e[i]!==255)throw new TypeError(n+" is ambiguous");e[i]=a}var s=t.length,d=t.charAt(0),u=Math.log(s)/Math.log(256),p=Math.log(256)/Math.log(s);function h(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var y=0,x=0,T=0,f=l.length;T!==f&&l[T]===0;)T++,y++;for(var P=(f-T)*p+1>>>0,B=new Uint8Array(P);T!==f;){for(var v=l[T],A=0,I=P-1;(v!==0||A<x)&&I!==-1;I--,A++)v+=256*B[I]>>>0,B[I]=v%s>>>0,v=v/s>>>0;if(v!==0)throw new Error("Non-zero carry");x=A,T++}for(var m=P-x;m!==P&&B[m]===0;)m++;for(var U=d.repeat(y);m<P;++m)U+=t.charAt(B[m]);return U}function _(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;for(var y=0,x=0,T=0;l[y]===d;)x++,y++;for(var f=(l.length-y)*u+1>>>0,P=new Uint8Array(f);l[y];){var B=l.charCodeAt(y);if(B>255)return;var v=e[B];if(v===255)return;for(var A=0,I=f-1;(v!==0||A<T)&&I!==-1;I--,A++)v+=s*P[I]>>>0,P[I]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");T=A,y++}for(var m=f-T;m!==f&&P[m]===0;)m++;for(var U=new Uint8Array(x+(f-m)),F=x;m!==f;)U[F++]=P[m++];return U}function E(l){var y=_(l);if(y)return y;throw new Error("Non-base"+s+" character")}return{encode:h,decodeUnsafe:_,decode:E}}return j=o,j}var V,ie;function Ye(){return ie||(ie=1,V=Xe()("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")),V}var Ze=Ye();const M=Ae(Ze);class et extends Q{constructor(e){super(e);c(this,"keyPair");c(this,"near");this.near=this.wallet._near,this.base=["yoctoNEAR",1e25]}async ready(){if(!this.wallet.isSignedIn())throw new Error("Wallet has not been signed in!");const e=new Be.BrowserLocalStorageKeyStore,r=this.wallet.account();if(this.keyPair=await e.getKey(this.wallet._networkId,r.accountId),!this.keyPair){this.keyPair=Pe.KeyPair.fromRandom("ed25519");const a=this.keyPair.getPublicKey().toString();await e.setKey(this.wallet._networkId,r.accountId,this.keyPair),await r.addKey(a)}this._address=await this.wallet.getAccountId(),this.providerInstance=this.wallet._near.connection.provider}async getTx(e){const r=await this.providerInstance,[a,n]=e.split(":"),i=await r.txStatusReceipts(M.decode(n),a),s=await r.block(i.transaction_outcome.block_hash),d=(await r.block({finality:"final"})).header.height;if(i.receipts_outcome[0].outcome.status.SuccessValue!=="")throw new Error("Transaction failed!");const u=i.receipts[0].receipt.Action.actions[0].Transfer.deposit??0;return{from:a,to:i.transaction.receiver_id,amount:new g(u),blockHeight:new g(s.header.height),pending:!1,confirmed:d-s.header.height>=this.minConfirm}}ownerToAddress(e){const r=typeof e=="string"?e:M.encode(e);return b.Buffer.from(M.decode(r.replace("ed25519:",""))).toString("hex")}async sign(e){return this.getSigner().sign(e)}getSigner(){return new ee(this.keyPair.secretKey)}async verify(e,r,a){return ee.verify(e,r,a)}async getCurrentHeight(){const e=await this.providerInstance.status();return new g(e.sync_info.latest_block_height)}async getFee(e,r){const a=(await this.providerInstance.block({finality:"final"})).header.height,n=await this.providerInstance.gasPrice(a);return new g(n.gas_price).multipliedBy(45e10)}async sendTx(e){const r=await this.providerInstance.sendTransaction(e);return`${this.address}:${r.transaction.hash}`}async createTx(e,r,a){if(!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");const n=await this.providerInstance.query({request_type:"view_access_key",finality:"final",account_id:this.address,public_key:this.keyPair.getPublicKey().toString()}),i=++n.nonce,s=b.Buffer.from(M.decode(n.block_hash)),d=[z.actionCreators.transfer(new Ue(new g(e).toString()))],u=z.createTransaction(this.address,this.keyPair.getPublicKey(),r,i,d,s),p=$e.serialize(z.SCHEMA,u),h=new Uint8Array(De.sha256.array(p)),_=this.keyPair.sign(h);return{tx:new z.SignedTransaction({transaction:u,signature:new z.Signature({keyType:u.publicKey.keyType,data:_.signature})}),txId:void 0}}async getPublicKey(){return b.Buffer.from(this.keyPair.getPublicKey().data)}}class tt extends O{constructor(e){super(e);c(this,"contractInstance");c(this,"contractAddress");this.contractAddress=e.contractAddress}async getContract(){return this.contractInstance||(this.contractInstance=new Ke(this.contractAddress,rt,this.w3signer),this.base=["wei",Math.pow(10,await this.contractInstance.decimals())]),this.contractInstance}async getTx(e){const r=await this.providerInstance.getTransaction(e);if(!r)throw new Error("Tx doesn't exist");if(r.data.length!==138||r.data.slice(2,10)!=="a9059cbb")throw new Error("Tx isn't a ERC20 transfer");const a=`0x${r.data.slice(34,74)}`,n=new g(r.data.slice(74),16);return{from:r.from,to:a,blockHeight:r.blockNumber?new g(r.blockNumber):void 0,amount:n,pending:!r.blockNumber,confirmed:r.confirmations>=this.minConfirm}}async getFee(e,r){const a="0x"+new g(e).toString(16),n=await this.getContract(),i=await this.providerInstance.getGasPrice(),s=await n.estimateGas.transfer(r,a),d=new g(i.mul(s).toString()),[u]=await this.getGas(),p=u.multipliedBy(d),h=new g(await this.price());return new g(p).dividedToIntegerBy(h)}async createTx(e,r,a){const n=await this.getContract(),i="0x"+new g(e).toString(16),s=await n.populateTransaction.transfer(r,i);if(s.gasPrice=await this.providerInstance.getGasPrice(),s.gasLimit=await n.estimateGas.transfer(r,i),s.chainId=(await this.providerInstance.getNetwork()).chainId,!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");return s.nonce=await this.providerInstance.getTransactionCount(this.address),{txId:void 0,tx:s}}async getGas(){return[new g(await ke("ETH")),1e18]}}const rt=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];class at extends Q{constructor(e){super(e);c(this,"signerInstance");c(this,"_publicKey");this.base=["aptom",1e8]}async getProvider(){return this.providerInstance??(this.providerInstance=new Fe(this.providerUrl))}async getTx(e){const a=await(await this.getProvider()).waitForTransactionWithResult(e,{timeoutSecs:1,checkSuccess:!0}),n=a==null?void 0:a.payload;if(!a.success)throw new Error((a==null?void 0:a.vm_status)??"Unknown Aptos error");if(!((n==null?void 0:n.function)==="0x1::coin::transfer"&&(n==null?void 0:n.type_arguments[0])==="0x1::aptos_coin::AptosCoin"&&(a==null?void 0:a.vm_status)==="Executed successfully"))throw new Error(`Aptos tx ${e} failed validation`);const i=a.type==="pending_transaction";return{to:n.arguments[0],from:a.sender,amount:new g(n.arguments[1]),pending:i,confirmed:!i}}ownerToAddress(e){const r=Le.sha3_256.create();return r.update(b.Buffer.from(e)),r.update("\0"),`0x${r.hex()}`}async sign(e){return await this.getSigner().sign(e)}getSigner(){return this.signerInstance??(this.signerInstance=new te(this.wallet,this._publicKey))}async verify(e,r,a){return await te.verify(e,r,a)}async getCurrentHeight(){return new g((await(await this.getProvider()).client.blocks.httpRequest.request({method:"GET",url:"/"})).block_height)}async getFee(e,r){const a=await this.getProvider();if(!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");const i=await new qe(a,{sender:this.address}).build("0x1::coin::transfer",["0x1::aptos_coin::AptosCoin"],[r??"0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9",new g(e).toNumber()]),d=new ze(h=>{const _=new Uint8Array(64);return new He.Ed25519Signature(_)},await this.getPublicKey()).sign(i),u={estimate_gas_unit_price:!0,estimate_max_gas_amount:!0},p=await a.client.request.request({url:"/transactions/simulate",query:u,method:"POST",body:d,mediaType:"application/x.aptos.signed_transaction+bcs"});return{gasUnitPrice:+p[0].gas_unit_price,maxGasAmount:+p[0].max_gas_amount}}async sendTx(e){return(await this.wallet.signAndSubmitTransaction(e)).hash}async createTx(e,r,a){return{txId:void 0,tx:{arguments:[r,new g(e).toNumber()],function:"0x1::coin::transfer",type:"entry_function_payload",type_arguments:["0x1::aptos_coin::AptosCoin"]}}}async getPublicKey(){return this._publicKey??(this._publicKey=b.Buffer.from((await this.wallet.account()).publicKey.toString().slice(2),"hex"))}async ready(){var r;this._publicKey=await this.getPublicKey(),this._address=this.ownerToAddress(this._publicKey);const e=await this.getProvider();this._address=await e.lookupOriginalAddress(this.address??"").then(a=>a.toString()).catch(a=>this._address),((r=this._address)==null?void 0:r.length)==66&&this._address.charAt(2)==="0"&&(this._address=this._address.slice(0,2)+this._address.slice(3))}}class nt extends O{}class st extends O{async createTx(t,e,r){const a=this.w3signer,n={to:e,from:this.address,value:t.toString(),gasLimit:BigInt(0)},i=await this.provider.estimateGas(n);return n.gasLimit=i,{tx:await a.populateTransaction(n),txId:void 0}}async getTx(t){const r=await this.provider.getTransaction(t);if(!r)throw new Error("Tx doesn't exist");if(!r.to)throw new Error(`Unable to resolve transactions ${t} receiver`);return{from:r.from,to:r.to,blockHeight:r.blockNumber?new g(r.blockNumber):void 0,amount:new g(r.value.toString()),pending:!r.blockNumber,confirmed:await r.confirmations()>=this.minConfirm}}async ready(){const t=this.wallet;this.provider=t;const e=await t.getSigner();e._signTypedData=async(r,a,n)=>e.signTypedData(r,a,n),t.getSigner=()=>e,this.wallet=t,await super.ready()}}function it(o){switch(o.token){case"ethereum":return q("ethereum",o.providerName,{irys:o.irys,name:"ethereum",ticker:"ETH",providerUrl:o.providerUrl??"https://cloudflare-eth.com/",wallet:o.wallet});case"matic":return q("ethereum",o.providerName,{irys:o.irys,name:"matic",ticker:"MATIC",providerUrl:o.providerUrl??"https://polygon-rpc.com",wallet:o.wallet,minConfirm:1});case"arbitrum":return q("ethereum",o.providerName,{irys:o.irys,name:"arbitrum",ticker:"ETH",providerUrl:o.providerUrl??"https://arb1.arbitrum.io/rpc",wallet:o.wallet});case"bnb":return q("ethereum",o.providerName,{irys:o.irys,name:"bnb",ticker:"BNB",providerUrl:o.providerUrl??"https://bsc-dataseed.binance.org",wallet:o.wallet});case"avalanche":return q("ethereum",o.providerName,{irys:o.irys,name:"avalanche",ticker:"AVAX",providerUrl:o.providerUrl??"https://api.avax.network/ext/bc/C/rpc",wallet:o.wallet});case"boba-eth":return q("ethereum",o.providerName,{irys:o.irys,name:"boba-eth",ticker:"ETH",providerUrl:o.providerUrl??"https://mainnet.boba.network/",minConfirm:1,wallet:o.wallet});case"boba":{const t=new tt({irys:o.irys,name:"boba",ticker:"BOBA",providerUrl:o.providerUrl??"https://mainnet.boba.network/",contractAddress:o.contractAddress??"0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7",minConfirm:1,wallet:o.wallet});return t.price=async()=>{var r;const e=await W.post("https://api.livecoinwatch.com/coins/single",JSON.stringify({currency:"USD",code:`${t.ticker}`}),{headers:{"x-api-key":"75a7a824-6577-45e6-ad86-511d590c7cc8","content-type":"application/json"}});if(await S.checkAndThrow(e,"Getting price data"),!((r=e==null?void 0:e.data)!=null&&r.rate))throw new Error(`unable to get price for ${t.name}`);return+e.data.rate},t}case"solana":return new Re({irys:o.irys,name:"solana",ticker:"SOL",providerUrl:o.providerUrl??"https://api.mainnet-beta.solana.com/",wallet:o.wallet});case"near":return new et({irys:o.irys,name:"near",ticker:"NEAR",providerUrl:o.providerUrl??"https://rpc.mainnet.near.org",wallet:o.wallet});case"aptos":return new at({irys:o.irys,name:"aptos",ticker:"APTOS",providerUrl:o.providerUrl??"https://fullnode.mainnet.aptoslabs.com/v1",wallet:o.wallet});default:throw new Error(`Unknown/Unsupported token ${o.token}`)}}function q(o,t,e){switch(o){case"ethereum":switch(t){case"ethersv5":return new nt(e);case"ethersv6":return new st(e);default:return new O(e)}}}class ot{constructor(t){c(this,"irys");this.irys=t}async upload(t,e){return this.irys.uploadWithReceipt(t,e)}async uploadProof(t){return await this.irys.uploadWithReceipt("",{tags:Object.entries({dataProtocol:"Provenance-Confirmation",...t}).map(([e,r])=>({name:oe[e],value:r}))})}async getAllProofs(t,e){var s,d;const r=Object.entries(t).map(([u,p])=>({name:oe[u],values:[p]}));if(r.length===0)throw new Error("Getting a provenance proof requires at least one query element");const a=`
    query ($tags: [TagFilter!]) {
      transactions(tags: $tags) {
        edges {
          node {
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            tags {
              name
              value
            }
          }
        }
      }
    }
    `,n=[];let i=null;do{const u=await this.irys.api.post("/graphql",{query:a,variables:{tags:r,limit:(e==null?void 0:e.limit)??null,after:i}},void 0);i=(d=(s=u.data.data.transactions)==null?void 0:s.pageInfo)!=null&&d.hasNextPage?u.data.data.transactions.pageInfo.endCursor:null,n.push(...u.data.data.transactions.edges.map(p=>p.node))}while(i);return n}async getProof(t){const e=(await this.getAllProofs(t,{limit:1})).at(0);if(!e)throw new Error(`Unable to locate proof with fields ${JSON.stringify(t)}`);return e}}const oe={dataProtocol:"Data-Protocol",hashingAlgo:"Hashing-Algo",dataHash:"Data-Hash",uploadedFor:"Uploaded-For",prompt:"Prompt",promptHash:"Prompt-Hash",model:"Model"};class ct{constructor(t){c(this,"irys");this.irys=t}async getById(t){const e=(await this.query({ids:[t],limit:1})).at(0);if(!e)throw new Error(`Unable to locate tx with id ${t}`);return e}async getByOwner(t){const e=(await this.query({owners:[t],limit:1})).at(0);if(!e)throw new Error(`Unable to locate tx with owner ${t}`);return e}async getByTag(t,e){const r=(await this.query({tags:[{name:t,values:[e]}],limit:1})).at(0);if(!r)throw new Error(`Unable to locate tx with tag ${t}:${e}`);return r}async query(t){var n,i;const e=`
    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {
      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {
        edges {
          cursor
          node {
            address
            currency
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            signature
            tags {
              name
              value
            }
            timestamp
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
    `,r=[];let a=null;do{const s=await this.irys.api.post("/graphql",{query:e,variables:{...t,after:a??t.after}},void 0);a=(i=(n=s.data.data.transactions)==null?void 0:n.pageInfo)!=null&&i.hasNextPage?s.data.data.transactions.pageInfo.endCursor:null,r.push(...s.data.data.transactions.edges.map(d=>d.node))}while(a);return r}}const ut=Symbol("not readable"),dt=Symbol("readable"),ht=Symbol("ended"),lt=Symbol("errored"),C={notReadable:ut,readable:dt,ended:ht,errored:lt};class gt{constructor(t,{size:e}={}){c(this,"_stream");c(this,"_error");c(this,"_state",C.notReadable);c(this,"_size");c(this,"_rejections",new Set);this._stream=t,this._size=e;const r=["_handleStreamEnd","_handleStreamError"];for(const a of r)Object.defineProperty(this,a,{configurable:!0,writable:!0,value:this[a].bind(this)});t.once("error",this._handleStreamError),t.once("end",this._handleStreamEnd),t.on("readable",()=>{this._state=C.readable})}get closed(){return this._state===C.ended}[Symbol.asyncIterator](){return this}async next(){switch(this._state){case C.notReadable:{let t,e;try{t=this._untilReadable(),e=this._untilEnd(),await Promise.race([t.promise,e.promise])}finally{t!=null&&t.close(),e!=null&&e.close()}return this.next()}case C.ended:return this.close(),{done:!0,value:void 0};case C.errored:throw this.close(),this._error;case C.readable:{const t=this._size?this._stream.read(this._size):this._stream.read();return t!==null?{done:!1,value:t}:(this._state=C.notReadable,await new Promise(e=>setTimeout(r=>r(!0),0,e)),this.next())}}}_untilReadable(){let t;const e=new Promise((a,n)=>{t=()=>{this._state=C.readable,this._rejections.delete(n),a()},this._state,C.readable,this._stream.once("readable",t),this._rejections.add(n)});return{close:()=>{t!=null&&this._stream.removeListener("readable",t)},promise:e}}_untilEnd(){let t;const e=new Promise((a,n)=>{t=()=>{this._state=C.ended,this._rejections.delete(n),a()},this._stream.once("end",t),this._rejections.add(n)});return{close:()=>{t!=null&&this._stream.removeListener("end",t)},promise:e}}return(){return this._state=C.ended,this.next()}throw(t){return this._error=t,this._state=C.errored,this.next()}close(t){this._stream.removeListener("end",this._handleStreamEnd),this._stream.removeListener("error",this._handleStreamError),this._state=C.ended,this._stream.destroy(t)}_handleStreamError(t){this._error=t,this._state=C.errored;for(const e of this._rejections)e(t)}_handleStreamEnd(){this._state=C.ended}get state(){return this._state}}class pt extends Oe.EventEmitter{constructor(e,r){super({captureRejections:!0});c(this,"tokenConfig");c(this,"api");c(this,"uploadID");c(this,"token");c(this,"chunkSize");c(this,"batchSize");c(this,"paused",!1);c(this,"isResume",!1);c(this,"uploadOptions");c(this,"arbundles");this.tokenConfig=e,this.arbundles=this.tokenConfig.irys.arbundles,this.api=r,this.token=this.tokenConfig.name,this.chunkSize=25e6,this.batchSize=5,this.uploadID=""}setResumeData(e){return e&&(this.uploadID=e,this.isResume=!0),this}getResumeData(){return this.uploadID}setChunkSize(e){if(e<1)throw new Error("Invalid chunk size (must be >=1)");return this.chunkSize=e,this}setBatchSize(e){if(e<1)throw new Error("Invalid batch size (must be >=1)");return this.batchSize=e,this}pause(){this.emit("pause"),this.paused=!0}resume(){this.paused=!1,this.emit("resume")}async uploadTransaction(e,r){return this.uploadOptions=r,this.arbundles.DataItem.isDataItem(e)?this.runUpload(e.getRaw()):this.runUpload(e)}async uploadData(e,r){return this.uploadOptions=r==null?void 0:r.upload,this.runUpload(e,{...r})}async runUpload(e,r){var X;let a=this.uploadID;const n=r===void 0,i={"x-chunking-version":"2"};let s;if(!a)s=await this.api.get(`/chunks/${this.token}/-1/-1`,{headers:i}),S.checkAndThrow(s,"Getting upload token"),this.uploadID=a=s.data.id;else{if(s=await this.api.get(`/chunks/${this.token}/${a}/-1`,{headers:i}),s.status===404)throw new Error("Upload ID not found - your upload has probably expired.");if(S.checkAndThrow(s,"Getting upload info"),this.chunkSize!=+s.data.size)throw new Error(`Chunk size not equal to that of a previous upload (${+s.data.size}).`)}const{max:d,min:u}=s.data;if(this.chunkSize<+u||this.chunkSize>+d)throw new Error(`Chunk size out of allowed range: ${u} - ${d}`);let p=0;const h=(w,k,R)=>new Promise(K=>{H(async G=>{await this.api.post(`/chunks/${this.token}/${a}/${k}`,w,{headers:{"Content-Type":"application/octet-stream",...i},maxBodyLength:1/0,maxContentLength:1/0}).then(N=>{if((N==null?void 0:N.status)>=300){const Y={res:N,id:R,offset:k,size:w.length};throw this.emit("chunkError",Y),(N==null?void 0:N.status)===402&&G(new Error("Not enough funds to send data")),Y}this.emit("chunkUpload",{id:R,offset:k,size:w.length,totalUploaded:p+=w.length}),K({o:k,d:N})})})}),_=s.data.chunks??[],E=new ae.PassThrough;let l=b.Buffer.alloc(0),y=!1,x=!0;E.on("end",()=>y=!0),E.on("error",w=>{throw new Error(`Error processing readable: ${w}`)});const T=async w=>{for(;!y;){if(l.length>=w)return k=b.Buffer.from(l.slice(0,w)),l=l.slice(w),k;var k=E.read(w);if(k===null){await new Promise(R=>setTimeout(K=>K(!0),0,R));continue}if(k.length===w)return k;l=b.Buffer.concat([l,k])}for(;l.length>=w;)return k=b.Buffer.from(l.slice(0,w)),l=l.slice(w),k;return x=!1,l};let f,P;if(!n){f=this.arbundles.createData("",this.tokenConfig.getSigner(),{...r,anchor:(r==null?void 0:r.anchor)??ye.randomBytes(32).toString("base64").slice(0,32)});const w=f.getRaw();P=w.length,E.write(w),p-=w.length}if(b.Buffer.isBuffer(e))E.write(e),E.end();else if("pipe"in e)e.pipe(E);else throw new Error("Input data is not a buffer or a compatible stream (no .pipe method)");let B=0;const v=new Set;let A=0,I,m,U;if(!n){m=new ae.PassThrough;const w=f.getRaw().length;if(this.chunkSize<P)throw new Error(`Configured chunk size is too small for transaction header! (${this.chunkSize} < ${P})`);I=await T(this.chunkSize),A++,B+=I.length,m.write(I.slice(w));const k=[this.arbundles.stringToBuffer("dataitem"),this.arbundles.stringToBuffer("1"),this.arbundles.stringToBuffer(f.signatureType.toString()),f.rawOwner,f.rawTarget,f.rawAnchor,f.rawTags,new gt(m)];U=this.arbundles.deepHash(k)}let F=_.pop();for(;x;){if(this.paused&&await new Promise(R=>this.on("resume",()=>R(void 0))),F&&+F[0]-B<=this.chunkSize){const K=F[1],G=await T(K);n||m.write(G),B+=K,F=_.pop(),A++,p+=K;continue}const w=await T(this.chunkSize);for(n||m.write(w);v.size>=this.batchSize;){const[R]=await Promise.race(v);v.delete(R)}const k=(async()=>await h(w,B,++A))().then(R=>[k,R]);v.add(k),B+=w.length}if(m&&m.end(),await Promise.all(v),!n){const w=await U,k=b.Buffer.from(await this.tokenConfig.getSigner().sign(w));I.set(k,2),await h(I,0,0)}const D=await this.api.post(`/chunks/${this.token}/${a}/-1`,null,{headers:{"Content-Type":"application/octet-stream",...i},timeout:((X=this.api.config)==null?void 0:X.timeout)??4e4*10});if(D.status===402)throw new Error("Not enough funds to send data");if(S.checkAndThrow(D,"Finalising upload",[201]),D.status===201)throw new Error(D.data);return D.data.verify=S.verifyReceipt.bind({},this.arbundles,D.data.data),this.emit("done",D),D}get completionPromise(){return new Promise(e=>this.on("done",e))}}const ce=5e7;class wt{constructor(t,e,r,a,n){c(this,"api");c(this,"token");c(this,"tokenConfig");c(this,"utils");c(this,"contentTypeOverride");c(this,"forceUseChunking");c(this,"arbundles");c(this,"irysTransaction");this.api=t,this.token=r,this.tokenConfig=a,this.arbundles=this.tokenConfig.irys.arbundles,this.utils=e,this.irysTransaction=n}async uploadTransaction(t,e){let r;const a=this.arbundles.DataItem.isDataItem(t);if(this.forceUseChunking||a&&t.getRaw().length>=ce||!a)r=await this.chunkedUploader.uploadTransaction(a?t.getRaw():t,e);else{const{url:n,timeout:i,headers:s}=this.api.getConfig(),d={"Content-Type":"application/octet-stream",...s};if(r=await this.api.post(new URL(`/tx/${this.token}`,n).toString(),t.getRaw(),{headers:d,timeout:i,maxBodyLength:1/0}),r.status===201)throw new Error(r.data)}switch(r.status){case 402:throw new Error("Not enough funds to send data");default:if(r.status>=400)throw new Error(`whilst uploading Irys transaction: ${r.status} ${r.statusText}`)}return r.data.verify=async()=>this.utils.verifyReceipt(r.data),r}async uploadData(t,e){if(typeof t=="string"&&(t=b.Buffer.from(t)),b.Buffer.isBuffer(t)&&t.length<=ce){const r=this.arbundles.createData(t,this.tokenConfig.getSigner(),{...e,anchor:(e==null?void 0:e.anchor)??xe.randomBytes(32).toString("base64").slice(0,32)});return await r.sign(this.tokenConfig.getSigner()),(await this.uploadTransaction(r,{...e==null?void 0:e.upload})).data}return(await this.chunkedUploader.uploadData(t,e)).data}async concurrentUploader(t,e){const r=[],a=e!=null&&e.logFunction?e==null?void 0:e.logFunction:async s=>{},n=(e==null?void 0:e.concurrency)??5,i=await Me.PromisePool.for(t).withConcurrency(n>=1?n:5).handleError(async(s,d)=>{if(r.push(s),s.message==="Not enough funds to send data")throw s}).process(async(s,d,u)=>{await H(async p=>{try{const h=await this.processItem(s,e==null?void 0:e.itemOptions);return d%n==0&&await a(`Processed ${d} Items`),e!=null&&e.resultProcessor?await e.resultProcessor({item:s,res:h,i:d}):{item:s,res:h,i:d}}catch(h){throw(h==null?void 0:h.message)==="Not enough funds to send data"&&p(h),h}},{retries:3,minTimeout:1e3,maxTimeout:1e4})});return{errors:r,results:i.results}}async processItem(t,e){return this.arbundles.DataItem.isDataItem(t)?this.uploadTransaction(t,{...e==null?void 0:e.upload}):this.uploadData(t,e)}async generateManifest(t){const{items:e,indexFile:r}=t,a={manifest:"arweave/paths",version:"0.1.0",paths:{}};if(r){if(!e.has(r))throw new Error(`Unable to access item: ${r}`);a.index={path:r}}for(const[n,i]of e.entries())a.paths[n]={id:i};return a}get chunkedUploader(){return new pt(this.tokenConfig,this.api)}set useChunking(t){typeof t=="boolean"&&(this.forceUseChunking=t)}set contentType(t){this.contentTypeOverride=t}async uploadBundle(t,e){const r=(e==null?void 0:e.throwawayKey)??await this.arbundles.getCryptoDriver().generateJWK(),a=new ve(r),n=t.map(p=>this.arbundles.DataItem.isDataItem(p)?p:this.arbundles.createData(p,a)),i=await this.arbundles.bundleAndSignData(n,a),s=this.arbundles.createData(i.getRaw(),this.tokenConfig.getSigner(),{tags:[{name:"Bundle-Format",value:"binary"},{name:"Bundle-Version",value:"2.0.0"}]});await s.sign(this.tokenConfig.getSigner());const d=await this.uploadTransaction(s,e),u=$(b.Buffer.from(await this.arbundles.getCryptoDriver().hash($.toBuffer($(a.publicKey)))));return{...d,txs:n,throwawayKey:r,throwawayKeyAddress:u}}}class ue extends wt{constructor(e){super(e.api,e.utils,e.token,e.tokenConfig,e.IrysTransaction);c(this,"irys");this.irys=e}async uploadFile(e,r){const n=(r!=null&&r.tags?r.tags.some(({name:i})=>i.toLowerCase()==="content-type"):!1)?r==null?void 0:r.tags:[...(r==null?void 0:r.tags)??[],{name:"Content-Type",value:e.type}];return this.uploadData(b.Buffer.from(await e.arrayBuffer()),{tags:n,...r})}async uploadFolder(e,r){const a=[],n=new Map,i=(r==null?void 0:r.throwawayKey)??await this.irys.arbundles.getCryptoDriver().generateJWK(),s=new ve(i);for(const h of e){const _=h.webkitRelativePath?h.webkitRelativePath:h.name,l=(h.tags?h.tags.some(({name:x})=>x.toLowerCase()==="content-type"):!1)?h.tags:[...h.tags??[],{name:"Content-Type",value:h.type}],y=this.irys.arbundles.createData(b.Buffer.from(await h.arrayBuffer()),s,{tags:l});await y.sign(s),a.push(y),n.set(_,y.id)}const d=await this.generateManifest({items:n,indexFile:r==null?void 0:r.indexFileRelPath}),u=this.irys.arbundles.createData(JSON.stringify(d),r!=null&&r.seperateManifestTx?this.irys.tokenConfig.getSigner():s,{tags:[{name:"Type",value:"manifest"},{name:"Content-Type",value:"application/x.arweave-manifest+json"},...(r==null?void 0:r.manifestTags)??[]]});(r==null?void 0:r.seperateManifestTx)===!0?(await u.sign(this.irys.tokenConfig.getSigner()),await this.uploadTransaction(u,{...r})):(await u.sign(s),a.push(u));const p=await this.uploadBundle(a,{...r});return{...p.data,manifestId:u.id,manifest:d,throwawayKey:p.throwawayKey,throwawayKeyAddress:p.throwawayKeyAddress,txs:p.txs}}}class de extends J{constructor({url:e,token:r,wallet:a,config:n}){switch(e){case void 0:case"node1":e="https://node1.irys.xyz";break;case"node2":e="https://node2.irys.xyz";break;case"devnet":e="https://devnet.irys.xyz";break}const i=new URL(e);super({url:i,arbundles:Je});c(this,"tokenConfig");c(this,"uploader");c(this,"uploadFolder");c(this,"uploadFile");if(this.api=new Ve({url:i,timeout:(n==null?void 0:n.timeout)??1e5,headers:n==null?void 0:n.headers}),this.tokenConfig=it({irys:this,token:r.toLowerCase(),wallet:a==null?void 0:a.provider,providerUrl:(n==null?void 0:n.providerUrl)??(a==null?void 0:a.rpcUrl),contractAddress:n==null?void 0:n.contractAddress,providerName:a==null?void 0:a.name}),this.token=this.tokenConfig.name,i.host==="devnet.irys.network"&&!((n==null?void 0:n.providerUrl)??((a==null?void 0:a.rpcUrl)||this.tokenConfig.inheritsRPC)))throw new Error(`Using ${i.host} requires a dev/testnet RPC to be configured! see https://docs.irys.network/sdk/using-devnet`);this.utils=new S(this.api,this.token,this.tokenConfig),this.uploader=new ue(this),this.funder=new We(this.utils),this.uploader=new ue(this),this.provenance=new ot(this),this.transactions=new ct(this),this.address="Please run `await Irys.ready()`",this.uploadFolder=this.uploader.uploadFolder.bind(this.uploader),this.uploadFile=this.uploader.uploadFile.bind(this.uploader)}}const Ot=Object.freeze(Object.defineProperty({__proto__:null,WebIrys:de,default:de},Symbol.toStringTag,{value:"Module"}));export{Q as B,M as b,Ot as i};
