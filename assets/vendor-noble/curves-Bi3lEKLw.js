import{h as zt,a as yt,b as st,i as Ct,c as P,d as ce,r as Dt,e as ae,f as ue,g as le}from"./hashes-DJrKYuPd.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tt=BigInt(0),qt=BigInt(1);function et(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function wt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function Kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Tt:BigInt("0x"+t)}function bt(t){return Kt(st(t))}function dt(t){return yt(t),Kt(st(Uint8Array.from(t).reverse()))}function Ot(t,n){return zt(t.toString(16).padStart(n*2,"0"))}function Et(t,n){return Ot(t,n).reverse()}function M(t,n,e){let r;if(typeof n=="string")try{r=zt(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(Ct(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const f=r.length;if(typeof e=="number"&&f!==e)throw new Error(t+" of length "+e+" expected, got "+f);return r}const St=t=>typeof t=="bigint"&&Tt<=t;function de(t,n,e){return St(t)&&St(n)&&St(e)&&n<=t&&t<e}function ot(t,n,e,r){if(!de(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function he(t){let n;for(n=0;t>Tt;t>>=qt,n+=1);return n}const Bt=t=>(qt<<BigInt(t))-qt;function we(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");const r=m=>new Uint8Array(m),f=m=>Uint8Array.of(m);let o=r(t),i=r(t),s=0;const l=()=>{o.fill(1),i.fill(0),s=0},p=(...m)=>e(i,o,...m),c=(m=r(0))=>{i=p(f(0),m),o=p(),m.length!==0&&(i=p(f(1),m),o=p())},x=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let m=0;const T=[];for(;m<n;){o=p();const N=o.slice();T.push(N),m+=o.length}return P(...T)};return(m,T)=>{l(),c(m);let N;for(;!(N=T(x()));)c();return l(),N}}function ht(t,n,e={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function r(f,o,i){const s=t[f];if(i&&s===void 0)return;const l=typeof s;if(l!==o||s===null)throw new Error(`param "${f}" is invalid: expected ${o}, got ${l}`)}Object.entries(n).forEach(([f,o])=>r(f,o,!1)),Object.entries(e).forEach(([f,o])=>r(f,o,!0))}function mt(t){const n=new WeakMap;return(e,...r)=>{const f=n.get(e);if(f!==void 0)return f;const o=t(e,...r);return n.set(e,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const X=BigInt(0),C=BigInt(1),J=BigInt(2),ge=BigInt(3),Vt=BigInt(4),Xt=BigInt(5),Ft=BigInt(8);function U(t,n){const e=t%n;return e>=X?e:n+e}function L(t,n,e){let r=t;for(;n-- >X;)r*=r,r%=e;return r}function Yt(t,n){if(t===X)throw new Error("invert: expected non-zero number");if(n<=X)throw new Error("invert: expected positive modulus, got "+n);let e=U(t,n),r=n,f=X,o=C;for(;e!==X;){const s=r/e,l=r%e,p=f-o*s;r=e,e=l,f=o,o=p}if(r!==C)throw new Error("invert: does not exist");return U(f,n)}function Wt(t,n){const e=(t.ORDER+C)/Vt,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function ye(t,n){const e=(t.ORDER-Xt)/Ft,r=t.mul(n,J),f=t.pow(r,e),o=t.mul(n,f),i=t.mul(t.mul(o,J),f),s=t.mul(o,t.sub(i,t.ONE));if(!t.eql(t.sqr(s),n))throw new Error("Cannot find square root");return s}function me(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-C,e=0;for(;n%J===X;)n/=J,e++;let r=J;const f=ft(t);for(;jt(f,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Wt;let o=f.pow(r,n);const i=(n+C)/J;return function(l,p){if(l.is0(p))return p;if(jt(l,p)!==1)throw new Error("Cannot find square root");let c=e,x=l.mul(l.ONE,o),S=l.pow(p,n),m=l.pow(p,i);for(;!l.eql(S,l.ONE);){if(l.is0(S))return l.ZERO;let T=1,N=l.sqr(S);for(;!l.eql(N,l.ONE);)if(T++,N=l.sqr(N),T===c)throw new Error("Cannot find square root");const g=C<<BigInt(c-T-1),v=l.pow(x,g);c=T,x=l.sqr(v),S=l.mul(S,x),m=l.mul(m,v)}return m}}function pe(t){return t%Vt===ge?Wt:t%Ft===Xt?ye:me(t)}const be=(t,n)=>(U(t,n)&C)===C,Ee=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Be(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=Ee.reduce((r,f)=>(r[f]="function",r),n);return ht(t,e),t}function xe(t,n,e){if(e<X)throw new Error("invalid exponent, negatives unsupported");if(e===X)return t.ONE;if(e===C)return n;let r=t.ONE,f=n;for(;e>X;)e&C&&(r=t.mul(r,f)),f=t.sqr(f),e>>=C;return r}function Pt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),f=n.reduce((i,s,l)=>t.is0(s)?i:(r[l]=i,t.mul(i,s)),t.ONE),o=t.inv(f);return n.reduceRight((i,s,l)=>t.is0(s)?i:(r[l]=t.mul(i,r[l]),t.mul(i,s)),o),r}function jt(t,n){const e=(t.ORDER-C)/J,r=t.pow(n,e),f=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),i=t.eql(r,t.neg(t.ONE));if(!f&&!o&&!i)throw new Error("invalid Legendre symbol result");return f?1:o?0:-1}function ve(t,n){n!==void 0&&ce(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function ft(t,n,e=!1,r={}){if(t<=X)throw new Error("invalid field: expected ORDER > 0, got "+t);let f,o;if(typeof n=="object"&&n!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const c=n;c.BITS&&(f=c.BITS),c.sqrt&&(o=c.sqrt),typeof c.isLE=="boolean"&&(e=c.isLE)}else typeof n=="number"&&(f=n),r.sqrt&&(o=r.sqrt);const{nBitLength:i,nByteLength:s}=ve(t,f);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const p=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:s,MASK:Bt(i),ZERO:X,ONE:C,create:c=>U(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return X<=c&&c<t},is0:c=>c===X,isValidNot0:c=>!p.is0(c)&&p.isValid(c),isOdd:c=>(c&C)===C,neg:c=>U(-c,t),eql:(c,x)=>c===x,sqr:c=>U(c*c,t),add:(c,x)=>U(c+x,t),sub:(c,x)=>U(c-x,t),mul:(c,x)=>U(c*x,t),pow:(c,x)=>xe(p,c,x),div:(c,x)=>U(c*Yt(x,t),t),sqrN:c=>c*c,addN:(c,x)=>c+x,subN:(c,x)=>c-x,mulN:(c,x)=>c*x,inv:c=>Yt(c,t),sqrt:o||(c=>(l||(l=pe(t)),l(p,c))),toBytes:c=>e?Et(c,s):Ot(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return e?dt(c):bt(c)},invertBatch:c=>Pt(p,c),cmov:(c,x,S)=>S?x:c});return Object.freeze(p)}function Qt(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Jt(t){const n=Qt(t);return n+Math.ceil(n/2)}function Se(t,n,e=!1){const r=t.length,f=Qt(n),o=Jt(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const i=e?dt(t):bt(t),s=U(i,n-C)+C;return e?Et(s,f):Ot(s,f)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it=BigInt(0),tt=BigInt(1);function at(t,n){const e=n.negate();return t?e:n}function te(t,n,e){const r=n==="pz"?i=>i.pz:i=>i.ez,f=Pt(t.Fp,e.map(r));return e.map((i,s)=>i.toAffine(f[s])).map(t.fromAffine)}function ee(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function It(t,n){ee(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),f=2**t,o=Bt(t),i=BigInt(t);return{windows:e,windowSize:r,mask:o,maxNumber:f,shiftBy:i}}function Ht(t,n,e){const{windowSize:r,mask:f,maxNumber:o,shiftBy:i}=e;let s=Number(t&f),l=t>>i;s>r&&(s-=o,l+=tt);const p=n*r,c=p+Math.abs(s)-1,x=s===0,S=s<0,m=n%2!==0;return{nextN:l,offset:c,isZero:x,isNeg:S,isNegF:m,offsetF:p}}function Ie(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function _e(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const _t=new WeakMap,ne=new WeakMap;function At(t){return ne.get(t)||1}function Lt(t){if(t!==it)throw new Error("invalid wNAF")}function re(t,n){return{constTimeNegate:at,hasPrecomputes(e){return At(e)!==1},unsafeLadder(e,r,f=t.ZERO){let o=e;for(;r>it;)r&tt&&(f=f.add(o)),o=o.double(),r>>=tt;return f},precomputeWindow(e,r){const{windows:f,windowSize:o}=It(r,n),i=[];let s=e,l=s;for(let p=0;p<f;p++){l=s,i.push(l);for(let c=1;c<o;c++)l=l.add(s),i.push(l);s=l.double()}return i},wNAF(e,r,f){let o=t.ZERO,i=t.BASE;const s=It(e,n);for(let l=0;l<s.windows;l++){const{nextN:p,offset:c,isZero:x,isNeg:S,isNegF:m,offsetF:T}=Ht(f,l,s);f=p,x?i=i.add(at(m,r[T])):o=o.add(at(S,r[c]))}return Lt(f),{p:o,f:i}},wNAFUnsafe(e,r,f,o=t.ZERO){const i=It(e,n);for(let s=0;s<i.windows&&f!==it;s++){const{nextN:l,offset:p,isZero:c,isNeg:x}=Ht(f,s,i);if(f=l,!c){const S=r[p];o=o.add(x?S.negate():S)}}return Lt(f),o},getPrecomputes(e,r,f){let o=_t.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&(typeof f=="function"&&(o=f(o)),_t.set(r,o))),o},wNAFCached(e,r,f){const o=At(e);return this.wNAF(o,this.getPrecomputes(o,e,f),r)},wNAFCachedUnsafe(e,r,f,o){const i=At(e);return i===1?this.unsafeLadder(e,r,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,f),r,o)},setWindowSize(e,r){ee(r,n),ne.set(e,r),_t.delete(e)}}}function Ae(t,n,e,r){let f=n,o=t.ZERO,i=t.ZERO;for(;e>it||r>it;)e&tt&&(o=o.add(f)),r&tt&&(i=i.add(f)),f=f.double(),e>>=tt,r>>=tt;return{p1:o,p2:i}}function oe(t,n,e,r){Ie(e,t),_e(r,n);const f=e.length,o=r.length;if(f!==o)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,s=he(BigInt(f));let l=1;s>12?l=s-3:s>4?l=s-2:s>0&&(l=2);const p=Bt(l),c=new Array(Number(p)+1).fill(i),x=Math.floor((n.BITS-1)/l)*l;let S=i;for(let m=x;m>=0;m-=l){c.fill(i);for(let N=0;N<o;N++){const g=r[N],v=Number(g>>BigInt(m)&p);c[v]=c[v].add(e[N])}let T=i;for(let N=c.length-1,g=i;N>0;N--)g=g.add(c[N]),T=T.add(g);if(S=S.add(T),m!==0)for(let N=0;N<l;N++)S=S.double()}return S}function $t(t,n){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Be(n),n}else return ft(t)}function se(t,n,e={}){if(!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const s of["p","n","h"]){const l=n[s];if(!(typeof l=="bigint"&&l>it))throw new Error(`CURVE.${s} must be positive bigint`)}const r=$t(n.p,e.Fp),f=$t(n.n,e.Fn),i=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(const s of i)if(!r.isValid(n[s]))throw new Error(`CURVE.${s} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:f}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const F=BigInt(0),V=BigInt(1),Nt=BigInt(2),Ne=BigInt(8),qe={zip215:!0};function Ze(t,n,e,r){const f=t.sqr(e),o=t.sqr(r),i=t.add(t.mul(n.a,f),o),s=t.add(t.ONE,t.mul(n.d,t.mul(f,o)));return t.eql(i,s)}function Re(t,n={}){const{Fp:e,Fn:r}=se("edwards",t,n),{h:f,n:o}=t;ht(n,{},{uvRatio:"function"});const i=Nt<<BigInt(r.BYTES*8)-V,s=N=>e.create(N),l=n.uvRatio||((N,g)=>{try{return{isValid:!0,value:e.sqrt(e.div(N,g))}}catch{return{isValid:!1,value:F}}});if(!Ze(e,t,t.Gx,t.Gy))throw new Error("bad curve params: generator point");function p(N,g,v=!1){const Z=v?V:F;return ot("coordinate "+N,g,Z,i),g}function c(N){if(!(N instanceof m))throw new Error("ExtendedPoint expected")}const x=mt((N,g)=>{const{ex:v,ey:Z,ez:O}=N,j=N.is0();g==null&&(g=j?Ne:e.inv(O));const h=s(v*g),q=s(Z*g),R=s(O*g);if(j)return{x:F,y:V};if(R!==V)throw new Error("invZ was invalid");return{x:h,y:q}}),S=mt(N=>{const{a:g,d:v}=t;if(N.is0())throw new Error("bad point: ZERO");const{ex:Z,ey:O,ez:j,et:h}=N,q=s(Z*Z),R=s(O*O),_=s(j*j),a=s(_*_),w=s(q*g),u=s(_*s(w+R)),d=s(a+s(v*s(q*R)));if(u!==d)throw new Error("bad point: equation left != right (1)");const y=s(Z*O),E=s(j*h);if(y!==E)throw new Error("bad point: equation left != right (2)");return!0});class m{constructor(g,v,Z,O){this.ex=p("x",g),this.ey=p("y",v),this.ez=p("z",Z,!0),this.et=p("t",O),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(g){if(g instanceof m)throw new Error("extended point not allowed");const{x:v,y:Z}=g||{};return p("x",v),p("y",Z),new m(v,Z,V,s(v*Z))}static normalizeZ(g){return te(m,"ez",g)}static msm(g,v){return oe(m,r,g,v)}_setWindowSize(g){this.precompute(g)}precompute(g=8,v=!0){return T.setWindowSize(this,g),v||this.multiply(Nt),this}assertValidity(){S(this)}equals(g){c(g);const{ex:v,ey:Z,ez:O}=this,{ex:j,ey:h,ez:q}=g,R=s(v*q),_=s(j*O),a=s(Z*q),w=s(h*O);return R===_&&a===w}is0(){return this.equals(m.ZERO)}negate(){return new m(s(-this.ex),this.ey,this.ez,s(-this.et))}double(){const{a:g}=t,{ex:v,ey:Z,ez:O}=this,j=s(v*v),h=s(Z*Z),q=s(Nt*s(O*O)),R=s(g*j),_=v+Z,a=s(s(_*_)-j-h),w=R+h,u=w-q,d=R-h,y=s(a*u),E=s(w*d),b=s(a*d),B=s(u*w);return new m(y,E,B,b)}add(g){c(g);const{a:v,d:Z}=t,{ex:O,ey:j,ez:h,et:q}=this,{ex:R,ey:_,ez:a,et:w}=g,u=s(O*R),d=s(j*_),y=s(q*Z*w),E=s(h*a),b=s((O+j)*(R+_)-u-d),B=E-y,A=E+y,I=s(d-v*u),$=s(b*B),Y=s(A*I),z=s(b*I),k=s(B*A);return new m($,Y,k,z)}subtract(g){return this.add(g.negate())}multiply(g){const v=g;ot("scalar",v,V,o);const{p:Z,f:O}=T.wNAFCached(this,v,m.normalizeZ);return m.normalizeZ([Z,O])[0]}multiplyUnsafe(g,v=m.ZERO){const Z=g;return ot("scalar",Z,F,o),Z===F?m.ZERO:this.is0()||Z===V?this:T.wNAFCachedUnsafe(this,Z,m.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}isTorsionFree(){return T.wNAFCachedUnsafe(this,o).is0()}toAffine(g){return x(this,g)}clearCofactor(){return f===V?this:this.multiplyUnsafe(f)}static fromBytes(g,v=!1){return yt(g),this.fromHex(g,v)}static fromHex(g,v=!1){const{d:Z,a:O}=t,j=e.BYTES;g=M("pointHex",g,j),et("zip215",v);const h=g.slice(),q=g[j-1];h[j-1]=q&-129;const R=dt(h),_=v?i:e.ORDER;ot("pointHex.y",R,F,_);const a=s(R*R),w=s(a-V),u=s(Z*a-O);let{isValid:d,value:y}=l(w,u);if(!d)throw new Error("Point.fromHex: invalid y coordinate");const E=(y&V)===V,b=(q&128)!==0;if(!v&&y===F&&b)throw new Error("Point.fromHex: x=0 and x_0=1");return b!==E&&(y=s(-y)),m.fromAffine({x:y,y:R})}static fromPrivateScalar(g){return m.BASE.multiply(g)}toBytes(){const{x:g,y:v}=this.toAffine(),Z=Et(v,e.BYTES);return Z[Z.length-1]|=g&V?128:0,Z}toRawBytes(){return this.toBytes()}toHex(){return st(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}m.BASE=new m(t.Gx,t.Gy,V,s(t.Gx*t.Gy)),m.ZERO=new m(F,V,V,F),m.Fp=e,m.Fn=r;const T=re(m,r.BYTES*8);return m}function ze(t,n){ht(n,{hash:"function"},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:e,hash:r}=n,{BASE:f,Fp:o,Fn:i}=t,s=i.ORDER,l=n.randomBytes||Dt,p=n.adjustScalarBytes||(h=>h),c=n.domain||((h,q,R)=>{if(et("phflag",R),q.length||R)throw new Error("Contexts/pre-hash are not supported");return h});function x(h){return i.create(h)}function S(h){return x(dt(h))}function m(h){const q=o.BYTES;h=M("private key",h,q);const R=M("hashed private key",r(h),2*q),_=p(R.slice(0,q)),a=R.slice(q,2*q),w=S(_);return{head:_,prefix:a,scalar:w}}function T(h){const{head:q,prefix:R,scalar:_}=m(h),a=f.multiply(_),w=a.toBytes();return{head:q,prefix:R,scalar:_,point:a,pointBytes:w}}function N(h){return T(h).pointBytes}function g(h=Uint8Array.of(),...q){const R=P(...q);return S(r(c(R,M("context",h),!!e)))}function v(h,q,R={}){h=M("message",h),e&&(h=e(h));const{prefix:_,scalar:a,pointBytes:w}=T(q),u=g(R.context,_,h),d=f.multiply(u).toBytes(),y=g(R.context,d,w,h),E=x(u+y*a);ot("signature.s",E,F,s);const b=o.BYTES,B=P(d,Et(E,b));return M("result",B,b*2)}const Z=qe;function O(h,q,R,_=Z){const{context:a,zip215:w}=_,u=o.BYTES;h=M("signature",h,2*u),q=M("message",q),R=M("publicKey",R,u),w!==void 0&&et("zip215",w),e&&(q=e(q));const d=dt(h.slice(u,2*u));let y,E,b;try{y=t.fromHex(R,w),E=t.fromHex(h.slice(0,u),w),b=f.multiplyUnsafe(d)}catch{return!1}if(!w&&y.isSmallOrder())return!1;const B=g(a,E.toBytes(),y.toBytes(),q);return E.add(y.multiplyUnsafe(B)).subtract(b).clearCofactor().is0()}return f.precompute(8),{getPublicKey:N,sign:v,verify:O,utils:{getExtendedPublicKey:T,randomPrivateKey:()=>l(o.BYTES),precompute(h=8,q=t.BASE){return q.precompute(h,!1)}},Point:t}}function Te(t){const n={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},e=t.Fp,r=ft(n.n,t.nBitLength,!0),f={Fp:e,Fn:r,uvRatio:t.uvRatio},o={hash:t.hash,randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:n,curveOpts:f,eddsaOpts:o}}function Oe(t,n){return Object.assign({},n,{ExtendedPoint:n.Point,CURVE:t})}function Ye(t){const{CURVE:n,curveOpts:e,eddsaOpts:r}=Te(t),f=Re(n,e),o=ze(f,r);return Oe(t,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);const je=BigInt(1),Mt=BigInt(2);BigInt(3);const He=BigInt(5),Le=BigInt(8),xt={p:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Le,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function $e(t){const n=BigInt(10),e=BigInt(20),r=BigInt(40),f=BigInt(80),o=xt.p,s=t*t%o*t%o,l=L(s,Mt,o)*s%o,p=L(l,je,o)*t%o,c=L(p,He,o)*p%o,x=L(c,n,o)*c%o,S=L(x,e,o)*x%o,m=L(S,r,o)*S%o,T=L(m,f,o)*m%o,N=L(T,f,o)*m%o,g=L(N,n,o)*c%o;return{pow_p_5_8:L(g,Mt,o)*t%o,b2:s}}function Me(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const Ut=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Ue(t,n){const e=xt.p,r=U(n*n*n,e),f=U(r*r*n,e),o=$e(t*f).pow_p_5_8;let i=U(t*r*o,e);const s=U(n*i*i,e),l=i,p=U(i*Ut,e),c=s===t,x=s===U(-t,e),S=s===U(-t*Ut,e);return c&&(i=l),(x||S)&&(i=p),be(i,e)&&(i=U(-i,e)),{isValid:c||x,value:i}}const ke=ft(xt.p,void 0,!0),Ge={...xt,Fp:ke,hash:ae,adjustScalarBytes:Me,uvRatio:Ue},on=Ye(Ge);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function kt(t){t.lowS!==void 0&&et("lowS",t.lowS),t.prehash!==void 0&&et("prehash",t.prehash)}class Ce extends Error{constructor(n=""){super(n)}}const W={Err:Ce,_tlv:{encode:(t,n)=>{const{Err:e}=W;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,f=wt(r);if(f.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?wt(f.length/2|128):"";return wt(t)+o+f+n},decode(t,n){const{Err:e}=W;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const f=n[r++],o=!!(f&128);let i=0;if(!o)i=f;else{const l=f&127;if(!l)throw new e("tlv.decode(long): indefinite length not supported");if(l>4)throw new e("tlv.decode(long): byte length is too big");const p=n.subarray(r,r+l);if(p.length!==l)throw new e("tlv.decode: length bytes not complete");if(p[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const c of p)i=i<<8|c;if(r+=l,i<128)throw new e("tlv.decode(long): not minimal encoding")}const s=n.subarray(r,r+i);if(s.length!==i)throw new e("tlv.decode: wrong value length");return{v:s,l:n.subarray(r+i)}}},_int:{encode(t){const{Err:n}=W;if(t<ut)throw new n("integer: negative integers are not allowed");let e=wt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=W;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return bt(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=W,f=M("signature",t),{v:o,l:i}=r.decode(48,f);if(i.length)throw new n("invalid signature: left bytes after parsing");const{v:s,l}=r.decode(2,o),{v:p,l:c}=r.decode(2,l);if(c.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(s),s:e.decode(p)}},hexFromSig(t){const{_tlv:n,_int:e}=W,r=n.encode(2,e.encode(t.r)),f=n.encode(2,e.encode(t.s)),o=r+f;return n.encode(48,o)}},ut=BigInt(0),lt=BigInt(1),De=BigInt(2),gt=BigInt(3),Ke=BigInt(4);function Ve(t,n,e){function r(f){const o=t.sqr(f),i=t.mul(o,f);return t.add(t.add(i,t.mul(f,n)),e)}return r}function ie(t,n,e){const{BYTES:r}=t;function f(o){let i;if(typeof o=="bigint")i=o;else{let s=M("private key",o);if(n){if(!n.includes(s.length*2))throw new Error("invalid private key");const l=new Uint8Array(r);l.set(s,l.length-s.length),s=l}try{i=t.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof o}`)}}if(e&&(i=t.create(i)),!t.isValidNot0(i))throw new Error("invalid private key: out of range [1..N-1]");return i}return f}function Xe(t,n={}){const{Fp:e,Fn:r}=se("weierstrass",t,n),{h:f,n:o}=t;ht(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:i}=n;if(i&&(!e.is0(t.a)||typeof i.beta!="bigint"||typeof i.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function s(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function l(_,a,w){const{x:u,y:d}=a.toAffine(),y=e.toBytes(u);if(et("isCompressed",w),w){s();const E=!e.isOdd(d);return P(fe(E),y)}else return P(Uint8Array.of(4),y,e.toBytes(d))}function p(_){yt(_);const a=e.BYTES,w=a+1,u=2*a+1,d=_.length,y=_[0],E=_.subarray(1);if(d===w&&(y===2||y===3)){const b=e.fromBytes(E);if(!e.isValid(b))throw new Error("bad point: is not on curve, wrong x");const B=S(b);let A;try{A=e.sqrt(B)}catch(Y){const z=Y instanceof Error?": "+Y.message:"";throw new Error("bad point: is not on curve, sqrt error"+z)}s();const I=e.isOdd(A);return(y&1)===1!==I&&(A=e.neg(A)),{x:b,y:A}}else if(d===u&&y===4){const b=e.fromBytes(E.subarray(a*0,a*1)),B=e.fromBytes(E.subarray(a*1,a*2));if(!m(b,B))throw new Error("bad point: is not on curve");return{x:b,y:B}}else throw new Error(`bad point: got length ${d}, expected compressed=${w} or uncompressed=${u}`)}const c=n.toBytes||l,x=n.fromBytes||p,S=Ve(e,t.a,t.b);function m(_,a){const w=e.sqr(a),u=S(_);return e.eql(w,u)}if(!m(t.Gx,t.Gy))throw new Error("bad curve params: generator point");const T=e.mul(e.pow(t.a,gt),Ke),N=e.mul(e.sqr(t.b),BigInt(27));if(e.is0(e.add(T,N)))throw new Error("bad curve params: a or b");function g(_,a,w=!1){if(!e.isValid(a)||w&&e.is0(a))throw new Error(`bad point coordinate ${_}`);return a}function v(_){if(!(_ instanceof h))throw new Error("ProjectivePoint expected")}const Z=mt((_,a)=>{const{px:w,py:u,pz:d}=_;if(e.eql(d,e.ONE))return{x:w,y:u};const y=_.is0();a==null&&(a=y?e.ONE:e.inv(d));const E=e.mul(w,a),b=e.mul(u,a),B=e.mul(d,a);if(y)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:E,y:b}}),O=mt(_=>{if(_.is0()){if(n.allowInfinityPoint&&!e.is0(_.py))return;throw new Error("bad point: ZERO")}const{x:a,y:w}=_.toAffine();if(!e.isValid(a)||!e.isValid(w))throw new Error("bad point: x or y not field elements");if(!m(a,w))throw new Error("bad point: equation left != right");if(!_.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function j(_,a,w,u,d){return w=new h(e.mul(w.px,_),w.py,w.pz),a=at(u,a),w=at(d,w),a.add(w)}class h{constructor(a,w,u){this.px=g("x",a),this.py=g("y",w,!0),this.pz=g("z",u),Object.freeze(this)}static fromAffine(a){const{x:w,y:u}=a||{};if(!a||!e.isValid(w)||!e.isValid(u))throw new Error("invalid affine point");if(a instanceof h)throw new Error("projective point not allowed");return e.is0(w)&&e.is0(u)?h.ZERO:new h(w,u,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){return te(h,"pz",a)}static fromBytes(a){return yt(a),h.fromHex(a)}static fromHex(a){const w=h.fromAffine(x(M("pointHex",a)));return w.assertValidity(),w}static fromPrivateKey(a){const w=ie(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return h.BASE.multiply(w(a))}static msm(a,w){return oe(h,r,a,w)}precompute(a=8,w=!0){return R.setWindowSize(this,a),w||this.multiply(gt),this}_setWindowSize(a){this.precompute(a)}assertValidity(){O(this)}hasEvenY(){const{y:a}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(a)}equals(a){v(a);const{px:w,py:u,pz:d}=this,{px:y,py:E,pz:b}=a,B=e.eql(e.mul(w,b),e.mul(y,d)),A=e.eql(e.mul(u,b),e.mul(E,d));return B&&A}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a,b:w}=t,u=e.mul(w,gt),{px:d,py:y,pz:E}=this;let b=e.ZERO,B=e.ZERO,A=e.ZERO,I=e.mul(d,d),$=e.mul(y,y),Y=e.mul(E,E),z=e.mul(d,y);return z=e.add(z,z),A=e.mul(d,E),A=e.add(A,A),b=e.mul(a,A),B=e.mul(u,Y),B=e.add(b,B),b=e.sub($,B),B=e.add($,B),B=e.mul(b,B),b=e.mul(z,b),A=e.mul(u,A),Y=e.mul(a,Y),z=e.sub(I,Y),z=e.mul(a,z),z=e.add(z,A),A=e.add(I,I),I=e.add(A,I),I=e.add(I,Y),I=e.mul(I,z),B=e.add(B,I),Y=e.mul(y,E),Y=e.add(Y,Y),I=e.mul(Y,z),b=e.sub(b,I),A=e.mul(Y,$),A=e.add(A,A),A=e.add(A,A),new h(b,B,A)}add(a){v(a);const{px:w,py:u,pz:d}=this,{px:y,py:E,pz:b}=a;let B=e.ZERO,A=e.ZERO,I=e.ZERO;const $=t.a,Y=e.mul(t.b,gt);let z=e.mul(w,y),k=e.mul(u,E),G=e.mul(d,b),D=e.add(w,u),H=e.add(y,E);D=e.mul(D,H),H=e.add(z,k),D=e.sub(D,H),H=e.add(w,d);let K=e.add(y,b);return H=e.mul(H,K),K=e.add(z,G),H=e.sub(H,K),K=e.add(u,d),B=e.add(E,b),K=e.mul(K,B),B=e.add(k,G),K=e.sub(K,B),I=e.mul($,H),B=e.mul(Y,G),I=e.add(B,I),B=e.sub(k,I),I=e.add(k,I),A=e.mul(B,I),k=e.add(z,z),k=e.add(k,z),G=e.mul($,G),H=e.mul(Y,H),k=e.add(k,G),G=e.sub(z,G),G=e.mul($,G),H=e.add(H,G),z=e.mul(k,H),A=e.add(A,z),z=e.mul(K,H),B=e.mul(D,B),B=e.sub(B,z),z=e.mul(D,k),I=e.mul(K,I),I=e.add(I,z),new h(B,A,I)}subtract(a){return this.add(a.negate())}is0(){return this.equals(h.ZERO)}multiply(a){const{endo:w}=n;if(!r.isValidNot0(a))throw new Error("invalid scalar: out of range");let u,d;const y=E=>R.wNAFCached(this,E,h.normalizeZ);if(w){const{k1neg:E,k1:b,k2neg:B,k2:A}=w.splitScalar(a),{p:I,f:$}=y(b),{p:Y,f:z}=y(A);d=$.add(z),u=j(w.beta,I,Y,E,B)}else{const{p:E,f:b}=y(a);u=E,d=b}return h.normalizeZ([u,d])[0]}multiplyUnsafe(a){const{endo:w}=n,u=this;if(!r.isValid(a))throw new Error("invalid scalar: out of range");if(a===ut||u.is0())return h.ZERO;if(a===lt)return u;if(R.hasPrecomputes(this))return this.multiply(a);if(w){const{k1neg:d,k1:y,k2neg:E,k2:b}=w.splitScalar(a),{p1:B,p2:A}=Ae(h,u,y,b);return j(w.beta,B,A,d,E)}else return R.wNAFCachedUnsafe(u,a)}multiplyAndAddUnsafe(a,w,u){const d=this.multiplyUnsafe(w).add(a.multiplyUnsafe(u));return d.is0()?void 0:d}toAffine(a){return Z(this,a)}isTorsionFree(){const{isTorsionFree:a}=n;return f===lt?!0:a?a(h,this):R.wNAFCachedUnsafe(this,o).is0()}clearCofactor(){const{clearCofactor:a}=n;return f===lt?this:a?a(h,this):this.multiplyUnsafe(f)}toBytes(a=!0){return et("isCompressed",a),this.assertValidity(),c(h,this,a)}toRawBytes(a=!0){return this.toBytes(a)}toHex(a=!0){return st(this.toBytes(a))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}h.BASE=new h(t.Gx,t.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO),h.Fp=e,h.Fn=r;const q=r.BITS,R=re(h,n.endo?Math.ceil(q/2):q);return h}function fe(t){return Uint8Array.of(t?2:3)}function Fe(t,n,e={}){ht(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||Dt,f=n.hmac||((u,...d)=>ue(n.hash,u,P(...d))),{Fp:o,Fn:i}=t,{ORDER:s,BITS:l}=i;function p(u){const d=s>>lt;return u>d}function c(u){return p(u)?i.neg(u):u}function x(u,d){if(!i.isValidNot0(d))throw new Error(`invalid signature ${u}: out of range 1..CURVE.n`)}class S{constructor(d,y,E){x("r",d),x("s",y),this.r=d,this.s=y,E!=null&&(this.recovery=E),Object.freeze(this)}static fromCompact(d){const y=i.BYTES,E=M("compactSignature",d,y*2);return new S(i.fromBytes(E.subarray(0,y)),i.fromBytes(E.subarray(y,y*2)))}static fromDER(d){const{r:y,s:E}=W.toSig(M("DER",d));return new S(y,E)}assertValidity(){}addRecoveryBit(d){return new S(this.r,this.s,d)}recoverPublicKey(d){const y=o.ORDER,{r:E,s:b,recovery:B}=this;if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");if(s*De<y&&B>1)throw new Error("recovery id is ambiguous for h>1 curve");const I=B===2||B===3?E+s:E;if(!o.isValid(I))throw new Error("recovery id 2 or 3 invalid");const $=o.toBytes(I),Y=t.fromHex(P(fe((B&1)===0),$)),z=i.inv(I),k=O(M("msgHash",d)),G=i.create(-k*z),D=i.create(b*z),H=t.BASE.multiplyUnsafe(G).add(Y.multiplyUnsafe(D));if(H.is0())throw new Error("point at infinify");return H.assertValidity(),H}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,i.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return P(i.toBytes(this.r),i.toBytes(this.s));if(d==="der")return zt(W.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return st(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return st(this.toBytes("compact"))}}const m=ie(i,e.allowedPrivateKeyLengths,e.wrapPrivateKey),T={isValidPrivateKey(u){try{return m(u),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const u=s;return Se(r(Jt(u)),u)},precompute(u=8,d=t.BASE){return d.precompute(u,!1)}};function N(u,d=!0){return t.fromPrivateKey(u).toBytes(d)}function g(u){if(typeof u=="bigint")return!1;if(u instanceof t)return!0;const y=M("key",u).length,E=o.BYTES,b=E+1,B=2*E+1;if(!(e.allowedPrivateKeyLengths||i.BYTES===b))return y===b||y===B}function v(u,d,y=!0){if(g(u)===!0)throw new Error("first arg must be private key");if(g(d)===!1)throw new Error("second arg must be public key");return t.fromHex(d).multiply(m(u)).toBytes(y)}const Z=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const d=bt(u),y=u.length*8-l;return y>0?d>>BigInt(y):d},O=n.bits2int_modN||function(u){return i.create(Z(u))},j=Bt(l);function h(u){return ot("num < 2^"+l,u,ut,j),i.toBytes(u)}function q(u,d,y=R){if(["recovered","canonical"].some(D=>D in y))throw new Error("sign() legacy options not supported");const{hash:E}=n;let{lowS:b,prehash:B,extraEntropy:A}=y;b==null&&(b=!0),u=M("msgHash",u),kt(y),B&&(u=M("prehashed msgHash",E(u)));const I=O(u),$=m(d),Y=[h($),h(I)];if(A!=null&&A!==!1){const D=A===!0?r(o.BYTES):A;Y.push(M("extraEntropy",D))}const z=P(...Y),k=I;function G(D){const H=Z(D);if(!i.isValidNot0(H))return;const K=i.inv(H),ct=t.BASE.multiply(H).toAffine(),nt=i.create(ct.x);if(nt===ut)return;const Q=i.create(K*i.create(k+nt*$));if(Q===ut)return;let vt=(ct.x===nt?0:2)|Number(ct.y&lt),rt=Q;return b&&p(Q)&&(rt=c(Q),vt^=1),new S(nt,rt,vt)}return{seed:z,k2sig:G}}const R={lowS:n.lowS,prehash:!1},_={lowS:n.lowS,prehash:!1};function a(u,d,y=R){const{seed:E,k2sig:b}=q(u,d,y);return we(n.hash.outputLen,i.BYTES,f)(E,b)}t.BASE.precompute(8);function w(u,d,y,E=_){const b=u;d=M("msgHash",d),y=M("publicKey",y),kt(E);const{lowS:B,prehash:A,format:I}=E;if("strict"in E)throw new Error("options.strict was renamed to lowS");if(I!==void 0&&!["compact","der","js"].includes(I))throw new Error('format must be "compact", "der" or "js"');const $=typeof b=="string"||Ct(b),Y=!$&&!I&&typeof b=="object"&&b!==null&&typeof b.r=="bigint"&&typeof b.s=="bigint";if(!$&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let z,k;try{if(Y)if(I===void 0||I==="js")z=new S(b.r,b.s);else throw new Error("invalid format");if($){try{I!=="compact"&&(z=S.fromDER(b))}catch(rt){if(!(rt instanceof W.Err))throw rt}!z&&I!=="der"&&(z=S.fromCompact(b))}k=t.fromHex(y)}catch{return!1}if(!z||B&&z.hasHighS())return!1;A&&(d=n.hash(d));const{r:G,s:D}=z,H=O(d),K=i.inv(D),ct=i.create(H*K),nt=i.create(G*K),Q=t.BASE.multiplyUnsafe(ct).add(k.multiplyUnsafe(nt));return Q.is0()?!1:i.create(Q.x)===G}return Object.freeze({getPublicKey:N,getSharedSecret:v,sign:a,verify:w,utils:T,Point:t,Signature:S})}function We(t){const n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},e=t.Fp,r=ft(n.n,t.nBitLength),f={Fp:e,Fn:r,allowedPrivateKeyLengths:t.allowedPrivateKeyLengths,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,wrapPrivateKey:t.wrapPrivateKey,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:f}}function Pe(t){const{CURVE:n,curveOpts:e}=We(t),r={hash:t.hash,hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:e,ecdsaOpts:r}}function Qe(t,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:t})}function Je(t){const{CURVE:n,curveOpts:e,ecdsaOpts:r}=Pe(t),f=Xe(n,e),o=Fe(f,r,e);return Qe(t,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function tn(t,n){const e=r=>Je({...t,hash:r});return{...e(n),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const en=BigInt(1),Zt=BigInt(2),Gt=(t,n)=>(t+n/Zt)/n;function nn(t){const n=pt.p,e=BigInt(3),r=BigInt(6),f=BigInt(11),o=BigInt(22),i=BigInt(23),s=BigInt(44),l=BigInt(88),p=t*t*t%n,c=p*p*t%n,x=L(c,e,n)*c%n,S=L(x,e,n)*c%n,m=L(S,Zt,n)*p%n,T=L(m,f,n)*m%n,N=L(T,o,n)*T%n,g=L(N,s,n)*N%n,v=L(g,l,n)*g%n,Z=L(v,s,n)*N%n,O=L(Z,e,n)*c%n,j=L(O,i,n)*T%n,h=L(j,r,n)*p%n,q=L(h,Zt,n);if(!Rt.eql(Rt.sqr(q),t))throw new Error("Cannot find square root");return q}const Rt=ft(pt.p,void 0,void 0,{sqrt:nn}),sn=tn({...pt,Fp:Rt,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=pt.n,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-en*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),f=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),s=Gt(o*t,n),l=Gt(-r*t,n);let p=U(t-s*e-l*f,n),c=U(-s*r-l*o,n);const x=p>i,S=c>i;if(x&&(p=n-p),S&&(c=n-c),p>i||c>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:x,k1:p,k2neg:S,k2:c}}}},le);export{on as e,sn as s};
