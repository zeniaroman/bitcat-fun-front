import{g as x}from"./address-C-94Rlzo.js";import{P as tr}from"./abstract-provider-BJATZ19F.js";import{S as nr}from"./abstract-signer-vaofOY7d.js";import{c as q,b as S,i as k,h as A,a as w,d as _,e as T,s as E,j as ir,k as j,g as sr,l as J}from"./bytes-BFUO92dS.js";import{k as l}from"./keccak256-BpI13PIi.js";import{t as L}from"./strings-BqJBhWqj.js";import{d as g,a as or,s as M,c as cr,r as ar}from"./properties-Bism-GXA.js";import{L as $}from"./logger-BIOSViGG.js";import{B as p}from"./bignumber-DuyZ-PBD.js";import{H as F,e as ur,d as R}from"./hdnode-De1GriMn.js";import{c as fr,r as hr,S as N}from"./signing-key-DZY4IiDE.js";import{e as mr,d as gr,a as dr}from"./json-wallets-DmRppK22.js";import{e as C}from"./rlp-L8r_OHwd.js";import{r as lr}from"./random-UwHXQyRf.js";function V(t){return l(L(t))}const yr="hash/5.8.0",pr=`Ethereum Signed Message:
`;function Q(t){return typeof t=="string"&&(t=L(t)),l(q([L(pr),L(String(t.length)),t]))}var wr=function(t,r,e,n){function s(o){return o instanceof e?o:new e(function(a){a(o)})}return new(e||(e=Promise))(function(o,a){function i(f){try{u(n.next(f))}catch(v){a(v)}}function c(f){try{u(n.throw(f))}catch(v){a(v)}}function u(f){f.done?o(f.value):s(f.value).then(i,c)}u((n=n.apply(t,r||[])).next())})};const h=new $(yr),W=new Uint8Array(32);W.fill(0);const vr=p.from(-1),X=p.from(0),Y=p.from(1),Er=p.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function xr(t){const r=w(t),e=r.length%32;return e?S([r,W.slice(e)]):A(r)}const Ar=_(Y.toHexString(),32),Pr=_(X.toHexString(),32),U={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"},D=["name","version","chainId","verifyingContract","salt"];function G(t){return function(r){return typeof r!="string"&&h.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`,`domain.${t}`,r),r}}const br={name:G("name"),version:G("version"),chainId:function(t){try{return p.from(t).toString()}catch{}return h.throwArgumentError('invalid domain value for "chainId"',"domain.chainId",t)},verifyingContract:function(t){try{return x(t).toLowerCase()}catch{}return h.throwArgumentError('invalid domain value "verifyingContract"',"domain.verifyingContract",t)},salt:function(t){try{const r=w(t);if(r.length!==32)throw new Error("bad length");return A(r)}catch{}return h.throwArgumentError('invalid domain value "salt"',"domain.salt",t)}};function I(t){{const r=t.match(/^(u?)int(\d*)$/);if(r){const e=r[1]==="",n=parseInt(r[2]||"256");(n%8!==0||n>256||r[2]&&r[2]!==String(n))&&h.throwArgumentError("invalid numeric width","type",t);const s=Er.mask(e?n-1:n),o=e?s.add(Y).mul(vr):X;return function(a){const i=p.from(a);return(i.lt(o)||i.gt(s))&&h.throwArgumentError(`value out-of-bounds for ${t}`,"value",a),_(i.toTwos(256).toHexString(),32)}}}{const r=t.match(/^bytes(\d+)$/);if(r){const e=parseInt(r[1]);return(e===0||e>32||r[1]!==String(e))&&h.throwArgumentError("invalid bytes width","type",t),function(n){return w(n).length!==e&&h.throwArgumentError(`invalid length for ${t}`,"value",n),xr(n)}}}switch(t){case"address":return function(r){return _(x(r),32)};case"bool":return function(r){return r?Ar:Pr};case"bytes":return function(r){return l(r)};case"string":return function(r){return V(r)}}return null}function H(t,r){return`${t}(${r.map(({name:e,type:n})=>n+" "+e).join(",")})`}class m{constructor(r){g(this,"types",Object.freeze(or(r))),g(this,"_encoderCache",{}),g(this,"_types",{});const e={},n={},s={};Object.keys(r).forEach(i=>{e[i]={},n[i]=[],s[i]={}});for(const i in r){const c={};r[i].forEach(u=>{c[u.name]&&h.throwArgumentError(`duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(i)}`,"types",r),c[u.name]=!0;const f=u.type.match(/^([^\x5b]*)(\x5b|$)/)[1];f===i&&h.throwArgumentError(`circular type reference to ${JSON.stringify(f)}`,"types",r),!I(f)&&(n[f]||h.throwArgumentError(`unknown type ${JSON.stringify(f)}`,"types",r),n[f].push(i),e[i][f]=!0)})}const o=Object.keys(n).filter(i=>n[i].length===0);o.length===0?h.throwArgumentError("missing primary type","types",r):o.length>1&&h.throwArgumentError(`ambiguous primary types or unused types: ${o.map(i=>JSON.stringify(i)).join(", ")}`,"types",r),g(this,"primaryType",o[0]);function a(i,c){c[i]&&h.throwArgumentError(`circular type reference to ${JSON.stringify(i)}`,"types",r),c[i]=!0,Object.keys(e[i]).forEach(u=>{n[u]&&(a(u,c),Object.keys(c).forEach(f=>{s[f][u]=!0}))}),delete c[i]}a(this.primaryType,{});for(const i in s){const c=Object.keys(s[i]);c.sort(),this._types[i]=H(i,r[i])+c.map(u=>H(u,r[u])).join("")}}getEncoder(r){let e=this._encoderCache[r];return e||(e=this._encoderCache[r]=this._getEncoder(r)),e}_getEncoder(r){{const s=I(r);if(s)return s}const e=r.match(/^(.*)(\x5b(\d*)\x5d)$/);if(e){const s=e[1],o=this.getEncoder(s),a=parseInt(e[3]);return i=>{a>=0&&i.length!==a&&h.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",i);let c=i.map(o);return this._types[s]&&(c=c.map(l)),l(S(c))}}const n=this.types[r];if(n){const s=V(this._types[r]);return o=>{const a=n.map(({name:i,type:c})=>{const u=this.getEncoder(c)(o[i]);return this._types[c]?l(u):u});return a.unshift(s),S(a)}}return h.throwArgumentError(`unknown type: ${r}`,"type",r)}encodeType(r){const e=this._types[r];return e||h.throwArgumentError(`unknown type: ${JSON.stringify(r)}`,"name",r),e}encodeData(r,e){return this.getEncoder(r)(e)}hashStruct(r,e){return l(this.encodeData(r,e))}encode(r){return this.encodeData(this.primaryType,r)}hash(r){return this.hashStruct(this.primaryType,r)}_visit(r,e,n){if(I(r))return n(r,e);const s=r.match(/^(.*)(\x5b(\d*)\x5d)$/);if(s){const a=s[1],i=parseInt(s[3]);return i>=0&&e.length!==i&&h.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",e),e.map(c=>this._visit(a,c,n))}const o=this.types[r];return o?o.reduce((a,{name:i,type:c})=>(a[i]=this._visit(c,e[i],n),a),{}):h.throwArgumentError(`unknown type: ${r}`,"type",r)}visit(r,e){return this._visit(this.primaryType,r,e)}static from(r){return new m(r)}static getPrimaryType(r){return m.from(r).primaryType}static hashStruct(r,e,n){return m.from(e).hashStruct(r,n)}static hashDomain(r){const e=[];for(const n in r){const s=U[n];s||h.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`,"domain",r),e.push({name:n,type:s})}return e.sort((n,s)=>D.indexOf(n.name)-D.indexOf(s.name)),m.hashStruct("EIP712Domain",{EIP712Domain:e},r)}static encode(r,e,n){return S(["0x1901",m.hashDomain(r),m.from(e).hash(n)])}static hash(r,e,n){return l(m.encode(r,e,n))}static resolveNames(r,e,n,s){return wr(this,void 0,void 0,function*(){r=M(r);const o={};r.verifyingContract&&!k(r.verifyingContract,20)&&(o[r.verifyingContract]="0x");const a=m.from(e);a.visit(n,(i,c)=>(i==="address"&&!k(c,20)&&(o[c]="0x"),c));for(const i in o)o[i]=yield s(i);return r.verifyingContract&&o[r.verifyingContract]&&(r.verifyingContract=o[r.verifyingContract]),n=a.visit(n,(i,c)=>i==="address"&&o[c]?o[c]:c),{domain:r,value:n}})}static getPayload(r,e,n){m.hashDomain(r);const s={},o=[];D.forEach(c=>{const u=r[c];u!=null&&(s[c]=br[c](u),o.push({name:c,type:U[c]}))});const a=m.from(e),i=M(e);return i.EIP712Domain?h.throwArgumentError("types must not contain EIP712Domain type","types.EIP712Domain",e):i.EIP712Domain=o,a.encode(n),{types:i,domain:s,primaryType:a.primaryType,message:a.visit(n,(c,u)=>{if(c.match(/^bytes(\d*)/))return A(w(u));if(c.match(/^u?int/))return p.from(u).toString();switch(c){case"address":return u.toLowerCase();case"bool":return!!u;case"string":return typeof u!="string"&&h.throwArgumentError("invalid string","value",u),u}return h.throwArgumentError("unsupported type","type",c)})}}}const Sr="transactions/5.8.0",y=new $(Sr);var z;(function(t){t[t.legacy=0]="legacy",t[t.eip2930=1]="eip2930",t[t.eip1559=2]="eip1559"})(z||(z={}));const $r=[{name:"nonce",maxLength:32,numeric:!0},{name:"gasPrice",maxLength:32,numeric:!0},{name:"gasLimit",maxLength:32,numeric:!0},{name:"to",length:20},{name:"value",maxLength:32,numeric:!0},{name:"data"}],Lr={chainId:!0,data:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,type:!0,value:!0};function O(t){const r=fr(t);return x(T(l(T(r,1)),12))}function rr(t,r){return O(hr(w(t),r))}function d(t,r){const e=E(p.from(t).toHexString());return e.length>32&&y.throwArgumentError("invalid length for "+r,"transaction:"+r,t),e}function K(t,r){return{address:x(t),storageKeys:(r||[]).map((e,n)=>(sr(e)!==32&&y.throwArgumentError("invalid access list storageKey",`accessList[${t}:${n}]`,e),e.toLowerCase()))}}function Or(t){if(Array.isArray(t))return t.map((e,n)=>Array.isArray(e)?(e.length>2&&y.throwArgumentError("access list expected to be [ address, storageKeys[] ]",`value[${n}]`,e),K(e[0],e[1])):K(e.address,e.storageKeys));const r=Object.keys(t).map(e=>{const n=t[e].reduce((s,o)=>(s[o]=!0,s),{});return K(e,Object.keys(n).sort())});return r.sort((e,n)=>e.address.localeCompare(n.address)),r}function er(t){return Or(t).map(r=>[r.address,r.storageKeys])}function _r(t,r){if(t.gasPrice!=null){const n=p.from(t.gasPrice),s=p.from(t.maxFeePerGas||0);n.eq(s)||y.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas","tx",{gasPrice:n,maxFeePerGas:s})}const e=[d(t.chainId||0,"chainId"),d(t.nonce||0,"nonce"),d(t.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),d(t.maxFeePerGas||0,"maxFeePerGas"),d(t.gasLimit||0,"gasLimit"),t.to!=null?x(t.to):"0x",d(t.value||0,"value"),t.data||"0x",er(t.accessList||[])];if(r){const n=j(r);e.push(d(n.recoveryParam,"recoveryParam")),e.push(E(n.r)),e.push(E(n.s))}return S(["0x02",C(e)])}function Cr(t,r){const e=[d(t.chainId||0,"chainId"),d(t.nonce||0,"nonce"),d(t.gasPrice||0,"gasPrice"),d(t.gasLimit||0,"gasLimit"),t.to!=null?x(t.to):"0x",d(t.value||0,"value"),t.data||"0x",er(t.accessList||[])];if(r){const n=j(r);e.push(d(n.recoveryParam,"recoveryParam")),e.push(E(n.r)),e.push(E(n.s))}return S(["0x01",C(e)])}function Nr(t,r){cr(t,Lr);const e=[];$r.forEach(function(a){let i=t[a.name]||[];const c={};a.numeric&&(c.hexPad="left"),i=w(A(i,c)),a.length&&i.length!==a.length&&i.length>0&&y.throwArgumentError("invalid length for "+a.name,"transaction:"+a.name,i),a.maxLength&&(i=E(i),i.length>a.maxLength&&y.throwArgumentError("invalid length for "+a.name,"transaction:"+a.name,i)),e.push(A(i))});let n=0;if(t.chainId!=null?(n=t.chainId,typeof n!="number"&&y.throwArgumentError("invalid transaction.chainId","transaction",t)):r&&!ir(r)&&r.v>28&&(n=Math.floor((r.v-35)/2)),n!==0&&(e.push(A(n)),e.push("0x"),e.push("0x")),!r)return C(e);const s=j(r);let o=27+s.recoveryParam;return n!==0?(e.pop(),e.pop(),e.pop(),o+=n*2+8,s.v>28&&s.v!==o&&y.throwArgumentError("transaction.chainId/signature.v mismatch","signature",r)):s.v!==o&&y.throwArgumentError("transaction.chainId/signature.v mismatch","signature",r),e.push(A(o)),e.push(E(w(s.r))),e.push(E(w(s.s))),C(e)}function B(t,r){if(t.type==null||t.type===0)return t.accessList!=null&&y.throwArgumentError("untyped transactions do not support accessList; include type: 1","transaction",t),Nr(t,r);switch(t.type){case 1:return Cr(t,r);case 2:return _r(t,r)}return y.throwError(`unsupported transaction type: ${t.type}`,$.errors.UNSUPPORTED_OPERATION,{operation:"serializeTransaction",transactionType:t.type})}const Dr="wallet/5.8.0";var Z=function(t,r,e,n){function s(o){return o instanceof e?o:new e(function(a){a(o)})}return new(e||(e=Promise))(function(o,a){function i(f){try{u(n.next(f))}catch(v){a(v)}}function c(f){try{u(n.throw(f))}catch(v){a(v)}}function u(f){f.done?o(f.value):s(f.value).then(i,c)}u((n=n.apply(t,r||[])).next())})};const P=new $(Dr);function Ir(t){return t!=null&&k(t.privateKey,32)&&t.address!=null}function Kr(t){const r=t.mnemonic;return r&&r.phrase}class b extends nr{constructor(r,e){if(super(),Ir(r)){const n=new N(r.privateKey);if(g(this,"_signingKey",()=>n),g(this,"address",O(this.publicKey)),this.address!==x(r.address)&&P.throwArgumentError("privateKey/address mismatch","privateKey","[REDACTED]"),Kr(r)){const s=r.mnemonic;g(this,"_mnemonic",()=>({phrase:s.phrase,path:s.path||R,locale:s.locale||"en"}));const o=this.mnemonic,a=F.fromMnemonic(o.phrase,null,o.locale).derivePath(o.path);O(a.privateKey)!==this.address&&P.throwArgumentError("mnemonic/address mismatch","privateKey","[REDACTED]")}else g(this,"_mnemonic",()=>null)}else{if(N.isSigningKey(r))r.curve!=="secp256k1"&&P.throwArgumentError("unsupported curve; must be secp256k1","privateKey","[REDACTED]"),g(this,"_signingKey",()=>r);else{typeof r=="string"&&r.match(/^[0-9a-f]*$/i)&&r.length===64&&(r="0x"+r);const n=new N(r);g(this,"_signingKey",()=>n)}g(this,"_mnemonic",()=>null),g(this,"address",O(this.publicKey))}e&&!tr.isProvider(e)&&P.throwArgumentError("invalid provider","provider",e),g(this,"provider",e||null)}get mnemonic(){return this._mnemonic()}get privateKey(){return this._signingKey().privateKey}get publicKey(){return this._signingKey().publicKey}getAddress(){return Promise.resolve(this.address)}connect(r){return new b(this,r)}signTransaction(r){return ar(r).then(e=>{e.from!=null&&(x(e.from)!==this.address&&P.throwArgumentError("transaction from address mismatch","transaction.from",r.from),delete e.from);const n=this._signingKey().signDigest(l(B(e)));return B(e,n)})}signMessage(r){return Z(this,void 0,void 0,function*(){return J(this._signingKey().signDigest(Q(r)))})}_signTypedData(r,e,n){return Z(this,void 0,void 0,function*(){const s=yield m.resolveNames(r,e,n,o=>(this.provider==null&&P.throwError("cannot resolve ENS names without a provider",$.errors.UNSUPPORTED_OPERATION,{operation:"resolveName",value:o}),this.provider.resolveName(o)));return J(this._signingKey().signDigest(m.hash(s.domain,e,s.value)))})}encrypt(r,e,n){if(typeof e=="function"&&!n&&(n=e,e={}),n&&typeof n!="function")throw new Error("invalid callback");return e||(e={}),mr(this,r,e,n)}static createRandom(r){let e=lr(16);r||(r={}),r.extraEntropy&&(e=w(T(l(q([e,r.extraEntropy])),0,16)));const n=ur(e,r.locale);return b.fromMnemonic(n,r.path,r.locale)}static fromEncryptedJson(r,e,n){return gr(r,e,n).then(s=>new b(s))}static fromEncryptedJsonSync(r,e){return new b(dr(r,e))}static fromMnemonic(r,e,n){return e||(e=R),new b(F.fromMnemonic(r,null,n).derivePath(e))}}function Vr(t,r){return rr(Q(t),r)}function Qr(t,r,e,n){return rr(m.hash(t,r,e),n)}export{b as W,Qr as a,Vr as v};
