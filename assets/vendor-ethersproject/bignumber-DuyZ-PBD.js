import{B as x}from"../vendor-bn.js-CN51n21Z.js";import{f as N,h as d,i as a}from"./bytes-BFUO92dS.js";import{L as u}from"./logger-BIOSViGG.js";const p="bignumber/5.8.0";var m=x.BN;const h=new u(p),c={},b=9007199254740991;let w=!1;class o{constructor(r,e){r!==c&&h.throwError("cannot call constructor directly; use BigNumber.from",u.errors.UNSUPPORTED_OPERATION,{operation:"new (BigNumber)"}),this._hex=e,this._isBigNumber=!0,Object.freeze(this)}fromTwos(r){return n(t(this).fromTwos(r))}toTwos(r){return n(t(this).toTwos(r))}abs(){return this._hex[0]==="-"?o.from(this._hex.substring(1)):this}add(r){return n(t(this).add(t(r)))}sub(r){return n(t(this).sub(t(r)))}div(r){return o.from(r).isZero()&&f("division-by-zero","div"),n(t(this).div(t(r)))}mul(r){return n(t(this).mul(t(r)))}mod(r){const e=t(r);return e.isNeg()&&f("division-by-zero","mod"),n(t(this).umod(e))}pow(r){const e=t(r);return e.isNeg()&&f("negative-power","pow"),n(t(this).pow(e))}and(r){const e=t(r);return(this.isNegative()||e.isNeg())&&f("unbound-bitwise-result","and"),n(t(this).and(e))}or(r){const e=t(r);return(this.isNegative()||e.isNeg())&&f("unbound-bitwise-result","or"),n(t(this).or(e))}xor(r){const e=t(r);return(this.isNegative()||e.isNeg())&&f("unbound-bitwise-result","xor"),n(t(this).xor(e))}mask(r){return(this.isNegative()||r<0)&&f("negative-width","mask"),n(t(this).maskn(r))}shl(r){return(this.isNegative()||r<0)&&f("negative-width","shl"),n(t(this).shln(r))}shr(r){return(this.isNegative()||r<0)&&f("negative-width","shr"),n(t(this).shrn(r))}eq(r){return t(this).eq(t(r))}lt(r){return t(this).lt(t(r))}lte(r){return t(this).lte(t(r))}gt(r){return t(this).gt(t(r))}gte(r){return t(this).gte(t(r))}isNegative(){return this._hex[0]==="-"}isZero(){return t(this).isZero()}toNumber(){try{return t(this).toNumber()}catch{f("overflow","toNumber",this.toString())}return null}toBigInt(){try{return BigInt(this.toString())}catch{}return h.throwError("this platform does not support BigInt",u.errors.UNSUPPORTED_OPERATION,{value:this.toString()})}toString(){return arguments.length>0&&(arguments[0]===10?w||(w=!0,h.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")):arguments[0]===16?h.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",u.errors.UNEXPECTED_ARGUMENT,{}):h.throwError("BigNumber.toString does not accept parameters",u.errors.UNEXPECTED_ARGUMENT,{})),t(this).toString(10)}toHexString(){return this._hex}toJSON(r){return{type:"BigNumber",hex:this.toHexString()}}static from(r){if(r instanceof o)return r;if(typeof r=="string")return r.match(/^-?0x[0-9a-f]+$/i)?new o(c,g(r)):r.match(/^-?[0-9]+$/)?new o(c,g(new m(r))):h.throwArgumentError("invalid BigNumber string","value",r);if(typeof r=="number")return r%1&&f("underflow","BigNumber.from",r),(r>=b||r<=-b)&&f("overflow","BigNumber.from",r),o.from(String(r));const e=r;if(typeof e=="bigint")return o.from(e.toString());if(N(e))return o.from(d(e));if(e)if(e.toHexString){const s=e.toHexString();if(typeof s=="string")return o.from(s)}else{let s=e._hex;if(s==null&&e.type==="BigNumber"&&(s=e.hex),typeof s=="string"&&(a(s)||s[0]==="-"&&a(s.substring(1))))return o.from(s)}return h.throwArgumentError("invalid BigNumber value","value",r)}static isBigNumber(r){return!!(r&&r._isBigNumber)}}function g(i){if(typeof i!="string")return g(i.toString(16));if(i[0]==="-")return i=i.substring(1),i[0]==="-"&&h.throwArgumentError("invalid hex","value",i),i=g(i),i==="0x00"?i:"-"+i;if(i.substring(0,2)!=="0x"&&(i="0x"+i),i==="0x")return"0x00";for(i.length%2&&(i="0x0"+i.substring(2));i.length>4&&i.substring(0,4)==="0x00";)i="0x"+i.substring(4);return i}function n(i){return o.from(g(i))}function t(i){const r=o.from(i).toHexString();return r[0]==="-"?new m("-"+r.substring(3),16):new m(r.substring(2),16)}function f(i,r,e){const s={fault:i,operation:r};return e!=null&&(s.value=e),h.throwError(i,u.errors.NUMERIC_FAULT,s)}function B(i){return new m(i,36).toString(16)}export{o as B,B as _};
