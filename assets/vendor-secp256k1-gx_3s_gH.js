import{g as R}from"./solana-vendors-DGPAp7Fj.js";import{r as U}from"./vendor-elliptic-BTxzAQL_.js";var x,m;function _(){if(m)return x;m=1;const l={IMPOSSIBLE_CASE:"Impossible case. Please create issue.",TWEAK_ADD:"The tweak was out of range or the resulted private key is invalid",TWEAK_MUL:"The tweak was out of range or equal to zero",CONTEXT_RANDOMIZE_UNKNOW:"Unknow error on context randomization",SECKEY_INVALID:"Private Key is invalid",PUBKEY_PARSE:"Public Key could not be parsed",PUBKEY_SERIALIZE:"Public Key serialization error",PUBKEY_COMBINE:"The sum of the public keys is not valid",SIG_PARSE:"Signature could not be parsed",SIGN:"The nonce generation function failed, or the private key was invalid",RECOVER:"Public key could not be recover",ECDH:"Scalar was invalid (zero or overflow)"};function w(o,t){if(!o)throw new Error(t)}function i(o,t,e){if(w(t instanceof Uint8Array,`Expected ${o} to be an Uint8Array`),e!==void 0)if(Array.isArray(e)){const r=e.join(", "),n=`Expected ${o} to be an Uint8Array with length [${r}]`;w(e.includes(t.length),n)}else{const r=`Expected ${o} to be an Uint8Array with length ${e}`;w(t.length===e,r)}}function s(o){w(S(o)==="Boolean","Expected compressed to be a Boolean")}function y(o=e=>new Uint8Array(e),t){return typeof o=="function"&&(o=o(t)),i("output",o,t),o}function S(o){return Object.prototype.toString.call(o).slice(8,-1)}return x=o=>({contextRandomize(t){switch(w(t===null||t instanceof Uint8Array,"Expected seed to be an Uint8Array or null"),t!==null&&i("seed",t,32),o.contextRandomize(t)){case 1:throw new Error(l.CONTEXT_RANDOMIZE_UNKNOW)}},privateKeyVerify(t){return i("private key",t,32),o.privateKeyVerify(t)===0},privateKeyNegate(t){switch(i("private key",t,32),o.privateKeyNegate(t)){case 0:return t;case 1:throw new Error(l.IMPOSSIBLE_CASE)}},privateKeyTweakAdd(t,e){switch(i("private key",t,32),i("tweak",e,32),o.privateKeyTweakAdd(t,e)){case 0:return t;case 1:throw new Error(l.TWEAK_ADD)}},privateKeyTweakMul(t,e){switch(i("private key",t,32),i("tweak",e,32),o.privateKeyTweakMul(t,e)){case 0:return t;case 1:throw new Error(l.TWEAK_MUL)}},publicKeyVerify(t){return i("public key",t,[33,65]),o.publicKeyVerify(t)===0},publicKeyCreate(t,e=!0,r){switch(i("private key",t,32),s(e),r=y(r,e?33:65),o.publicKeyCreate(r,t)){case 0:return r;case 1:throw new Error(l.SECKEY_INVALID);case 2:throw new Error(l.PUBKEY_SERIALIZE)}},publicKeyConvert(t,e=!0,r){switch(i("public key",t,[33,65]),s(e),r=y(r,e?33:65),o.publicKeyConvert(r,t)){case 0:return r;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.PUBKEY_SERIALIZE)}},publicKeyNegate(t,e=!0,r){switch(i("public key",t,[33,65]),s(e),r=y(r,e?33:65),o.publicKeyNegate(r,t)){case 0:return r;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.IMPOSSIBLE_CASE);case 3:throw new Error(l.PUBKEY_SERIALIZE)}},publicKeyCombine(t,e=!0,r){w(Array.isArray(t),"Expected public keys to be an Array"),w(t.length>0,"Expected public keys array will have more than zero items");for(const n of t)i("public key",n,[33,65]);switch(s(e),r=y(r,e?33:65),o.publicKeyCombine(r,t)){case 0:return r;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.PUBKEY_COMBINE);case 3:throw new Error(l.PUBKEY_SERIALIZE)}},publicKeyTweakAdd(t,e,r=!0,n){switch(i("public key",t,[33,65]),i("tweak",e,32),s(r),n=y(n,r?33:65),o.publicKeyTweakAdd(n,t,e)){case 0:return n;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.TWEAK_ADD)}},publicKeyTweakMul(t,e,r=!0,n){switch(i("public key",t,[33,65]),i("tweak",e,32),s(r),n=y(n,r?33:65),o.publicKeyTweakMul(n,t,e)){case 0:return n;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.TWEAK_MUL)}},signatureNormalize(t){switch(i("signature",t,64),o.signatureNormalize(t)){case 0:return t;case 1:throw new Error(l.SIG_PARSE)}},signatureExport(t,e){i("signature",t,64),e=y(e,72);const r={output:e,outputlen:72};switch(o.signatureExport(r,t)){case 0:return e.slice(0,r.outputlen);case 1:throw new Error(l.SIG_PARSE);case 2:throw new Error(l.IMPOSSIBLE_CASE)}},signatureImport(t,e){switch(i("signature",t),e=y(e,64),o.signatureImport(e,t)){case 0:return e;case 1:throw new Error(l.SIG_PARSE);case 2:throw new Error(l.IMPOSSIBLE_CASE)}},ecdsaSign(t,e,r={},n){i("message",t,32),i("private key",e,32),w(S(r)==="Object","Expected options to be an Object"),r.data!==void 0&&i("options.data",r.data),r.noncefn!==void 0&&w(S(r.noncefn)==="Function","Expected options.noncefn to be a Function"),n=y(n,64);const a={signature:n,recid:null};switch(o.ecdsaSign(a,t,e,r.data,r.noncefn)){case 0:return a;case 1:throw new Error(l.SIGN);case 2:throw new Error(l.IMPOSSIBLE_CASE)}},ecdsaVerify(t,e,r){switch(i("signature",t,64),i("message",e,32),i("public key",r,[33,65]),o.ecdsaVerify(t,e,r)){case 0:return!0;case 3:return!1;case 1:throw new Error(l.SIG_PARSE);case 2:throw new Error(l.PUBKEY_PARSE)}},ecdsaRecover(t,e,r,n=!0,a){switch(i("signature",t,64),w(S(e)==="Number"&&e>=0&&e<=3,"Expected recovery id to be a Number within interval [0, 3]"),i("message",r,32),s(n),a=y(a,n?33:65),o.ecdsaRecover(a,t,e,r)){case 0:return a;case 1:throw new Error(l.SIG_PARSE);case 2:throw new Error(l.RECOVER);case 3:throw new Error(l.IMPOSSIBLE_CASE)}},ecdh(t,e,r={},n){switch(i("public key",t,[33,65]),i("private key",e,32),w(S(r)==="Object","Expected options to be an Object"),r.data!==void 0&&i("options.data",r.data),r.hashfn!==void 0?(w(S(r.hashfn)==="Function","Expected options.hashfn to be a Function"),r.xbuf!==void 0&&i("options.xbuf",r.xbuf,32),r.ybuf!==void 0&&i("options.ybuf",r.ybuf,32),i("output",n)):n=y(n,32),o.ecdh(n,t,e,r.data,r.hashfn,r.xbuf,r.ybuf)){case 0:return n;case 1:throw new Error(l.PUBKEY_PARSE);case 2:throw new Error(l.ECDH)}}}),x}var P,I;function C(){if(I)return P;I=1;const l=U().ec,w=new l("secp256k1"),i=w.curve,s=i.n.constructor;function y(e,r){let n=new s(r);if(n.cmp(i.p)>=0)return null;n=n.toRed(i.red);let a=n.redSqr().redIMul(n).redIAdd(i.b).redSqrt();e===3!==a.isOdd()&&(a=a.redNeg());const c=n.redSqr().redIMul(n);return a.redSqr().redISub(c.redIAdd(i.b)).isZero()?w.keyPair({pub:{x:n,y:a}}):null}function S(e,r,n){let a=new s(r),c=new s(n);if(a.cmp(i.p)>=0||c.cmp(i.p)>=0||(a=a.toRed(i.red),c=c.toRed(i.red),(e===6||e===7)&&c.isOdd()!==(e===7)))return null;const u=a.redSqr().redIMul(a);return c.redSqr().redISub(u.redIAdd(i.b)).isZero()?w.keyPair({pub:{x:a,y:c}}):null}function o(e){const r=e[0];switch(r){case 2:case 3:return e.length!==33?null:y(r,e.subarray(1,33));case 4:case 6:case 7:return e.length!==65?null:S(r,e.subarray(1,33),e.subarray(33,65));default:return null}}function t(e,r){const n=r.encode(null,e.length===33);for(let a=0;a<e.length;++a)e[a]=n[a]}return P={contextRandomize(){return 0},privateKeyVerify(e){const r=new s(e);return r.cmp(i.n)<0&&!r.isZero()?0:1},privateKeyNegate(e){const r=new s(e),n=i.n.sub(r).umod(i.n).toArrayLike(Uint8Array,"be",32);return e.set(n),0},privateKeyTweakAdd(e,r){const n=new s(r);if(n.cmp(i.n)>=0||(n.iadd(new s(e)),n.cmp(i.n)>=0&&n.isub(i.n),n.isZero()))return 1;const a=n.toArrayLike(Uint8Array,"be",32);return e.set(a),0},privateKeyTweakMul(e,r){let n=new s(r);if(n.cmp(i.n)>=0||n.isZero())return 1;n.imul(new s(e)),n.cmp(i.n)>=0&&(n=n.umod(i.n));const a=n.toArrayLike(Uint8Array,"be",32);return e.set(a),0},publicKeyVerify(e){return o(e)===null?1:0},publicKeyCreate(e,r){const n=new s(r);if(n.cmp(i.n)>=0||n.isZero())return 1;const a=w.keyFromPrivate(r).getPublic();return t(e,a),0},publicKeyConvert(e,r){const n=o(r);if(n===null)return 1;const a=n.getPublic();return t(e,a),0},publicKeyNegate(e,r){const n=o(r);if(n===null)return 1;const a=n.getPublic();return a.y=a.y.redNeg(),t(e,a),0},publicKeyCombine(e,r){const n=new Array(r.length);for(let c=0;c<r.length;++c)if(n[c]=o(r[c]),n[c]===null)return 1;let a=n[0].getPublic();for(let c=1;c<n.length;++c)a=a.add(n[c].pub);return a.isInfinity()?2:(t(e,a),0)},publicKeyTweakAdd(e,r,n){const a=o(r);if(a===null)return 1;if(n=new s(n),n.cmp(i.n)>=0)return 2;const c=a.getPublic().add(i.g.mul(n));return c.isInfinity()?2:(t(e,c),0)},publicKeyTweakMul(e,r,n){const a=o(r);if(a===null)return 1;if(n=new s(n),n.cmp(i.n)>=0||n.isZero())return 2;const c=a.getPublic().mul(n);return t(e,c),0},signatureNormalize(e){const r=new s(e.subarray(0,32)),n=new s(e.subarray(32,64));return r.cmp(i.n)>=0||n.cmp(i.n)>=0?1:(n.cmp(w.nh)===1&&e.set(i.n.sub(n).toArrayLike(Uint8Array,"be",32),32),0)},signatureExport(e,r){const n=r.subarray(0,32),a=r.subarray(32,64);if(new s(n).cmp(i.n)>=0||new s(a).cmp(i.n)>=0)return 1;const{output:c}=e;let u=c.subarray(4,37);u[0]=0,u.set(n,1);let f=33,d=0;for(;f>1&&u[d]===0&&!(u[d+1]&128);--f,++d);if(u=u.subarray(d),u[0]&128||f>1&&u[0]===0&&!(u[1]&128))return 1;let E=c.subarray(39,72);E[0]=0,E.set(a,1);let h=33,b=0;for(;h>1&&E[b]===0&&!(E[b+1]&128);--h,++b);return E=E.subarray(b),E[0]&128||h>1&&E[0]===0&&!(E[1]&128)?1:(e.outputlen=6+f+h,c[0]=48,c[1]=e.outputlen-2,c[2]=2,c[3]=u.length,c.set(u,4),c[4+f]=2,c[5+f]=E.length,c.set(E,6+f),0)},signatureImport(e,r){if(r.length<8||r.length>72||r[0]!==48||r[1]!==r.length-2||r[2]!==2)return 1;const n=r[3];if(n===0||5+n>=r.length||r[4+n]!==2)return 1;const a=r[5+n];if(a===0||6+n+a!==r.length||r[4]&128||n>1&&r[4]===0&&!(r[5]&128)||r[n+6]&128||a>1&&r[n+6]===0&&!(r[n+7]&128))return 1;let c=r.subarray(4,4+n);if(c.length===33&&c[0]===0&&(c=c.subarray(1)),c.length>32)return 1;let u=r.subarray(6+n);if(u.length===33&&u[0]===0&&(u=u.slice(1)),u.length>32)throw new Error("S length is too long");let f=new s(c);f.cmp(i.n)>=0&&(f=new s(0));let d=new s(r.subarray(6+n));return d.cmp(i.n)>=0&&(d=new s(0)),e.set(f.toArrayLike(Uint8Array,"be",32),0),e.set(d.toArrayLike(Uint8Array,"be",32),32),0},ecdsaSign(e,r,n,a,c){if(c){const d=c;c=E=>{const h=d(r,n,null,a,E);if(!(h instanceof Uint8Array&&h.length===32))throw new Error("This is the way");return new s(h)}}const u=new s(n);if(u.cmp(i.n)>=0||u.isZero())return 1;let f;try{f=w.sign(r,n,{canonical:!0,k:c,pers:a})}catch{return 1}return e.signature.set(f.r.toArrayLike(Uint8Array,"be",32),0),e.signature.set(f.s.toArrayLike(Uint8Array,"be",32),32),e.recid=f.recoveryParam,0},ecdsaVerify(e,r,n){const a={r:e.subarray(0,32),s:e.subarray(32,64)},c=new s(a.r),u=new s(a.s);if(c.cmp(i.n)>=0||u.cmp(i.n)>=0)return 1;if(u.cmp(w.nh)===1||c.isZero()||u.isZero())return 3;const f=o(n);if(f===null)return 2;const d=f.getPublic();return w.verify(r,a,d)?0:3},ecdsaRecover(e,r,n,a){const c={r:r.slice(0,32),s:r.slice(32,64)},u=new s(c.r),f=new s(c.s);if(u.cmp(i.n)>=0||f.cmp(i.n)>=0)return 1;if(u.isZero()||f.isZero())return 2;let d;try{d=w.recoverPubKey(a,c,n)}catch{return 2}return t(e,d),0},ecdh(e,r,n,a,c,u,f){const d=o(r);if(d===null)return 1;const E=new s(n);if(E.cmp(i.n)>=0||E.isZero())return 2;const h=d.getPublic().mul(E);if(c===void 0){const b=h.encode(null,!0),K=w.hash().update(b).digest();for(let p=0;p<32;++p)e[p]=K[p]}else{u||(u=new Uint8Array(32));const b=h.getX().toArray("be",32);for(let A=0;A<32;++A)u[A]=b[A];f||(f=new Uint8Array(32));const K=h.getY().toArray("be",32);for(let A=0;A<32;++A)f[A]=K[A];const p=c(u,f,a);if(!(p instanceof Uint8Array&&p.length===e.length))return 2;e.set(p)}return 0}},P}var g,v;function N(){return v||(v=1,g=_()(C())),g}var T=N();const M=R(T);export{M as s};
