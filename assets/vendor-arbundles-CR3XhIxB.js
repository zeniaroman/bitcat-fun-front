var Nt=Object.defineProperty;var $t=(r,t,e)=>t in r?Nt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var a=(r,t,e)=>$t(r,typeof t!="symbol"?t+"":t,e);import{b as i}from"./vendor-buffer-DVXvU5G6.js";import"./vendor-base64-js-C2zTC7ec.js";import"./vendor-bignumber.js-Dj_rIxHg.js";import"./vendor-async-retry-DWdC6xTk.js";import{b as y}from"./vendor-base64url-D1J1q9RC.js";import{c as K,s as p,W as X,j as jt,A as Ct}from"./vendor-irys/arweave-CO_npObX.js";import{a as Yt,v as J}from"./vendor-noble/ed25519-DHS8bCE8.js";import{b as R}from"./vendor-bs58-DhqqakFZ.js";import{s as Y}from"./vendor-secp256k1-gx_3s_gH.js";import{c as k}from"./vendor-crypto-browserify-NMg_40A5.js";import{B as Wt}from"./vendor-bn.js-CN51n21Z.js";import{c as Vt}from"./vendor-keccak-Bl_8Z6TM.js";import{a as Z}from"./vendor-ethersproject/bytes-BFUO92dS.js";import{v as zt,W as ht,a as yt}from"./vendor-ethersproject/wallet-_-D8aoNy.js";import{h as lt}from"./vendor-ethersproject/hash-CaQkUgof.js";import{r as Jt}from"./vendor-ethersproject/signing-key-DZY4IiDE.js";import{c as Ft}from"./vendor-ethersproject/transactions-DgEmUiir.js";import{s as dt}from"./vendor-stream-browserify-BiXhMpOM.js";class Gt{constructor(){a(this,"publicKey");a(this,"signatureType");a(this,"signatureLength");a(this,"ownerLength");a(this,"pem")}static verify(t,e,s,n){throw new Error("You must implement verify method on child")}}var h;(function(r){r[r.ARWEAVE=1]="ARWEAVE",r[r.ED25519=2]="ED25519",r[r.ETHEREUM=3]="ETHEREUM",r[r.SOLANA=4]="SOLANA",r[r.INJECTEDAPTOS=5]="INJECTEDAPTOS",r[r.MULTIAPTOS=6]="MULTIAPTOS",r[r.TYPEDETHEREUM=7]="TYPEDETHEREUM"})(h||(h={}));const l={[h.ARWEAVE]:{sigLength:512,pubLength:512,sigName:"arweave"},[h.ED25519]:{sigLength:64,pubLength:32,sigName:"ed25519"},[h.ETHEREUM]:{sigLength:65,pubLength:65,sigName:"ethereum"},[h.SOLANA]:{sigLength:64,pubLength:32,sigName:"solana"},[h.INJECTEDAPTOS]:{sigLength:64,pubLength:32,sigName:"injectedAptos"},[h.MULTIAPTOS]:{sigLength:2052,pubLength:1025,sigName:"multiAptos"},[h.TYPEDETHEREUM]:{sigLength:65,pubLength:42,sigName:"typedEthereum"}};class N{constructor(t,e){a(this,"_key");a(this,"pk");a(this,"ownerLength",l[2].pubLength);a(this,"signatureLength",l[2].sigLength);a(this,"_publicKey");a(this,"signatureType",2);this._key=t,this.pk=e}get publicKey(){return this._publicKey}get key(){throw new Error("You must implement `key`")}sign(t){return Yt(i.Buffer.from(t),i.Buffer.from(this.key))}static async verify(t,e,s){let n=t;return typeof t=="string"&&(n=y.toBuffer(t)),J(i.Buffer.from(s),i.Buffer.from(e),i.Buffer.from(n))}}async function $(r){if(typeof r[Symbol.asyncIterator]=="function"){const n=r,o=k.createHash("sha384");let c=0;for await(const g of n)c+=g.byteLength,o.update(g);const u=K([p("blob"),p(c.toString())]),f=K([await S().hash(u,"SHA-384"),o.digest()]);return await S().hash(f,"SHA-384")}else if(Array.isArray(r)){const n=K([p("list"),p(r.length.toString())]);return await bt(r,await S().hash(n,"SHA-384"))}const t=r,e=K([p("blob"),p(t.byteLength.toString())]),s=K([await S().hash(e,"SHA-384"),await S().hash(t,"SHA-384")]);return await S().hash(s,"SHA-384")}async function bt(r,t){if(r.length<1)return t;const e=K([t,await $(r[0])]),s=await S().hash(e,"SHA-384");return await bt(r.slice(1),s)}const Xt=X.default?X.default:X;class wt extends Xt{getPublicKey(t){throw new Error("Unimplemented")}}let Zt;function S(){return Zt??(Zt=new wt)}class pt{constructor(t,e){a(this,"_key");a(this,"pk");a(this,"signatureType",1);a(this,"ownerLength",l[1].pubLength);a(this,"signatureLength",l[1].sigLength);a(this,"_publicKey");this._key=t,this.pk=e,e||(this.pk=S().getPublicKey(JSON.parse(t)))}get publicKey(){return this._publicKey}sign(t){return k.createSign("sha256").update(t).sign({key:this._key,padding:k.constants.RSA_PKCS1_PSS_PADDING})}static async verify(t,e,s){return await S().verify(i.Buffer.isBuffer(t)?y.encode(t):t,e,s)}}class mt extends pt{constructor(e){super(jt(e),e.n);a(this,"jwk");this.jwk=e}get publicKey(){if(!this.pk)throw new Error("ArweaveSigner - pk is undefined");return y.toBuffer(this.pk)}sign(e){return S().sign(this.jwk,e)}static async verify(e,s,n){return await S().verify(e,s,n)}}class St{constructor(t){a(this,"_publicKey");a(this,"ownerLength",l[2].pubLength);a(this,"signatureLength",l[2].sigLength);a(this,"signatureType",2);a(this,"pem");a(this,"provider");if(this.provider=t,!this.provider.publicKey)throw new Error("InjectedSolanaSigner - provider.publicKey is undefined");this._publicKey=this.provider.publicKey.toBuffer()}get publicKey(){return this._publicKey}async sign(t){if(!this.provider.signMessage)throw new Error("Selected Wallet does not support message signing");return await this.provider.signMessage(t)}static async verify(t,e,s){let n=t;return typeof t=="string"&&(n=y.toBuffer(t)),J(i.Buffer.from(s),i.Buffer.from(e),i.Buffer.from(n))}}class qt{constructor(t){a(this,"signer");a(this,"publicKey");a(this,"ownerLength",l[h.ETHEREUM].pubLength);a(this,"signatureLength",l[h.ETHEREUM].sigLength);a(this,"signatureType",h.ETHEREUM);this.signer=t.getSigner()}async setPublicKey(){const t="sign this message to connect to Bundlr.Network",e=await this.signer.signMessage(t),s=await lt(t),n=Jt(Z(s),e);this.publicKey=i.Buffer.from(Z(n))}async sign(t){this.publicKey||await this.setPublicKey();const e=await this.signer.signMessage(t);return i.Buffer.from(e.slice(2),"hex")}static verify(t,e,s){const n=Ft(t);return zt(e,s)===n}}class et extends N{get publicKey(){return R.decode(this.pk)}get key(){return R.decode(this._key)}constructor(t){const e=R.decode(t);super(R.encode(e.subarray(0,32)),R.encode(e.subarray(32,64)))}}function U(r){return r=Tt(r),Vt("keccak256").update(r).digest()}function Tt(r){if(!i.Buffer.isBuffer(r))if(Array.isArray(r))r=i.Buffer.from(r);else if(typeof r=="string")Bt(r)?r=i.Buffer.from(rt(Et(r)),"hex"):r=i.Buffer.from(r);else if(typeof r=="number")r=At(r);else if(r==null)r=i.Buffer.allocUnsafe(0);else if(Wt.isBN(r))r=r.toArrayLike(i.Buffer);else if(r.toArray)r=i.Buffer.from(r.toArray());else throw new Error("invalid type");return r}function Bt(r,t){return!(typeof r!="string"||!r.match(/^0x[0-9A-Fa-f]*$/)||t&&r.length!==2+2*t)}function rt(r){if(typeof r!="string")throw new Error(`while padding to even, value must be string, is currently ${typeof r}, while padToEven.`);return r.length%2&&(r=`0${r}`),r}function Et(r){return typeof r!="string"?r:Lt(r)?r.slice(2):r}function Lt(r){if(typeof r!="string")throw new Error("value must be type 'string', is currently type "+typeof r+", while checking isHexPrefixed.");return r.startsWith("0x")}function At(r){const t=xt(r);return i.Buffer.from(rt(t.slice(2)),"hex")}function xt(r){return`0x${r.toString(16)}`}typeof window<"u"&&(window.keccak256=U);const Qt={intToBuffer:At,intToHex:xt,isHexPrefixed:Lt,stripHexPrefix:Et,padToEven:rt,isHexString:Bt,toBuffer:Tt};class _t{constructor(t,e){a(this,"_key");a(this,"ownerLength",l[h.ETHEREUM].pubLength);a(this,"signatureLength",l[h.ETHEREUM].sigLength);a(this,"signatureType",h.ETHEREUM);a(this,"pk");this._key=t,this.pk=e.toString("hex")}get publicKey(){throw new Error("You must implement `publicKey`")}get key(){return i.Buffer.from(this._key,"hex")}static async verify(t,e,s){let n=t;typeof t=="string"&&(n=y.toBuffer(t));let o=!1;try{o=Y.ecdsaVerify(s,U(i.Buffer.from(e)),n)}catch{}return o}async sign(t){return Y.ecdsaSign(U(i.Buffer.from(t)),i.Buffer.from(this.key)).signature}}class F extends _t{get publicKey(){return i.Buffer.from(this.pk,"hex")}constructor(t){t.startsWith("0x")&&(t=t.slice(2));const e=i.Buffer.from(t,"hex"),s=Y.publicKeyCreate(e,!1);super(t,i.Buffer.from(s))}async sign(t){return new ht(this._key).signMessage(t).then(s=>i.Buffer.from(s.slice(2),"hex"))}static async verify(t,e,s){return Y.ecdsaVerify(s.length===65?s.slice(0,-1):s,Z(lt(e)),typeof t=="string"?y.toBuffer(t):t)}}class te extends F{}class ee extends et{constructor(t){super(t.replace("ed25519:",""))}}class re extends N{get publicKey(){return i.Buffer.from(this.pk)}get key(){return i.Buffer.from(this._key)}constructor(t,e){super(t.subarray(0,32),e)}}let It=class extends St{constructor(e){super(e);a(this,"signatureType",4)}async sign(e){return super.sign(i.Buffer.from(i.Buffer.from(e).toString("hex")))}static async verify(e,s,n){return super.verify(e,i.Buffer.from(i.Buffer.from(s).toString("hex")),n)}};class se extends et{constructor(e){super(e);a(this,"signatureType",4)}async sign(e){return super.sign(i.Buffer.from(i.Buffer.from(e).toString("hex")))}static async verify(e,s,n){return super.verify(e,i.Buffer.from(i.Buffer.from(s).toString("hex")),n)}}class ne extends N{constructor(t,e){super(t,e)}get publicKey(){return i.Buffer.from(this.pk.slice(2),"hex")}get key(){return i.Buffer.from(this._key.slice(2),"hex")}}class vt{constructor(t,e){a(this,"_publicKey");a(this,"ownerLength",l[h.INJECTEDAPTOS].pubLength);a(this,"signatureLength",l[h.INJECTEDAPTOS].sigLength);a(this,"signatureType",h.INJECTEDAPTOS);a(this,"pem");a(this,"provider");this.provider=t,this._publicKey=e}get publicKey(){return this._publicKey}async sign(t){if(!this.provider.signMessage)throw new Error("Selected Wallet does not support message signing");const e=await this.provider.signMessage({message:i.Buffer.from(t).toString("hex"),nonce:"bundlr"});return i.Buffer.from(e.signature,"hex")}static async verify(t,e,s){const n=t;return J(i.Buffer.from(s),i.Buffer.from(`APTOS
message: ${i.Buffer.from(e).toString("hex")}
nonce: bundlr`),i.Buffer.from(n))}}class Pt{constructor(t,e){a(this,"_publicKey");a(this,"ownerLength",l[h.MULTIAPTOS].pubLength);a(this,"signatureLength",l[h.MULTIAPTOS].sigLength);a(this,"signatureType",h.MULTIAPTOS);a(this,"collectSignatures");a(this,"provider");this._publicKey=t,this.collectSignatures=e}get publicKey(){return this._publicKey}async sign(t){const{signatures:e,bitmap:s}=await this.collectSignatures(t),n=128,o=new Uint8Array([0,0,0,0]),c=new Set;s.forEach(g=>{if(g>=32)throw new Error(`Invalid bit value ${g}.`);if(c.has(g))throw new Error("Duplicated bits detected.");c.add(g);const d=Math.floor(g/8);let T=o[d];T|=n>>g%8,o[d]=T});const u=i.Buffer.alloc(this.signatureLength);let f=0;for(let g=0;g<32;g++)s.includes(g)&&u.set(e[f++],g*64);return u.set(o,this.signatureLength-4),u}static async verify(t,e,s){const o=l[h.MULTIAPTOS].sigLength-4,c=s.slice(0,o),u=s.slice(o);let f=!1;for(let g=0;g<32;g++){const d=Math.floor(g/8),T=g-d*8;if((u[d]&128>>T)!==0){const w=c.slice(g*64,(g+1)*64),A=t.slice(g*32,(g+1)*32);await J(i.Buffer.from(w),i.Buffer.from(e),i.Buffer.from(A))||(f=!0)}}return!f}}class Kt extends F{constructor(e){super(e);a(this,"ownerLength",l[h.TYPEDETHEREUM].pubLength);a(this,"signatureLength",l[h.TYPEDETHEREUM].sigLength);a(this,"signatureType",h.TYPEDETHEREUM);a(this,"address");a(this,"signer");this.address="0x"+U(super.publicKey.slice(1)).slice(-20).toString("hex"),this.signer=new ht(e)}get publicKey(){return i.Buffer.from(this.address)}async sign(e){const s=await this.signer._signTypedData(W,V,{address:this.address,"Transaction hash":e});return i.Buffer.from(s.slice(2),"hex")}static async verify(e,s,n){const o=e.toString(),c=yt(W,V,{address:o,"Transaction hash":s},n);return o.toLowerCase()===c.toLowerCase()}}const W={name:"Bundlr",version:"1"},V={Bundlr:[{name:"Transaction hash",type:"bytes"},{name:"address",type:"address"}]};class ae{constructor(t){a(this,"ownerLength",l[h.TYPEDETHEREUM].pubLength);a(this,"signatureLength",l[h.TYPEDETHEREUM].sigLength);a(this,"signatureType",h.TYPEDETHEREUM);a(this,"address");a(this,"signer");a(this,"publicKey");this.signer=t.getSigner()}async ready(){this.address=(await this.signer.getAddress()).toString().toLowerCase(),this.publicKey=i.Buffer.from(this.address)}async sign(t){const e=await this.signer._signTypedData(W,V,{address:this.address,"Transaction hash":t});return i.Buffer.from(e.slice(2),"hex")}static verify(t,e,s){const n=t.toString(),o=yt(W,V,{address:n,"Transaction hash":e},s);return n.toLowerCase()===o.toLowerCase()}}class ie{constructor(t,e){a(this,"signer");a(this,"publicKey");a(this,"ownerLength",l[h.ARWEAVE].pubLength);a(this,"signatureLength",l[h.ARWEAVE].sigLength);a(this,"signatureType",h.ARWEAVE);a(this,"arweave");this.signer=t,this.arweave=e}async setPublicKey(){const t=await this.signer.getActivePublicKey();this.publicKey=y.toBuffer(t)}async sign(t){this.publicKey||await this.setPublicKey();const e={name:"RSA-PSS",saltLength:32},s=await this.signer.signature(t,e);return new Uint8Array(Object.values(s).map(o=>+o))}static async verify(t,e,s){return await S().verify(t,e,s)}}const st={1:mt,2:N,3:F,4:It,5:vt,6:Pt,7:Kt};async function q(r){return $([p("dataitem"),p("1"),p(r.signatureType.toString()),r.rawOwner,r.rawTarget,r.rawAnchor,r.rawTags,r.rawData])}function j(r,t){const e=new Uint8Array(r);if(t<0)throw new Error("Array is unsigned, cannot represent -ve numbers");if(t>2**(r*8)-1)throw new Error(`Number ${t} is too large for an array of ${r} bytes`);for(let s=0;s<e.length;s++){const n=t&255;e[s]=n,t=(t-n)/256}return e}function Q(r){return j(8,r)}function Ot(r){return j(2,r)}function oe(r){return j(16,r)}function tt(r){return j(32,r)}function b(r){let t=0;for(let e=r.length-1;e>=0;e--)t=t*256+r[e];return t}class nt{constructor(t=i.Buffer.alloc(it),e=0){a(this,"buf");a(this,"pos");this.buf=t,this.pos=e}writeTags(t){if(!Array.isArray(t))throw new Error("input must be array");const e=t.length;let s;if(e)for(this.writeLong(e),s=0;s<e;s++){const n=t[s];if(typeof(n==null?void 0:n.name)!="string"||typeof(n==null?void 0:n.value)!="string")throw new Error(`Invalid tag format for ${n}, expected {name:string, value: string}`);this.writeString(n.name),this.writeString(n.value)}this.writeLong(0)}toBuffer(){const t=i.Buffer.alloc(this.pos);if(this.pos>this.buf.length)throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);return this.buf.copy(t,0,0,this.pos),t}writeLong(t){const e=this.buf;let s,n;if(t>=-1073741824&&t<1073741824){n=t>=0?t<<1:~t<<1|1;do e[this.pos]=n&127,n>>=7;while(n&&(e[this.pos++]|=128))}else{s=t>=0?t*2:-t*2-1;do e[this.pos]=s&127,s/=128;while(s>=1&&(e[this.pos++]|=128))}this.pos++,this.buf=e}writeString(t){const e=i.Buffer.byteLength(t),s=this.buf;this.writeLong(e);let n=this.pos;if(this.pos+=e,!(this.pos>s.length)){if(e>64)this.buf.write(t,this.pos-e,e,"utf8");else{let o,c,u,f;for(o=0,c=e;o<c;o++)u=t.charCodeAt(o),u<128?s[n++]=u:u<2048?(s[n++]=u>>6|192,s[n++]=u&63|128):(u&64512)===55296&&((f=t.charCodeAt(o+1))&64512)===56320?(u=65536+((u&1023)<<10)+(f&1023),o++,s[n++]=u>>18|240,s[n++]=u>>12&63|128,s[n++]=u>>6&63|128,s[n++]=u&63|128):(s[n++]=u>>12|224,s[n++]=u>>6&63|128,s[n++]=u&63|128)}this.buf=s}}readLong(){let t=0,e=0;const s=this.buf;let n,o,c,u;do n=s[this.pos++],o=n&128,t|=(n&127)<<e,e+=7;while(o&&e<28);if(o){c=t,u=268435456;do n=s[this.pos++],c+=(n&127)*u,u*=128;while(n&128);return(c%2?-(c+1):c)/2}return t>>1^-(t&1)}skipLong(){const t=this.buf;for(;t[this.pos++]&128;);}readTags(){const t=[];let e;for(;e=this.readLong();)for(e<0&&(e=-e,this.skipLong());e--;){const s=this.readString(),n=this.readString();t.push({name:s,value:n})}return t}readString(){const t=this.readLong(),e=this.pos,s=this.buf;if(this.pos+=t,this.pos>s.length)throw new Error("TAP Position out of range");return this.buf.slice(e,e+t).toString()}}function kt(r){if((r==null?void 0:r.length)===0)return i.Buffer.allocUnsafe(0);const t=new nt;return t.writeTags(r),t.toBuffer()}function z(r){return new nt(r).readTags()}const at=80,it=4096;class _{constructor(t){a(this,"binary");a(this,"_id");this.binary=t}static isDataItem(t){return t.binary!==void 0}get signatureType(){const t=b(this.binary.subarray(0,2));if((h==null?void 0:h[t])!==void 0)return t;throw new Error("Unknown signature type: "+t)}async isValid(){return _.verify(this.binary)}get id(){return y.encode(this.rawId)}set id(t){this._id=y.toBuffer(t)}get rawId(){return k.createHash("sha256").update(this.rawSignature).digest()}set rawId(t){this._id=t}get rawSignature(){return this.binary.subarray(2,2+this.signatureLength)}get signature(){return y.encode(this.rawSignature)}set rawOwner(t){if(t.byteLength!=this.ownerLength)throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t.byteLength} bytes.`);this.binary.set(t,2+this.signatureLength)}get rawOwner(){return this.binary.subarray(2+this.signatureLength,2+this.signatureLength+this.ownerLength)}get signatureLength(){return l[this.signatureType].sigLength}get owner(){return y.encode(this.rawOwner)}get ownerLength(){return l[this.signatureType].pubLength}get rawTarget(){const t=this.getTargetStart();return this.binary[t]==1?this.binary.subarray(t+1,t+33):i.Buffer.alloc(0)}get target(){return y.encode(this.rawTarget)}get rawAnchor(){const t=this.getAnchorStart();return this.binary[t]==1?this.binary.subarray(t+1,t+33):i.Buffer.alloc(0)}get anchor(){return this.rawAnchor.toString()}get rawTags(){const t=this.getTagsStart(),e=b(this.binary.subarray(t+8,t+16));return this.binary.subarray(t+16,t+16+e)}get tags(){const t=this.getTagsStart();if(b(this.binary.subarray(t,t+8))==0)return[];const s=b(this.binary.subarray(t+8,t+16));return z(i.Buffer.from(this.binary.subarray(t+16,t+16+s)))}get tagsB64Url(){return this.tags.map(e=>({name:y.encode(e.name),value:y.encode(e.value)}))}getStartOfData(){const t=this.getTagsStart(),e=this.binary.subarray(t+8,t+16),s=b(e);return t+16+s}get rawData(){const t=this.getTagsStart(),e=this.binary.subarray(t+8,t+16),s=b(e),n=t+16+s;return this.binary.subarray(n,this.binary.length)}get data(){return y.encode(this.rawData)}getRaw(){return this.binary}async sign(t){return this._id=await ut(this,t),this.rawId}async setSignature(t){this.binary.set(t,2),this._id=i.Buffer.from(await S().hash(t))}isSigned(){var t;return(((t=this._id)==null?void 0:t.length)??0)>0}toJSON(){return{signature:this.signature,owner:this.owner,target:this.target,tags:this.tags.map(t=>({name:y.encode(t.name),value:y.encode(t.value)})),data:this.data}}static async verify(t){if(t.byteLength<at)return!1;const e=new _(t),s=e.signatureType,n=e.getTagsStart(),o=b(t.subarray(n,n+8)),c=t.subarray(n+8,n+16),u=b(c);if(u>it)return!1;if(o>0)try{if(z(i.Buffer.from(t.subarray(n+16,n+16+u))).length!==o)return!1}catch{return!1}const f=st[s],g=await q(e);return await f.verify(e.rawOwner,g,e.rawSignature)}async getSignatureData(){return q(this)}getTagsStart(){const t=this.getTargetStart(),e=this.binary[t]==1;let s=t+(e?33:1);const n=this.binary[s]==1;return s+=n?33:1,s}getTargetStart(){return 2+this.signatureLength+this.ownerLength}getAnchorStart(){let t=this.getTargetStart()+1;const e=this.binary[this.getTargetStart()]==1;return t+=e?32:0,t}}const L=32;class ot{constructor(t){a(this,"length");a(this,"items");a(this,"binary");this.binary=t,this.length=this.getDataItemCount(),this.items=this.getItems()}getRaw(){return this.binary}get(t){if(typeof t=="number"){if(t>=this.length)throw new RangeError("Index out of range");return this.getByIndex(t)}else return this.getById(t)}getSizes(){const t=[];for(let e=L;e<L+64*this.length;e+=64)t.push(b(this.binary.subarray(e,e+32)));return t}getIds(){const t=[];for(let e=L;e<L+64*this.length;e+=64){const s=this.binary.subarray(e+32,e+64);if(s.length===0)throw new Error("Invalid bundle, id specified in headers doesn't exist");t.push(y.encode(s))}return t}getIdBy(t){if(t>this.length-1)throw new RangeError("Index of bundle out of range");const e=64+64*t;return y.encode(this.binary.subarray(e,e+32))}async toTransaction(t,e,s){const n=await e.createTransaction({data:this.binary,...t},s);return n.addTag("Bundle-Format","binary"),n.addTag("Bundle-Version","2.0.0"),n}async verify(){for(const t of this.items){const e=await t.isValid(),s=y(k.createHash("sha256").update(t.rawSignature).digest());if(!(e&&t.id===s))return!1}return!0}getOffset(t){let e=0;for(let s=L;s<L+64*this.length;s+=64){const n=b(this.binary.subarray(s,s+32));e+=n;const o=this.binary.subarray(s+32,s+64);if(i.Buffer.compare(o,t)===0)return{startOffset:e,size:n}}return{startOffset:-1,size:-1}}getByIndex(t){let e=0;const s=this.getBundleStart();let n=0,o,c;for(let d=L;d<L+64*this.length;d+=64){if(o=b(this.binary.subarray(d,d+32)),n++===t){c=this.binary.subarray(d+32,d+64);break}e+=o}const u=s+e,f=this.binary.subarray(u,u+o),g=new _(f);return g.rawId=c,g}getById(t){const e=y.toBuffer(t),s=this.getOffset(e);if(s.startOffset===-1)throw new Error("Transaction not found");const o=this.getBundleStart()+s.startOffset;return new _(this.binary.subarray(o,o+s.size))}getDataItemCount(){return b(this.binary.subarray(0,32))}getBundleStart(){return 32+64*this.length}getItems(){const t=new Array(this.length);let e=0;const s=this.getBundleStart();let n=0;for(let o=L;o<L+64*this.length;o+=64){const c=b(this.binary.subarray(o,o+32)),u=this.binary.subarray(o+32,o+64);if(u.length===0)throw new Error("Invalid bundle, id specified in headers doesn't exist");const f=s+e,g=this.binary.subarray(f,f+c);e+=c;const d=new _(g);d.rawId=u,t[n]=d,n++}return t}}function ue(r){return new ot(r)}async function ce(r,t){const e=new Uint8Array(64*r.length),s=await Promise.all(r.map(async(o,c)=>{const u=o.isSigned()?o.rawId:await ut(o,t),f=new Uint8Array(64);return f.set(tt(o.getRaw().byteLength),0),f.set(u,32),e.set(f,64*c),o.getRaw()})).then(o=>i.Buffer.concat(o)),n=i.Buffer.concat([i.Buffer.from(tt(r.length)),i.Buffer.from(e),s]);return new ot(n)}async function Dt(r,t){const e=await q(r),s=await t.sign(e),n=await S().hash(s);return{signature:i.Buffer.from(s),id:i.Buffer.from(n)}}async function ut(r,t){const{signature:e,id:s}=await Dt(r,t);return r.getRaw().set(e,2),s}function Ht(r,t,e){var D,H;const s=t.publicKey,n=e!=null&&e.target?y.toBuffer(e.target):null,o=1+((n==null?void 0:n.byteLength)??0),c=e!=null&&e.anchor?i.Buffer.from(e.anchor):null,u=1+((c==null?void 0:c.byteLength)??0),f=(((D=e==null?void 0:e.tags)==null?void 0:D.length)??0)>0?kt(e==null?void 0:e.tags):null,g=16+(f?f.byteLength:0),d=typeof r=="string"?i.Buffer.from(r):i.Buffer.from(r),T=d.byteLength,I=2+t.signatureLength+t.ownerLength+o+u+g+T,w=i.Buffer.alloc(I);if(w.set(Ot(t.signatureType),0),w.set(new Uint8Array(t.signatureLength).fill(0),2),s.byteLength!==t.ownerLength)throw new Error(`Owner must be ${t.ownerLength} bytes, but was incorrectly ${s.byteLength}`);w.set(s,2+t.signatureLength);const A=2+t.signatureLength+t.ownerLength;if(w[A]=n?1:0,n){if(n.byteLength!==32)throw new Error(`Target must be 32 bytes but was incorrectly ${n.byteLength}`);w.set(n,A+1)}const v=A+o;let B=v+1;if(w[v]=c?1:0,c){if(B+=c.byteLength,c.byteLength!==32)throw new Error("Anchor must be 32 bytes");w.set(c,v+1)}w.set(Q(((H=e==null?void 0:e.tags)==null?void 0:H.length)??0),B);const C=Q((f==null?void 0:f.byteLength)??0);w.set(C,B+8),f&&w.set(f,B+16);const O=B+g;return w.set(d,O),new _(w)}class fe{constructor(){a(this,"signatureType");a(this,"rawSignature");a(this,"signature");a(this,"signatureLength");a(this,"rawOwner");a(this,"owner");a(this,"ownerLength");a(this,"rawTarget");a(this,"target");a(this,"rawAnchor");a(this,"anchor");a(this,"rawTags");a(this,"tags");a(this,"rawData");a(this,"data")}static async verify(...t){throw new Error("You must implement `verify`")}}const ge=Object.freeze(Object.defineProperty({__proto__:null,AVSCTap:nt,AlgorandSigner:re,AptosSigner:ne,ArconnectSigner:ie,Arweave:Ct,ArweaveSigner:mt,Bundle:ot,BundleItem:fe,CryptoDriver:wt,Curve25519:N,DataItem:_,EthereumSigner:F,HexInjectedSolanaSigner:It,HexSolanaSigner:se,InjectedAptosSigner:vt,InjectedEthereumSigner:qt,InjectedSolanaSigner:St,InjectedTypedEthereumSigner:ae,MAX_TAG_BYTES:it,MIN_BINARY_SIZE:at,MultiSignatureAptosSigner:Pt,NearSigner:ee,PolygonSigner:te,Rsa4096:pt,SIG_CONFIG:l,get SignatureConfig(){return h},Signer:Gt,SolanaSigner:et,TypedEthereumSigner:Kt,bundleAndSignData:ce,byteArrayToLong:b,concatBuffers:K,createData:Ht,deepHash:$,deserializeTags:z,exportForTesting:Qt,getCryptoDriver:S,getSignatureAndId:Dt,indexToType:st,keccak256:U,longTo16ByteArray:oe,longTo32ByteArray:tt,longTo8ByteArray:Q,longToNByteArray:j,secp256k1:_t,serializeTags:kt,shortTo2ByteArray:Ot,sign:ut,stringToBuffer:p,unbundleData:ue},Symbol.toStringTag,{value:"Module"}));async function gt(r){const t=Mt(r);let e=(await t.next()).value;e=await m(t,e,32);const s=b(e.subarray(0,32));e=e.subarray(32);const n=64*s;e=await m(t,e,n);const o=new Array(s);for(let f=0;f<n;f+=64)o[f/64]=[b(e.subarray(f,f+32)),y(i.Buffer.from(e.subarray(f+32,f+64)))];e=e.subarray(n);let c=32+n;const u=[];for(const[f,g]of o){e=await m(t,e,at),e=await m(t,e,2);const d=b(e.subarray(0,2));e=e.subarray(2);const{sigLength:T,pubLength:I,sigName:w}=l[d];e=await m(t,e,T);const A=e.subarray(0,T);e=e.subarray(T),e=await m(t,e,I);const v=e.subarray(0,I);e=e.subarray(I),e=await m(t,e,1);const B=e[0]===1;B&&(e=await m(t,e,33));const C=B?e.subarray(1,33):i.Buffer.allocUnsafe(0);e=e.subarray(B?33:1),e=await m(t,e,1);const O=e[0]===1;O&&(e=await m(t,e,33));const D=O?e.subarray(1,33):i.Buffer.allocUnsafe(0);e=e.subarray(O?33:1),e=await m(t,e,8);const H=b(e.subarray(0,8));e=e.subarray(8),e=await m(t,e,8);const M=b(e.subarray(0,8));e=e.subarray(8),e=await m(t,e,M);const ct=e.subarray(0,M),ft=H!==0&&M!==0?z(i.Buffer.from(ct)):[];if(ft.length!==H)throw new Error("Tags lengths don't match");e=e.subarray(M);const P=new dt.Transform;P._transform=function(x,we,Ut){this.push(x),Ut()};const Rt=$([p("dataitem"),p("1"),p(d.toString()),v,C,D,ct,P]),G=2+T+I+(B?33:1)+(O?33:1)+16+M,E=f-G;if(e.byteLength>E)P.write(e.subarray(0,E)),e=e.subarray(E);else{let x=e.byteLength;for(P.write(e);E>x;){if(e=(await t.next()).value,!e)throw new Error(`Not enough data bytes  expected: ${E} received: ${x}`);x+=e.byteLength,x>E?P.write(e.subarray(0,e.byteLength-(x-E))):P.write(e)}e=e.subarray(e.byteLength-(x-E))}if(P.end(),g!==y(k.createHash("sha256").update(A).digest()))throw new Error("ID doesn't match signature");if(!await st[d].verify(v,await Rt,A))throw new Error("Invalid signature");u.push({id:g,sigName:w,signature:y(i.Buffer.from(A)),target:y(i.Buffer.from(C)),anchor:y(i.Buffer.from(D)),owner:y(i.Buffer.from(v)),tags:ft,dataOffset:c+G,dataSize:E}),c+=G+E}return u}async function he(r,t,e,s){const n=Ht("",e,s),o=new dt.PassThrough,c=[p("dataitem"),p("1"),p(n.signatureType.toString()),n.rawOwner,n.rawTarget,n.rawAnchor,n.rawTags,r],u=await $(c),f=i.Buffer.from(await e.sign(u));return n.setSignature(f),o.write(n.getRaw()),t.pipe(o)}async function m(r,t,e){if(t.byteLength>=e)return t;const{done:s,value:n}=await r.next();if(s&&!n)throw new Error("Invalid buffer");return m(r,i.Buffer.concat([i.Buffer.from(t),i.Buffer.from(n)]),e)}async function*Mt(r){for await(const t of r)yield t}const ye={readBytes:m,getReader:Mt},le=Object.freeze(Object.defineProperty({__proto__:null,default:gt,processStream:gt,streamExportForTesting:ye,streamSigner:he},Symbol.toStringTag,{value:"Module"})),de={...ge,stream:le};globalThis.arbundles??(globalThis.arbundles=de);export{mt as A,_ as D,It as H,ae as I,ee as N,vt as a,ce as b,Ht as c,$ as d,S as g};
