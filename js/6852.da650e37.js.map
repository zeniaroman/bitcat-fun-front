{"version":3,"file":"js/6852.da650e37.js","mappings":"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","sources":["webpack://app/../../../../src/plugins/candyMachineV2Module/constants.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/helpers.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/gpaBuilders.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/program.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/pdas.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/models/CandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/createCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/deleteCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/errors.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/asserts.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/insertItemsToCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/accounts.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/mintCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/updateCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/CandyMachinesV2BuildersClient.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/findCandyMachinesV2ByPublicKeyField.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/findCandyMachineV2ByAddress.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/operations/findMintedNftsByCandyMachineV2.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/CandyMachinesV2Client.ts","webpack://app/../../../../src/plugins/candyMachineV2Module/plugin.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/updateCandyGuardAuthority.ts","webpack://app/../../../../src/plugins/candyMachineModule/errors.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/callCandyGuardRoute.ts","webpack://app/../../../../src/plugins/candyMachineModule/constants.ts","webpack://app/../../../../src/plugins/candyMachineModule/models/CandyMachineHiddenSection.ts","webpack://app/../../../../src/plugins/candyMachineModule/models/CandyMachine.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/createCandyMachine.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/createCandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/deleteCandyMachine.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/deleteCandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/asserts.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/insertCandyMachineItems.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/mintFromCandyMachine.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/unwrapCandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/updateCandyMachine.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/updateCandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/wrapCandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/CandyMachineBuildersClient.ts","webpack://app/../../../../src/plugins/candyMachineModule/CandyMachineGuardsClient.ts","webpack://app/../../../../src/plugins/candyMachineModule/CandyMachinePdasClient.ts","webpack://app/../../../../src/plugins/candyMachineModule/models/CandyGuard.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/findCandyGuardsByAuthority.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/default.ts","webpack://app/../../../../src/plugins/candyMachineModule/programs.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/findCandyMachineByAddress.ts","webpack://app/../../../../src/plugins/candyMachineModule/operations/findCandyGuardByAddress.ts","webpack://app/../../../../src/plugins/candyMachineModule/CandyMachineClient.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/freezeSolPayment.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/freezeTokenPayment.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/botTax.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/solPayment.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/tokenPayment.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/startDate.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/thirdPartySigner.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/tokenGate.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/gatekeeper.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/endDate.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/allowList.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/mintLimit.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/nftPayment.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/redeemedAmount.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/addressGate.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/nftGate.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/nftBurn.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/tokenBurn.ts","webpack://app/../../../../src/plugins/candyMachineModule/guards/programGate.ts","webpack://app/../../../../src/plugins/candyMachineModule/plugin.ts","webpack://app/../../../../src/plugins/corePlugins/plugin.ts"],"sourcesContent":["export const MAX_NAME_LENGTH = 32;\nexport const MAX_SYMBOL_LENGTH = 10;\nexport const MAX_URI_LENGTH = 200;\nexport const MAX_CREATOR_LIMIT = 5;\nexport const MAX_CREATOR_LEN = 32 + 1 + 1;\nexport const CONFIG_LINE_SIZE = 4 + MAX_NAME_LENGTH + 4 + MAX_URI_LENGTH;\nexport const CONFIG_ARRAY_START =\n  8 + // key\n  32 + // authority\n  32 + // wallet\n  33 + // token mint\n  4 +\n  6 + // uuid\n  8 + // price\n  8 + // items available\n  9 + // go live\n  10 + // end settings\n  4 +\n  MAX_SYMBOL_LENGTH + // u32 len + symbol\n  2 + // seller fee basis points\n  4 +\n  MAX_CREATOR_LIMIT * MAX_CREATOR_LEN + // optional + u32 len + actual vec\n  8 + // max supply\n  1 + // is mutable\n  1 + // retain authority\n  1 + // option for hidden setting\n  4 +\n  MAX_NAME_LENGTH + // name length,\n  4 +\n  MAX_URI_LENGTH + // uri length,\n  32 + // hash\n  4 + // max number of lines;\n  8 + // items redeemed\n  1 + // whitelist option\n  1 + // whitelist mint mode\n  1 + // allow presale\n  9 + // discount price\n  32 + // mint key for whitelist\n  1 +\n  32 +\n  1; // gatekeeper\n","import type { PublicKey } from '@solana/web3.js';\nimport {\n  CandyMachineData,\n  configLineBeet,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport { CONFIG_ARRAY_START, CONFIG_LINE_SIZE } from './constants';\nimport { CandyMachineV2Item } from './models';\nimport { removeEmptyChars } from '@/utils';\nimport { BigNumber, toBigNumber } from '@/types';\n\nexport function countCandyMachineV2Items(rawData: Buffer): BigNumber {\n  const number = rawData.slice(CONFIG_ARRAY_START, CONFIG_ARRAY_START + 4);\n  return toBigNumber(number, 'le');\n}\n\nexport function parseCandyMachineV2Items(\n  rawData: Buffer\n): CandyMachineV2Item[] {\n  const configLinesStart = CONFIG_ARRAY_START + 4;\n  const lines = [];\n  const count = countCandyMachineV2Items(rawData).toNumber();\n  for (let i = 0; i < count; i++) {\n    const [line] = configLineBeet.deserialize(\n      rawData,\n      configLinesStart + i * CONFIG_LINE_SIZE\n    );\n    lines.push({\n      name: removeEmptyChars(line.name),\n      uri: removeEmptyChars(line.uri),\n    });\n  }\n  return lines;\n}\n\nexport function getCandyMachineV2AccountSizeFromData(data: CandyMachineData) {\n  if (data.hiddenSettings != null) {\n    return CONFIG_ARRAY_START;\n  }\n  const itemsAvailable = toBigNumber(data.itemsAvailable).toNumber();\n  return Math.ceil(\n    CONFIG_ARRAY_START +\n      4 +\n      itemsAvailable * CONFIG_LINE_SIZE +\n      8 +\n      2 * (itemsAvailable / 8 + 1)\n  );\n}\n\nexport const getCandyMachineV2UuidFromAddress = (\n  candyMachineAddress: PublicKey\n): string => {\n  return candyMachineAddress.toBase58().slice(0, 6);\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { GpaBuilder } from '@/utils';\n\ntype AccountDiscriminator = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n];\n// TODO(thlorenz): copied from candy machine SDK\n// SDK should either provide a GPA builder or expose this discriminator\nconst candyMachineV2Discriminator: AccountDiscriminator = [\n  51, 173, 177, 113, 25, 241, 109, 189,\n];\n\nconst AUTHORITY = candyMachineV2Discriminator.length;\nconst WALLET = AUTHORITY + PublicKey.default.toBytes().byteLength;\n\nexport class CandyMachineV2GpaBuilder extends GpaBuilder {\n  whereDiscriminator(discrimator: AccountDiscriminator) {\n    return this.where(0, Buffer.from(discrimator));\n  }\n\n  candyMachineAccounts() {\n    return this.whereDiscriminator(candyMachineV2Discriminator);\n  }\n\n  // wallet same as solTreasury\n  candyMachineAccountsForWallet(wallet: PublicKey) {\n    return this.candyMachineAccounts().where(WALLET, wallet.toBase58());\n  }\n\n  candyMachineAccountsForAuthority(authority: PublicKey) {\n    return this.candyMachineAccounts().where(AUTHORITY, authority.toBase58());\n  }\n}\n","import { PROGRAM_ID } from '@metaplex-foundation/mpl-candy-machine';\nimport { CandyMachineV2GpaBuilder } from './gpaBuilders';\nimport { Metaplex } from '@/Metaplex';\n\n/** @group Programs */\nexport const CandyMachineV2Program = {\n  publicKey: PROGRAM_ID,\n\n  accounts(metaplex: Metaplex) {\n    return new CandyMachineV2GpaBuilder(metaplex, this.publicKey);\n  },\n};\n","import { Buffer } from 'buffer';\nimport { PublicKey } from '@solana/web3.js';\nimport { CandyMachineV2Program } from './program';\nimport { Pda } from '@/types';\n\n/** @group Pdas */\nexport const findCandyMachineV2CreatorPda = (\n  candyMachine: PublicKey,\n  programId: PublicKey = CandyMachineV2Program.publicKey\n): Pda => {\n  return Pda.find(programId, [\n    Buffer.from('candy_machine', 'utf8'),\n    candyMachine.toBuffer(),\n  ]);\n};\n\n/** @group Pdas */\nexport const findCandyMachineV2CollectionPda = (\n  candyMachine: PublicKey,\n  programId: PublicKey = CandyMachineV2Program.publicKey\n): Pda => {\n  return Pda.find(programId, [\n    Buffer.from('collection', 'utf8'),\n    candyMachine.toBuffer(),\n  ]);\n};\n","import { PublicKey } from '@solana/web3.js';\nimport {\n  CandyMachineData,\n  EndSettingType,\n  WhitelistMintMode,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport {\n  countCandyMachineV2Items,\n  getCandyMachineV2UuidFromAddress,\n  parseCandyMachineV2Items,\n} from '../helpers';\nimport {\n  CandyMachineV2Account,\n  MaybeCandyMachineV2CollectionAccount,\n} from '../accounts';\nimport { CandyMachineV2Program } from '../program';\nimport {\n  amount,\n  Amount,\n  BigNumber,\n  DateTime,\n  lamports,\n  SOL,\n  toBigNumber,\n  toDateTime,\n  toOptionDateTime,\n  UnparsedAccount,\n  Creator,\n} from '@/types';\nimport { assert, Option, removeEmptyChars } from '@/utils';\nimport { Mint } from '@/plugins/tokenModule';\n\n// -----------------\n// Model\n// -----------------\n\n/**\n * This model contains all the relevant information about a Candy Machine.\n * This includes its settings but also all of the items (a.k.a. config lines)\n * loaded inside the Candy Machine along with some statistics about the items.\n *\n * @group Models\n */\nexport type CandyMachineV2 = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'candyMachineV2';\n\n  /** The address of the Candy Machine account. */\n  readonly address: PublicKey;\n\n  /** The address of program that owns the Candy Machine account. */\n  readonly programAddress: PublicKey;\n\n  /** Whether this Candy Machine was created from v1 or v2. */\n  readonly version: 1 | 2;\n\n  /** The address of the authority that is allowed to manage this Candy Machine. */\n  readonly authorityAddress: PublicKey;\n\n  /**\n   * The address of the wallet receiving the payments for minting NFTs.\n   * If the Candy Machine accepts payments in SOL, this is the SOL treasury account.\n   * Otherwise, this is the token account associated with the treasury Mint.\n   */\n  readonly walletAddress: PublicKey;\n\n  /**\n   * The address of the Mint account of the SPL Token that should be used\n   * to accept payments for minting NFTs. When `null`, it means the\n   * Candy Machine account accepts payments in SOL.\n   */\n  readonly tokenMintAddress: Option<PublicKey>;\n\n  /**\n   * The mint address of the collection NFT that should be associated with\n   * minting NFTs. When `null`, it means NFTs will not be part of a\n   * collection when minted.\n   */\n  readonly collectionMintAddress: Option<PublicKey>;\n\n  /**\n   * A 6-character long unique identifier for the Candy Machine.\n   * This usually is the first 6 characters of the address.\n   * This is more of an internal field used by the program\n   * and you typically shouldn't need it.\n   */\n  readonly uuid: string;\n\n  /**\n   * The price of minting an NFT.\n   *\n   * If the Candy Machine uses no treasury mint (i.e. the `tokenMintAddress`\n   * is `null`), this amount will be in SOL. Otherwise, its currency will\n   * match the currency of the treasury mint.\n   */\n  readonly price: Amount;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   */\n  readonly symbol: string;\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points\n   * (i.e. 250 is 2.5%).\n   */\n  readonly sellerFeeBasisPoints: number;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   */\n  readonly isMutable: boolean;\n\n  /**\n   * Wheter the minted NFTs should use the Candy Machine authority\n   * as their update authority.\n   *\n   * We strongly recommend setting this to `true` unless you have a\n   * specific reason. When set to `false`, the update authority will\n   * be given to the address that minted the NFT and you will no longer\n   * be able to update the minted NFTs in the future.\n   */\n  readonly retainAuthority: boolean;\n\n  /**\n   * The timestamp of when the Candy Machine will be live.\n   *\n   * If this is `null` or if the timestamp refers to a time in the\n   * future, no one will be able to mint NFTs from the Candy Machine\n   * (except its authority that can bypass this live date).\n   */\n  readonly goLiveDate: Option<DateTime>;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   */\n  readonly maxEditionSupply: BigNumber;\n\n  /**\n   * The parsed items that are loaded in the Candy Machine.\n   *\n   * If the Candy Machine is using hidden settings,\n   * this will be an empty array.\n   */\n  readonly items: CandyMachineV2Item[];\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   */\n  readonly itemsAvailable: BigNumber;\n\n  /**\n   * The number of items that have been minted on this Candy Machine so far.\n   */\n  readonly itemsMinted: BigNumber;\n\n  /**\n   * The number of remaining items in the Candy Machine that can still be minted.\n   */\n  readonly itemsRemaining: BigNumber;\n\n  /**\n   * The number of items that have been inserted in the Candy Machine by\n   * its authority. If this number if lower than the number of items\n   * available, the Candy Machine is not ready and cannot be minted from.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly itemsLoaded: BigNumber;\n\n  /**\n   * Whether all items in the Candy Machine have been inserted by\n   * its authority.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly isFullyLoaded: boolean;\n\n  /**\n   * An optional constraint defining when the Candy Machine will end.\n   * If this is `null`, the Candy Machine will end when there are\n   * no more items to mint from (i.e. `itemsRemaining` is `0`).\n   */\n  readonly endSettings: Option<CandyMachineV2EndSettings>;\n\n  /** {@inheritDoc CandyMachineV2HiddenSettings} */\n  readonly hiddenSettings: Option<CandyMachineV2HiddenSettings>;\n\n  /** {@inheritDoc CandyMachineV2WhitelistMintSettings} */\n  readonly whitelistMintSettings: Option<CandyMachineV2WhitelistMintSettings>;\n\n  /** {@inheritDoc CandyMachineV2Gatekeeper} */\n  readonly gatekeeper: Option<CandyMachineV2Gatekeeper>;\n\n  /** {@inheritDoc Creator} */\n  readonly creators: Creator[];\n};\n\n/**\n * Represent an item inside a Candy Machine that has been or\n * will eventually be minted into an NFT.\n *\n * It only contains the name and the URI of the NFT to be as\n * the rest of the day will be shared by all NFTs and lives\n * in the Candy Machine configurations (e.g. `symbol`, `creators`, etc).\n *\n * @group Models\n */\nexport type CandyMachineV2Item = {\n  /** The name of the NFT to be. */\n  readonly name: string;\n\n  /**\n   * The URI of the NFT to be,\n   * pointing to some off-chain JSON Metadata.\n   */\n  readonly uri: string;\n};\n\n/**\n * End Settings provides a mechanism to stop the mint if a certain condition is\n * met without interaction.\n *\n * This type is a union type differentiated by the `endSettingType` field.\n * It can have one of the following values:\n *\n * - {@link CandyMachineV2EndSettingsAmount} if `endSettingType` is `EndSettingType.Amount`. \\\n *   It ends a Candy Machine after a certain amount of items have been minted.\n * - {@link CandyMachineV2EndSettingsDate} if `endSettingType` is `EndSettingType.Date`. \\\n *   It ends a Candy Machine after a certain date.\n *\n * @group Models\n */\nexport type CandyMachineV2EndSettings =\n  | CandyMachineV2EndSettingsAmount\n  | CandyMachineV2EndSettingsDate;\n\n/**\n * The \"Amount\" end setting allows us to end a Candy Machine\n * after a certain amount of items have been minted.\n *\n * @group Models\n */\nexport type CandyMachineV2EndSettingsAmount = {\n  /** Differentiates the types of end settings. */\n  readonly endSettingType: EndSettingType.Amount;\n\n  /** The maximum number of items to mint. */\n  readonly number: BigNumber;\n};\n\n/**\n * The \"Date\" end setting allows us to end a Candy Machine\n * after a given date and time.\n *\n * @group Models\n */\nexport type CandyMachineV2EndSettingsDate = {\n  /** Differentiates the types of end settings. */\n  readonly endSettingType: EndSettingType.Date;\n\n  /** The date after which the Candy Machine is closed. */\n  readonly date: DateTime;\n};\n\n/**\n * An optional setting that makes items in the Candy Machine hidden by\n * providing a single URI for all minted NFTs and the hash of a file that\n * maps mint number to actual NFT URIs.\n *\n * Hidden settings serve two purposes.\n * - First, it allows the creation of larger drops (20k+), since\n *   the JSON metadata URIs are not stored on-chain for each item.\n * - In turn, this also allows the creation of hide-and-reveal drops,\n *   where users discover which items they minted after the mint is complete.\n *\n * Once hidden settings are enabled, every minted NFT will have the same URI and the\n * name will be created by appending the mint number (e.g., “#45”) to the specified\n * name. The hash is expected to be a 32 character string corresponding to\n * the hash of a cache file that has the mapping between a mint number and the\n * actual metadata URI. This allows the order of the mint to be verified by\n * others after the mint is complete.\n *\n * Since the metadata URIs are not on-chain, it is possible to create very large\n * drops. The only caveat is that there is a need for an off-chain process to\n * update the metadata for each item. This is important otherwise all items\n * will have the same metadata.\n *\n * @group Models\n */\nexport type CandyMachineV2HiddenSettings = {\n  /**\n   * The base name for all minted NFTs.\n   * The number of the mint will be appended to this name.\n   */\n  readonly name: string;\n\n  /**\n   * The URI shared by all minted NFTs.\n   */\n  readonly uri: string;\n\n  /**\n   * A 32-character hash. In most cases this is the hash of the\n   * cache file with the mapping between mint numbers and metadata URIs\n   * so that the order can be verified when the mint is complete.\n   */\n  readonly hash: number[];\n};\n\n/**\n * Whitelist settings provide a variety of different use cases and revolve\n * around the idea of using custom SPL tokens to offer special rights to token\n * holders. How these SPL tokens are distributed is up to you.\n *\n * For example, you can offer a discount to token holders, you can allow token\n * holders to mint NFTs before everyone else, or a combination of both.\n *\n * @group Models\n */\nexport type CandyMachineV2WhitelistMintSettings = {\n  /**\n   * Determines how the whitelist token is used.\n   * - `WhitelistMintMode.BurnEveryTime`: a whitelist token is burned every time an NFT is mint.\n   * - `WhitelistMintMode.NeverBurn`: whitelist tokens are kept after minting.\n   */\n  readonly mode: WhitelistMintMode;\n\n  /** The mint address of the whitelist token. */\n  readonly mint: PublicKey;\n\n  /** Indicates whether whitelist token holders can mint before the live date. */\n  readonly presale: boolean;\n\n  /**\n   * The updated price for whitelist token holders.\n   * When provided, this `discountPrice` will be used instead of the original `price`\n   * for whitelist token holders only. When `null`, everybody will pay the original `price`.\n   */\n  readonly discountPrice: Option<Amount>;\n};\n\n/**\n * Gatekeeper settings allow us to protect ourselves against malicious actors such as bots.\n * Whilst the Candy Machine program itself has some protection mechanisms against bots,\n * you may want to add extra protection to ensure only humand can mint from your project.\n *\n * To enable gatekeeper settings, you must provide the address of a Gatekeeper Network\n * which usually encapsulates multiple gatekeeper providers and is responsible for\n * validating the legitimacy of the minting actor.\n *\n * @group Models\n */\nexport type CandyMachineV2Gatekeeper = {\n  /** The address of your desired Gatekeeper Network. */\n  readonly network: PublicKey;\n\n  /** Whether or not a new challenge should be required after each use. */\n  readonly expireOnUse: boolean;\n};\n\n// -----------------\n// Program to Model\n// -----------------\n\n/** @group Model Helpers */\nexport const isCandyMachineV2 = (value: any): value is CandyMachineV2 =>\n  typeof value === 'object' && value.model === 'candyMachineV2';\n\n/** @group Model Helpers */\nexport function assertCandyMachineV2(\n  value: any\n): asserts value is CandyMachineV2 {\n  assert(isCandyMachineV2(value), 'Expected CandyMachineV2 type');\n}\n\n/** @group Model Helpers */\nexport const toCandyMachineV2 = (\n  account: CandyMachineV2Account,\n  unparsedAccount: UnparsedAccount,\n  collectionAccount: MaybeCandyMachineV2CollectionAccount | null,\n  mint: Mint | null\n): CandyMachineV2 => {\n  assert(\n    mint === null ||\n      (account.data.tokenMint !== null &&\n        mint.address.equals(account.data.tokenMint))\n  );\n\n  const itemsAvailable = toBigNumber(account.data.data.itemsAvailable);\n  const itemsMinted = toBigNumber(account.data.itemsRedeemed);\n\n  const { endSettings } = account.data.data;\n  const { hiddenSettings } = account.data.data;\n  const { whitelistMintSettings } = account.data.data;\n  const { gatekeeper } = account.data.data;\n\n  const rawData = unparsedAccount.data;\n  const itemsLoaded = hiddenSettings\n    ? toBigNumber(0)\n    : countCandyMachineV2Items(rawData);\n  const items = hiddenSettings ? [] : parseCandyMachineV2Items(rawData);\n\n  return {\n    model: 'candyMachineV2',\n    address: account.publicKey,\n    programAddress: account.owner,\n    version: account.owner.equals(CandyMachineV2Program.publicKey) ? 2 : 1,\n    authorityAddress: account.data.authority,\n    walletAddress: account.data.wallet,\n    tokenMintAddress: account.data.tokenMint,\n    collectionMintAddress:\n      collectionAccount && collectionAccount.exists\n        ? collectionAccount.data.mint\n        : null,\n    uuid: account.data.data.uuid,\n\n    price: amount(account.data.data.price, mint ? mint.currency : SOL),\n    symbol: removeEmptyChars(account.data.data.symbol),\n    sellerFeeBasisPoints: account.data.data.sellerFeeBasisPoints,\n    isMutable: account.data.data.isMutable,\n    retainAuthority: account.data.data.retainAuthority,\n    goLiveDate: toOptionDateTime(account.data.data.goLiveDate),\n    maxEditionSupply: toBigNumber(account.data.data.maxSupply),\n    items,\n    itemsAvailable,\n    itemsMinted,\n    itemsRemaining: toBigNumber(itemsAvailable.sub(itemsMinted)),\n    itemsLoaded,\n    isFullyLoaded: itemsAvailable.lte(itemsLoaded),\n    // eslint-disable-next-line no-nested-ternary\n    endSettings: endSettings\n      ? endSettings.endSettingType === EndSettingType.Date\n        ? {\n            endSettingType: EndSettingType.Date,\n            date: toDateTime(endSettings.number),\n          }\n        : {\n            endSettingType: EndSettingType.Amount,\n            number: toBigNumber(endSettings.number),\n          }\n      : null,\n    hiddenSettings,\n    whitelistMintSettings: whitelistMintSettings\n      ? {\n          ...whitelistMintSettings,\n          discountPrice: whitelistMintSettings.discountPrice\n            ? lamports(whitelistMintSettings.discountPrice)\n            : null,\n        }\n      : null,\n    gatekeeper: gatekeeper\n      ? {\n          ...gatekeeper,\n          network: gatekeeper.gatekeeperNetwork,\n        }\n      : null,\n    creators: account.data.data.creators,\n  };\n};\n\n// -----------------\n// Model to Configs\n// -----------------\n\n/**\n * This object provides a common interface for the configurations required\n * to create or update Candy Machines.\n *\n * @group Models\n */\nexport type CandyMachineV2Configs = {\n  /**\n   * The address of the wallet receiving the payments for minting NFTs.\n   * If the Candy Machine accepts payments in SOL, this is the SOL treasury account.\n   * Otherwise, this is the token account associated with the treasury Mint.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  wallet: PublicKey;\n\n  /**\n   * The address of the Mint account of the SPL Token that should be used\n   * to accept payments for minting NFTs. When `null`, it means the\n   * Candy Machine account accepts payments in SOL.\n   */\n  tokenMint: Option<PublicKey>;\n\n  /**\n   * The price of minting an NFT.\n   *\n   * If the Candy Machine uses no treasury mint (i.e. the `tokenMintAddress`\n   * is `null`), this amount will be in SOL. Otherwise, its currency will\n   * match the currency of the treasury mint.\n   *\n   * @example\n   * ```ts\n   * { price: sol(1.5) } // For 1.5 SOL.\n   * { price: token(320, 2, MYTOKEN) } // For 3.2 MYTOKEN which is a 2-decimal token.\n   * ```\n   */\n  price: Amount;\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points\n   *\n   * @example\n   * ```ts\n   * { sellerFeeBasisPoints: 250 } // For 2.5% royalties.\n   * ```\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   *\n   * @example\n   * ```ts\n   * { itemsAvailable: toBigNumber(1000) } // For 1000 items.\n   * ```\n   */\n  itemsAvailable: BigNumber;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol: string;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxEditionSupply: BigNumber;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   *\n   * @defaultValue `true`\n   */\n  isMutable: boolean;\n\n  /**\n   * Wheter the minted NFTs should use the Candy Machine authority\n   * as their update authority.\n   *\n   * We strongly recommend setting this to `true` unless you have a\n   * specific reason. When set to `false`, the update authority will\n   * be given to the address that minted the NFT and you will no longer\n   * be able to update the minted NFTs in the future.\n   *\n   * @defaultValue `true`\n   */\n  retainAuthority: boolean;\n\n  /**\n   * The timestamp of when the Candy Machine will be live.\n   *\n   * If this is `null` or if the timestamp refers to a time in the\n   * future, no one will be able to mint NFTs from the Candy Machine\n   * (except its authority that can bypass this live date).\n   *\n   * @defaultValue `null`\n   */\n  goLiveDate: Option<DateTime>;\n\n  /**\n   * An optional constraint defining when the Candy Machine will end.\n   * If this is `null`, the Candy Machine will end when there are\n   * no more items to mint from (i.e. `itemsRemaining` is `0`).\n   *\n   * @defaultValue `null`\n   */\n  endSettings: Option<CandyMachineV2EndSettings>;\n\n  /**\n   * {@inheritDoc CandyMachineHiddenSettings}\n   * @defaultValue `null`\n   */\n  hiddenSettings: Option<CandyMachineV2HiddenSettings>;\n\n  /**\n   * {@inheritDoc CandyMachineWhitelistMintSettings}\n   * @defaultValue `null`\n   */\n  whitelistMintSettings: Option<CandyMachineV2WhitelistMintSettings>;\n\n  /**\n   * {@inheritDoc CandyMachineGatekeeper}\n   * @defaultValue `null`\n   */\n  gatekeeper: Option<CandyMachineV2Gatekeeper>;\n\n  /**\n   * {@inheritDoc Creator}\n   * @defaultValue\n   * ```ts\n   * [{\n   *   address: metaplex.identity().publicKey,\n   *   share: 100,\n   *   verified: false,\n   * }]\n   * ```\n   */\n  creators: Creator[];\n};\n\n/** @group Model Helpers */\nexport const toCandyMachineV2Configs = (\n  candyMachine: CandyMachineV2\n): CandyMachineV2Configs => {\n  return {\n    wallet: candyMachine.walletAddress,\n    tokenMint: candyMachine.tokenMintAddress,\n    ...candyMachine,\n  };\n};\n\n// -----------------\n// Configs to Program\n// -----------------\n\n/** @group Models */\nexport type CandyMachineV2InstructionData = {\n  wallet: PublicKey;\n  tokenMint: Option<PublicKey>;\n  data: CandyMachineData;\n};\n\n/** @group Model Helpers */\nexport const toCandyMachineV2InstructionData = (\n  address: PublicKey,\n  configs: CandyMachineV2Configs\n): CandyMachineV2InstructionData => {\n  const { endSettings } = configs;\n  const { whitelistMintSettings } = configs;\n  const { gatekeeper } = configs;\n\n  return {\n    wallet: configs.wallet,\n    tokenMint: configs.tokenMint,\n    data: {\n      ...configs,\n      uuid: getCandyMachineV2UuidFromAddress(address),\n      price: configs.price.basisPoints,\n      maxSupply: configs.maxEditionSupply,\n      endSettings: endSettings\n        ? {\n            ...endSettings,\n            number:\n              endSettings.endSettingType === EndSettingType.Date\n                ? endSettings.date\n                : endSettings.number,\n          }\n        : null,\n      whitelistMintSettings: whitelistMintSettings\n        ? {\n            ...whitelistMintSettings,\n            discountPrice:\n              whitelistMintSettings.discountPrice?.basisPoints ?? null,\n          }\n        : null,\n      gatekeeper: gatekeeper\n        ? {\n            ...gatekeeper,\n            gatekeeperNetwork: gatekeeper.network,\n          }\n        : null,\n    },\n  };\n};\n","import {\n  createInitializeCandyMachineInstruction,\n  createSetCollectionInstruction,\n  Creator,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { getCandyMachineV2AccountSizeFromData } from '../helpers';\nimport {\n  CandyMachineV2,\n  CandyMachineV2Configs,\n  toCandyMachineV2InstructionData,\n} from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { CandyMachineV2Program } from '../program';\nimport {\n  Option,\n  RequiredKeys,\n  TransactionBuilder,\n  TransactionBuilderOptions,\n} from '@/utils';\nimport {\n  assertSameCurrencies,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SOL,\n  toBigNumber,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { ExpectedSignerError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCandyMachineV2Operation' as const;\n\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const { candyMachine } = await metaplex\n *   .candyMachinesV2()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCandyMachineV2Operation =\n  useOperation<CreateCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCandyMachineV2Operation = Operation<\n  typeof Key,\n  CreateCandyMachineV2Input,\n  CreateCandyMachineV2Output\n>;\n\nexport type CreateCandyMachineV2InputWithoutConfigs = {\n  /**\n   * The Candy Machine to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  candyMachine?: Signer;\n\n  /**\n   * The authority that will be allowed to update the Candy Machine.\n   * Upon creation, passing the authority's public key is enough to set it.\n   * However, when also passing a `collection` to this operation,\n   * this authority will need to be passed as a Signer so the relevant\n   * instruction can be signed.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer | PublicKey; // Defaults to mx.identity().\n\n  /**\n   * The mint address of the Collection NFT that all NFTs minted from\n   * this Candy Machine should be part of.\n   * When provided, the `authority` parameter will need to be passed as a `Signer`.\n   * When `null`, minted NFTs won't be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCandyMachineV2Input =\n  CreateCandyMachineV2InputWithoutConfigs &\n    RequiredKeys<\n      Partial<CandyMachineV2Configs>,\n      'price' | 'sellerFeeBasisPoints' | 'itemsAvailable'\n    >;\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The created Candy Machine. */\n  candyMachine: CandyMachineV2;\n\n  /** The create Candy Machine's account as a Signer. */\n  candyMachineSigner: Signer;\n\n  /** The created Candy Machine's wallet. */\n  wallet: PublicKey;\n\n  /** The created Candy Machine's authority. */\n  authority: PublicKey;\n\n  /** The created Candy Machine's creators. */\n  creators: Creator[];\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCandyMachineV2OperationHandler: OperationHandler<CreateCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: CreateCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateCandyMachineV2Output> {\n      const builder = await createCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const candyMachine = await metaplex\n        .candyMachinesV2()\n        .findByAddress({ address: output.candyMachineSigner.publicKey }, scope);\n\n      return { ...output, candyMachine };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCandyMachineV2BuilderParams = Omit<\n  CreateCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the Candy Machine. */\n  initializeCandyMachineInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection. */\n  setCollectionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCandyMachineV2BuilderContext = Omit<\n  CreateCandyMachineV2Output,\n  'response' | 'candyMachine'\n>;\n\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCandyMachineV2Builder = async (\n  metaplex: Metaplex,\n  params: CreateCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateCandyMachineV2BuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const candyMachine = params.candyMachine ?? Keypair.generate();\n  const authority = params.authority ?? metaplex.identity();\n  const collection: PublicKey | null = params.collection ?? null;\n\n  const { data, wallet, tokenMint } = toCandyMachineV2InstructionData(\n    candyMachine.publicKey,\n    {\n      ...params,\n      wallet: params.wallet ?? metaplex.identity().publicKey,\n      tokenMint: params.tokenMint ?? null,\n      symbol: params.symbol ?? '',\n      maxEditionSupply: params.maxEditionSupply ?? toBigNumber(0),\n      isMutable: params.isMutable ?? true,\n      retainAuthority: params.retainAuthority ?? true,\n      goLiveDate: params.goLiveDate ?? null,\n      endSettings: params.endSettings ?? null,\n      creators: params.creators ?? [\n        {\n          address: metaplex.identity().publicKey,\n          share: 100,\n          verified: false,\n        },\n      ],\n      hiddenSettings: params.hiddenSettings ?? null,\n      whitelistMintSettings: params.whitelistMintSettings ?? null,\n      gatekeeper: params.gatekeeper ?? null,\n    }\n  );\n\n  const initializeInstruction = createInitializeCandyMachineInstruction(\n    {\n      candyMachine: candyMachine.publicKey,\n      wallet,\n      authority: toPublicKey(authority),\n      payer: payer.publicKey,\n    },\n    { data }\n  );\n\n  if (tokenMint) {\n    initializeInstruction.keys.push({\n      pubkey: tokenMint,\n      isWritable: false,\n      isSigner: false,\n    });\n  } else {\n    assertSameCurrencies(params.price, SOL);\n  }\n\n  return (\n    TransactionBuilder.make<CreateCandyMachineV2BuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        candyMachineSigner: candyMachine,\n        wallet,\n        authority: toPublicKey(authority),\n        creators: data.creators,\n      })\n\n      // Create an empty account for the candy machine.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: candyMachine,\n              space: getCandyMachineV2AccountSizeFromData(data),\n              program: CandyMachineV2Program.publicKey,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the candy machine account.\n      .add({\n        instruction: initializeInstruction,\n        signers: [candyMachine, payer],\n        key:\n          params.initializeCandyMachineInstructionKey ??\n          'initializeCandyMachine',\n      })\n\n      // Set the collection.\n      .when(!!collection, (builder) => {\n        if (!isSigner(authority)) {\n          throw new ExpectedSignerError(\n            'authority',\n            'PublicKey',\n            'You are trying to create a Candy Machine with a Collection NFT. ' +\n              'In order for the Collection NFT to be set successfully, you must provide the authority as a Signer. ' +\n              'Please provide the \"authority\" parameter as a Signer if you want to set the Collection NFT upon creation. ' +\n              'Alternatively, you may remove the \"collection\" parameter to create a Candy Machine without an associated Collection NFT.'\n          );\n        }\n\n        const collectionMint = collection as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const edition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.publicKey\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionInstruction({\n            candyMachine: candyMachine.publicKey,\n            authority: toPublicKey(authority),\n            collectionPda,\n            payer: payer.publicKey,\n            metadata,\n            mint: collectionMint,\n            edition,\n            collectionAuthorityRecord,\n            tokenMetadataProgram: metaplex.programs().getTokenMetadata()\n              .address,\n          }),\n          signers: [authority],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n  );\n};\n","import { createWithdrawFundsInstruction } from '@metaplex-foundation/mpl-candy-machine';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyMachineV2 } from '../models/CandyMachineV2';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'DeleteCandyMachineV2Operation' as const;\n\n/**\n * Deletes an existing Candy Machine.\n *\n * ```ts\n * await metaplex.candyMachinesV2().delete({ candyMachine });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const deleteCandyMachineV2Operation =\n  useOperation<DeleteCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type DeleteCandyMachineV2Operation = Operation<\n  typeof Key,\n  DeleteCandyMachineV2Input,\n  DeleteCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type DeleteCandyMachineV2Input = {\n  /**\n   * The Candy Machine to delete.\n   * We need the address of the Candy Machine as well as the address\n   * of the potential collection since we will need to delete the PDA account\n   * that links the Candy Machine to the collection.\n   *\n   * If the Candy Machine does not have a collection, simply set\n   * `collectionMintAddress` to `null`.\n   */\n  candyMachine: Pick<CandyMachineV2, 'address' | 'collectionMintAddress'>;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type DeleteCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const deleteCandyMachineV2OperationHandler: OperationHandler<DeleteCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: DeleteCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<DeleteCandyMachineV2Output> {\n      return deleteCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type DeleteCandyMachineV2BuilderParams = Omit<\n  DeleteCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that deletes the Candy Machine. */\n  instructionKey?: string;\n};\n\n/**\n * Deletes an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .delete({\n *     candyMachine: { address, collectionMintAddress },\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const deleteCandyMachineV2Builder = (\n  metaplex: Metaplex,\n  params: DeleteCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const authority = params.authority ?? metaplex.identity();\n  const { candyMachine } = params;\n\n  const deleteInstruction = createWithdrawFundsInstruction({\n    candyMachine: candyMachine.address,\n    authority: authority.publicKey,\n  });\n\n  if (candyMachine.collectionMintAddress) {\n    const collectionPda = findCandyMachineV2CollectionPda(candyMachine.address);\n    deleteInstruction.keys.push({\n      pubkey: collectionPda,\n      isWritable: true,\n      isSigner: false,\n    });\n  }\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: deleteInstruction,\n      signers: [authority],\n      key: params.instructionKey ?? 'withdrawFunds',\n    });\n};\n","import { EndSettingType } from '@metaplex-foundation/mpl-candy-machine';\nimport { CandyMachineV2Item, CandyMachineV2EndSettings } from './models';\nimport { MetaplexError } from '@/errors';\nimport { BigNumber, DateTime, formatDateTime } from '@/types';\nimport { Option } from '@/utils';\n\n/** @group Errors */\nexport class CandyMachineV2Error extends MetaplexError {\n  readonly name: string = 'CandyMachineV2Error';\n  constructor(message: string, cause?: Error) {\n    super(message, 'plugin', 'Candy Machine V2', cause);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2IsFullError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2IsFullError';\n  constructor(assetIndex: BigNumber, itemsAvailable: BigNumber) {\n    const message =\n      `Trying to add asset number ${assetIndex.addn(1)}, but ` +\n      `candy machine only can hold ${itemsAvailable} assets. ` +\n      'Limit number of assets you are adding or create a new Candy Machine that can hold more.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2IsEmptyError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2IsEmptyError';\n  constructor(itemsAvailable: BigNumber) {\n    const message =\n      `You're trying to mint from an empty candy machine. ` +\n      `All ${itemsAvailable} items have been minted. ` +\n      'You can no longer mint from this Candy Machine.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2CannotAddAmountError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2CannotAddAmountError';\n  constructor(index: BigNumber, amount: number, itemsAvailable: BigNumber) {\n    const message =\n      `Trying to add ${amount} assets to candy machine that already ` +\n      `has ${index} assets and can only hold ${itemsAvailable} assets.` +\n      'Limit number of assets you are adding or create a new Candy Machine that can hold more.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2AddItemConstraintsViolatedError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2AddItemConstraintsViolatedError';\n  constructor(index: BigNumber, item: CandyMachineV2Item, cause: Error) {\n    const message =\n      `Trying to add an asset with name \"${item.name}\" and uri: \"${item.uri}\" ` +\n      `to candy machine at index ${index} that violates constraints. ` +\n      `Fix the name or URI of this asset and try again.`;\n    super(message, cause);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2NotLiveError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2NotLiveError';\n  constructor(goLiveDate: Option<DateTime>) {\n    const message =\n      `You're trying to mint from a Candy Machine which is not live yet. ` +\n      (goLiveDate\n        ? `It will go live on ${formatDateTime(goLiveDate)}.`\n        : `Its live date has not been set yet.`) +\n      'You need to wait until the Candy Machine is live to mint from it. ' +\n      'If this is your Candy Machine, use \"metaplex.candyMachinesV2().update(...)\" to set the live date. ' +\n      'Note that the authority of the Candy Machine can mint regardless of the live date.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2EndedError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2EndedError';\n  constructor(endSetting: CandyMachineV2EndSettings) {\n    const endSettingType =\n      endSetting.endSettingType === EndSettingType.Amount ? 'Amount' : 'Date';\n    const endSettingExplanation =\n      endSetting.endSettingType === EndSettingType.Amount\n        ? `All ${endSetting.number} items have been minted.`\n        : `It ended on ${formatDateTime(endSetting.date)}.`;\n    const message =\n      `The end condition [${endSettingType}] of this Candy Machine has been reached. ` +\n      endSettingExplanation;\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineV2BotTaxError extends CandyMachineV2Error {\n  readonly name: string = 'CandyMachineV2BotTaxError';\n  constructor(explorerLink: string, cause: Error) {\n    const message =\n      `The NFT couldn't be fetched after being minted. ` +\n      `This is most likely due to a bot tax that occured during minting. ` +\n      `When someone tries to mint an NFT from a Candy Machine which cannot be minted from, ` +\n      `the program will succeed and charge a small tax to fight against bots. ` +\n      `Ensure you can mint from the Candy Machine. ` +\n      `You may want to check the transaction logs for more details: [${explorerLink}].`;\n    super(message, cause);\n  }\n}\n","import { Creator } from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  ConfigLine,\n  EndSettingType,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport {\n  MAX_CREATOR_LIMIT,\n  MAX_NAME_LENGTH,\n  MAX_SYMBOL_LENGTH,\n  MAX_URI_LENGTH,\n} from './constants';\nimport { CandyMachineV2 } from './models';\nimport {\n  CandyMachineV2AddItemConstraintsViolatedError,\n  CandyMachineV2CannotAddAmountError,\n  CandyMachineV2EndedError,\n  CandyMachineV2IsEmptyError,\n  CandyMachineV2IsFullError,\n  CandyMachineV2NotLiveError,\n} from './errors';\nimport { assert } from '@/utils';\nimport { BigNumber, now, Signer, toBigNumber } from '@/types';\n\nexport const assertName = (name: string) => {\n  assert(\n    name.length <= MAX_NAME_LENGTH,\n    `Candy Machine name too long: ${name} (max ${MAX_NAME_LENGTH})`\n  );\n};\n\nexport const assertSymbol = (symbol: string) => {\n  assert(\n    symbol.length <= MAX_SYMBOL_LENGTH,\n    `Candy Machine symbol too long: ${symbol} (max ${MAX_SYMBOL_LENGTH})`\n  );\n};\n\nexport const assertUri = (uri: string) => {\n  assert(\n    uri.length <= MAX_URI_LENGTH,\n    `Candy Machine URI too long: ${uri} (max ${MAX_URI_LENGTH})`\n  );\n};\n\nexport const assertCreators = (creators: Creator[]) => {\n  assert(\n    creators.length <= MAX_CREATOR_LIMIT,\n    `Candy Machine creators too long: ${creators} (max ${MAX_CREATOR_LIMIT})`\n  );\n};\n\nexport const assertNotFull = (\n  candyMachine: Pick<CandyMachineV2, 'itemsAvailable' | 'itemsLoaded'>,\n  index: BigNumber\n) => {\n  if (candyMachine.itemsAvailable.lte(candyMachine.itemsLoaded)) {\n    throw new CandyMachineV2IsFullError(index, candyMachine.itemsAvailable);\n  }\n};\n\nexport const assertNotEmpty = (\n  candyMachine: Pick<CandyMachineV2, 'itemsRemaining' | 'itemsAvailable'>\n) => {\n  if (candyMachine.itemsRemaining.isZero()) {\n    throw new CandyMachineV2IsEmptyError(candyMachine.itemsAvailable);\n  }\n};\n\nexport const assertCanAdd = (\n  candyMachine: Pick<CandyMachineV2, 'itemsAvailable'>,\n  index: BigNumber,\n  amount: number\n) => {\n  if (index.addn(amount).gt(candyMachine.itemsAvailable)) {\n    throw new CandyMachineV2CannotAddAmountError(\n      index,\n      amount,\n      candyMachine.itemsAvailable\n    );\n  }\n};\n\nexport const assertAllConfigLineConstraints = (configLines: ConfigLine[]) => {\n  for (let i = 0; i < configLines.length; i++) {\n    try {\n      assertName(configLines[i].name);\n      assertUri(configLines[i].uri);\n    } catch (error) {\n      throw new CandyMachineV2AddItemConstraintsViolatedError(\n        toBigNumber(i),\n        configLines[i],\n        error as Error\n      );\n    }\n  }\n};\n\nexport const assertCandyMachineV2IsLive = (\n  candyMachine: Pick<CandyMachineV2, 'whitelistMintSettings' | 'goLiveDate'>\n) => {\n  const hasWhitelistPresale =\n    candyMachine.whitelistMintSettings?.presale ?? false;\n\n  if (hasWhitelistPresale) {\n    return;\n  }\n\n  const liveDate = candyMachine.goLiveDate;\n\n  if (!liveDate || liveDate.gte(now())) {\n    throw new CandyMachineV2NotLiveError(liveDate);\n  }\n};\n\nexport const assertCandyMachineV2HasNotEnded = (\n  candyMachine: Pick<CandyMachineV2, 'endSettings' | 'itemsMinted'>\n) => {\n  const { endSettings } = candyMachine;\n\n  if (!endSettings) {\n    return;\n  }\n\n  const hasEndedByAmount =\n    endSettings.endSettingType === EndSettingType.Amount &&\n    candyMachine.itemsMinted.gte(endSettings.number);\n  const hasEndedByDate =\n    endSettings.endSettingType === EndSettingType.Date &&\n    endSettings.date.lt(now());\n\n  if (hasEndedByAmount || hasEndedByDate) {\n    throw new CandyMachineV2EndedError(endSettings);\n  }\n};\n\nexport const assertCanMintCandyMachineV2 = (\n  candyMachine: Pick<\n    CandyMachineV2,\n    | 'authorityAddress'\n    | 'itemsRemaining'\n    | 'itemsAvailable'\n    | 'itemsMinted'\n    | 'whitelistMintSettings'\n    | 'goLiveDate'\n    | 'endSettings'\n  >,\n  payer: Signer\n) => {\n  assertNotEmpty(candyMachine);\n\n  if (candyMachine.authorityAddress.equals(payer.publicKey)) {\n    return;\n  }\n\n  assertCandyMachineV2IsLive(candyMachine);\n  assertCandyMachineV2HasNotEnded(candyMachine);\n};\n","import { createAddConfigLinesInstruction } from '@metaplex-foundation/mpl-candy-machine';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  assertAllConfigLineConstraints,\n  assertCanAdd,\n  assertNotFull,\n} from '../asserts';\nimport { CandyMachineV2, CandyMachineV2Item } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'InsertItemsToCandyMachineV2Operation' as const;\n\n/**\n * Insert items into an existing Candy Machine.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .insertItems({\n *     candyMachine,\n *     items: [\n *       { name: 'My NFT #1', uri: 'https://example.com/nft1' },\n *       { name: 'My NFT #2', uri: 'https://example.com/nft2' },\n *       { name: 'My NFT #3', uri: 'https://example.com/nft3' },\n *     ],\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const insertItemsToCandyMachineV2Operation =\n  useOperation<InsertItemsToCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type InsertItemsToCandyMachineV2Operation = Operation<\n  typeof Key,\n  InsertItemsToCandyMachineV2Input,\n  InsertItemsToCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type InsertItemsToCandyMachineV2Input = {\n  /**\n   * The Candy Machine to insert items into.\n   *\n   * We only need a subset of the `CandyMachine` model.\n   * We need its address and the number of items loaded and to be loaded\n   * so we can check if the operation is valid.\n   */\n  candyMachine: Pick<\n    CandyMachineV2,\n    'itemsAvailable' | 'itemsLoaded' | 'address'\n  >;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The items to insert into the candy machine.\n   */\n  items: CandyMachineV2Item[];\n\n  /**\n   * The index we should use to insert the new items. This refers to the\n   * index of the first item to insert and the others will follow after it.\n   *\n   * By defaults, this uses the `itemsLoaded` property so items are simply\n   * appended to the current items.\n   *\n   * @defaultValue `candyMachine.itemsLoaded`\n   */\n  index?: BigNumber;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type InsertItemsToCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const InsertItemsToCandyMachineV2OperationHandler: OperationHandler<InsertItemsToCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: InsertItemsToCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<InsertItemsToCandyMachineV2Output> {\n      return insertItemsToCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type InsertItemsToCandyMachineV2BuilderParams = Omit<\n  InsertItemsToCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  instructionKey?: string;\n};\n\n/**\n * Insert items into an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachines()\n *   .builders()\n *   .insertItems({ candyMachine, items });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const insertItemsToCandyMachineV2Builder = (\n  metaplex: Metaplex,\n  params: InsertItemsToCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const authority = params.authority ?? metaplex.identity();\n  const index = params.index ?? params.candyMachine.itemsLoaded;\n  const { items } = params;\n  assertNotFull(params.candyMachine, index);\n  assertCanAdd(params.candyMachine, index, items.length);\n  assertAllConfigLineConstraints(items);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createAddConfigLinesInstruction(\n        {\n          candyMachine: params.candyMachine.address,\n          authority: authority.publicKey,\n        },\n        { index: index.toNumber(), configLines: items }\n      ),\n      signers: [authority],\n      key: params.instructionKey ?? 'insertItems',\n    });\n};\n","import {\n  CandyMachine,\n  CollectionPDA,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport {\n  Account,\n  getAccountParsingAndAssertingFunction,\n  getAccountParsingFunction,\n  MaybeAccount,\n} from '@/types';\n\n/** @group Accounts */\nexport type CandyMachineV2Account = Account<CandyMachine>;\n\n/** @group Account Helpers */\nexport const parseCandyMachineV2Account =\n  getAccountParsingFunction(CandyMachine);\n\n/** @group Account Helpers */\nexport const toCandyMachineV2Account =\n  getAccountParsingAndAssertingFunction(CandyMachine);\n\n/** @group Accounts */\nexport type CandyMachineV2CollectionAccount = Account<CollectionPDA>;\n\n/** @group Accounts */\nexport type MaybeCandyMachineV2CollectionAccount = MaybeAccount<CollectionPDA>;\n\n/** @group Account Helpers */\nexport const parseCandyMachineV2CollectionAccount =\n  getAccountParsingFunction(CollectionPDA);\n\n/** @group Account Helpers */\nexport const toCandyMachineV2CollectionAccount =\n  getAccountParsingAndAssertingFunction(CollectionPDA);\n","import {\n  createMintNftInstruction,\n  createSetCollectionDuringMintInstruction,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport {\n  Keypair,\n  PublicKey,\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n} from '@solana/web3.js';\nimport { NftWithToken } from '../../nftModule';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { parseCandyMachineV2CollectionAccount } from '../accounts';\nimport { assertCanMintCandyMachineV2 } from '../asserts';\nimport { CandyMachineV2BotTaxError } from '../errors';\nimport { CandyMachineV2 } from '../models';\nimport {\n  findCandyMachineV2CollectionPda,\n  findCandyMachineV2CreatorPda,\n} from '../pdas';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  assertAccountExists,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintCandyMachineV2Operation' as const;\n\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachinesV2()\n *   .mint({ candyMachine };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintCandyMachineV2Operation =\n  useOperation<MintCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintCandyMachineV2Operation = Operation<\n  typeof Key,\n  MintCandyMachineV2Input,\n  MintCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintCandyMachineV2Input = {\n  /**\n   * The Candy Machine to mint from.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to mint from it.\n   *\n   * This includes, its wallet address, its item statistics, it live date,\n   * its whitelist settings, etc.\n   */\n  candyMachine: Pick<\n    CandyMachineV2,\n    | 'address'\n    | 'walletAddress'\n    | 'authorityAddress'\n    | 'tokenMintAddress'\n    | 'itemsRemaining'\n    | 'itemsAvailable'\n    | 'itemsMinted'\n    | 'whitelistMintSettings'\n    | 'goLiveDate'\n    | 'endSettings'\n  >;\n\n  /**\n   * The mint account to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  newMint?: Signer;\n\n  /**\n   * The owner of the minted NFT.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  newOwner?: PublicKey;\n\n  /**\n   * The new token account to create as a Signer.\n   *\n   * This property would typically be ignored as, by default, it will create a\n   * associated token account from the `newOwner` and `newMint` properties.\n   *\n   * When provided, the `newOwner` property will be ignored.\n   *\n   * @defaultValue associated token address of `newOwner` and `newMint`.\n   */\n  newToken?: Signer;\n\n  /**\n   * The token account that should pay for the minted NFT.\n   *\n   * This is only relevant when the Candy Machine uses a mint treasury\n   * (i.e. payments are made using SPL tokens and not SOL).\n   *\n   * @defaultValue associated token address of `payer` and\n   * `candyMachine.tokenMintAddress`.\n   */\n  payerToken?: PublicKey;\n\n  /**\n   * The token account that contains whitelist tokens.\n   *\n   * This is only relevant when the Candy Machine uses\n   * whitelist settings.\n   *\n   * @defaultValue associated token address of `payer` and\n   * `candyMachine.whitelistMintSettings.mint`.\n   */\n  whitelistToken?: PublicKey; // Defaults to associated token.\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The minted NFT. */\n  nft: NftWithToken;\n\n  /** The mint account of the minted NFT as a Signer. */\n  mintSigner: Signer;\n\n  /** The token account's address of the minted NFT. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintCandyMachineV2OperationHandler: OperationHandler<MintCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: MintCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MintCandyMachineV2Output> {\n      assertCanMintCandyMachineV2(operation.input.candyMachine, scope.payer);\n\n      const builder = await mintCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      let nft: NftWithToken;\n      try {\n        nft = (await metaplex.nfts().findByMint(\n          {\n            mintAddress: output.mintSigner.publicKey,\n            tokenAddress: output.tokenAddress,\n          },\n          scope\n        )) as NftWithToken;\n      } catch (error) {\n        throw new CandyMachineV2BotTaxError(\n          metaplex.rpc().getSolanaExporerUrl(output.response.signature),\n          error as Error\n        );\n      }\n\n      return { nft, ...output };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintCandyMachineV2BuilderParams = Omit<\n  MintCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account of the NFT. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account of the NFT. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account of the NFT. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account of the NFT. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account of the NFT. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the one token. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the NFT. */\n  mintNftInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection on the minted NFT. */\n  setCollectionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type MintCandyMachineV2BuilderContext = Omit<\n  MintCandyMachineV2Output,\n  'response' | 'nft'\n>;\n\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .mint({ candyMachine });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintCandyMachineV2Builder = async (\n  metaplex: Metaplex,\n  params: MintCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<MintCandyMachineV2BuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    newMint = Keypair.generate(),\n    newOwner = metaplex.identity().publicKey,\n    newToken,\n  } = params;\n\n  const tokenMetadataProgram = metaplex\n    .programs()\n    .getTokenMetadata(programs).address;\n\n  const newMetadata = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const newEdition = metaplex.nfts().pdas().masterEdition({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const candyMachineCreator = findCandyMachineV2CreatorPda(\n    candyMachine.address\n  );\n  const candyMachineCollectionAddress = findCandyMachineV2CollectionPda(\n    candyMachine.address\n  );\n  const candyMachineCollectionAccount = parseCandyMachineV2CollectionAccount(\n    await metaplex.rpc().getAccount(candyMachineCollectionAddress)\n  );\n\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: token(1),\n        mint: newMint,\n        mintAuthority: payer,\n        freezeAuthority: payer.publicKey,\n        owner: newOwner,\n        token: newToken,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n\n  const mintNftInstruction = createMintNftInstruction(\n    {\n      candyMachine: candyMachine.address,\n      candyMachineCreator,\n      payer: payer.publicKey,\n      wallet: candyMachine.walletAddress,\n      metadata: newMetadata,\n      mint: newMint.publicKey,\n      mintAuthority: payer.publicKey,\n      updateAuthority: payer.publicKey,\n      masterEdition: newEdition,\n      tokenMetadataProgram,\n      clock: SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n      instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,\n    },\n    { creatorBump: candyMachineCreator.bump }\n  );\n\n  if (candyMachine.whitelistMintSettings) {\n    const whitelistToken =\n      params.whitelistToken ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: candyMachine.whitelistMintSettings.mint,\n        owner: payer.publicKey,\n      });\n\n    mintNftInstruction.keys.push(\n      {\n        pubkey: whitelistToken,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: candyMachine.whitelistMintSettings.mint,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: payer.publicKey,\n        isWritable: false,\n        isSigner: true,\n      }\n    );\n  }\n\n  if (candyMachine.tokenMintAddress) {\n    const payerToken =\n      params.payerToken ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: candyMachine.tokenMintAddress,\n        owner: payer.publicKey,\n      });\n\n    mintNftInstruction.keys.push(\n      {\n        pubkey: payerToken,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: payer.publicKey,\n        isWritable: false,\n        isSigner: true,\n      }\n    );\n  }\n\n  return (\n    TransactionBuilder.make<MintCandyMachineV2BuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintSigner: newMint,\n        tokenAddress,\n      })\n\n      // Create token and mint accounts.\n      .add(tokenWithMintBuilder)\n\n      // Create the new NFT.\n      .add({\n        instruction: mintNftInstruction,\n        signers: [payer, newMint],\n        key: params.mintNftInstructionKey ?? 'mintNft',\n      })\n\n      // Set the collection on the NFT.\n      .when(candyMachineCollectionAccount.exists, (builder) => {\n        assertAccountExists(candyMachineCollectionAccount);\n        const collectionMint = candyMachineCollectionAccount.data.mint;\n        const collectionMetadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: candyMachineCollectionAccount.publicKey,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionDuringMintInstruction({\n            candyMachine: candyMachine.address,\n            metadata: newMetadata,\n            payer: payer.publicKey,\n            collectionPda: candyMachineCollectionAccount.publicKey,\n            tokenMetadataProgram,\n            instructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            collectionMint: candyMachineCollectionAccount.data.mint,\n            collectionMetadata,\n            collectionMasterEdition,\n            authority: candyMachine.authorityAddress,\n            collectionAuthorityRecord,\n          }),\n          signers: [payer],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n  );\n};\n","import {\n  CandyMachineData,\n  createRemoveCollectionInstruction,\n  createSetCollectionInstruction,\n  createUpdateAuthorityInstruction,\n  createUpdateCandyMachineInstruction,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport type { PublicKey } from '@solana/web3.js';\nimport isEqual from 'lodash.isequal';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  CandyMachineV2,\n  CandyMachineV2Configs,\n  toCandyMachineV2Configs,\n  toCandyMachineV2InstructionData,\n} from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { NoInstructionsToSendError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyMachineV2Operation' as const;\n\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * await metaplex\n *   .candyMachinesV2()\n *   .update({\n *     candyMachine,\n *     price: sol(2), // Updates the price only.\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateCandyMachineV2Operation =\n  useOperation<UpdateCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateCandyMachineV2Operation = Operation<\n  typeof Key,\n  UpdateCandyMachineV2Input,\n  UpdateCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateCandyMachineV2Input = Partial<CandyMachineV2Configs> & {\n  /**\n   * The Candy Machine to update.\n   * We need the full model in order to compare the current data with\n   * the provided data to update. For instance, if you only want to\n   * update the `price`, we need to send an instruction that updates\n   * the data whilst keeping all other properties the same.\n   *\n   * If you want more control over how this transaction is built,\n   * you may use the associated transaction builder instead using\n   * `metaplex.candyMachinesV2().builders().updateCandyMachineV2({...})`.\n   */\n  candyMachine: CandyMachineV2;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The new Candy Machine authority.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newAuthority?: PublicKey;\n\n  /**\n   * The mint address of the new Candy Machine collection.\n   * When `null` is provided, the collection is removed.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newCollection?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateCandyMachineV2OperationHandler: OperationHandler<UpdateCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: UpdateCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UpdateCandyMachineV2Output> {\n      const {\n        candyMachine,\n        authority = metaplex.identity(),\n        newAuthority,\n        newCollection,\n        ...updatableFields\n      } = operation.input;\n\n      const currentConfigs = toCandyMachineV2Configs(candyMachine);\n      const instructionDataWithoutChanges = toCandyMachineV2InstructionData(\n        candyMachine.address,\n        currentConfigs\n      );\n      const instructionData = toCandyMachineV2InstructionData(\n        candyMachine.address,\n        {\n          ...currentConfigs,\n          ...updatableFields,\n        }\n      );\n      const { data, wallet, tokenMint } = instructionData;\n      const shouldUpdateData = !isEqual(\n        instructionData,\n        instructionDataWithoutChanges\n      );\n\n      const builder = updateCandyMachineV2Builder(\n        metaplex,\n        {\n          candyMachine,\n          authority,\n          newData: shouldUpdateData\n            ? { ...data, wallet, tokenMint }\n            : undefined,\n          newCollection,\n          newAuthority,\n        },\n        scope\n      );\n\n      if (builder.isEmpty()) {\n        throw new NoInstructionsToSendError(Key);\n      }\n\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateCandyMachineV2BuilderParams = {\n  /**\n   * The Candy Machine to update.\n   * We only need a subset of the `CandyMachine` model to figure out\n   * the current values for the wallet and collection addresses.\n   */\n  candyMachine: Pick<\n    CandyMachineV2,\n    'address' | 'walletAddress' | 'collectionMintAddress'\n  >;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The new Candy Machine data.\n   * This includes the wallet and token mint addresses\n   * which can both be updated.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newData?: CandyMachineData & {\n    wallet: PublicKey;\n    tokenMint: Option<PublicKey>;\n  };\n\n  /**\n   * The new Candy Machine authority.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newAuthority?: PublicKey;\n\n  /**\n   * The mint address of the new Candy Machine collection.\n   * When `null` is provided, the collection is removed.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newCollection?: Option<PublicKey>;\n\n  /** A key to distinguish the instruction that updates the data. */\n  updateInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the authority. */\n  updateAuthorityInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection. */\n  setCollectionInstructionKey?: string;\n\n  /** A key to distinguish the instruction that removes the collection. */\n  removeCollectionInstructionKey?: string;\n};\n\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .update({\n *     candyMachine: { address, walletAddress, collectionMintAddress },\n *     newData: {...}, // Updates the provided data.\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateCandyMachineV2Builder = (\n  metaplex: Metaplex,\n  params: UpdateCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    authority = metaplex.identity(),\n    newData,\n    newAuthority,\n    newCollection,\n  } = params;\n  const tokenMetadataProgram = metaplex\n    .programs()\n    .getTokenMetadata(programs).address;\n  const shouldUpdateAuthority =\n    !!newAuthority && !newAuthority.equals(authority.publicKey);\n  const sameCollection =\n    newCollection &&\n    candyMachine.collectionMintAddress &&\n    candyMachine.collectionMintAddress.equals(newCollection);\n  const shouldUpdateCollection = !!newCollection && !sameCollection;\n  const shouldRemoveCollection =\n    !shouldUpdateCollection &&\n    newCollection === null &&\n    candyMachine.collectionMintAddress !== null;\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update data.\n      .when(!!newData, (builder) => {\n        const data = newData as CandyMachineData;\n        const wallet = newData?.wallet as PublicKey;\n        const tokenMint = newData?.tokenMint as Option<PublicKey>;\n        const updateInstruction = createUpdateCandyMachineInstruction(\n          {\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            wallet,\n          },\n          { data }\n        );\n\n        if (tokenMint) {\n          updateInstruction.keys.push({\n            pubkey: tokenMint,\n            isWritable: false,\n            isSigner: false,\n          });\n        }\n\n        return builder.add({\n          instruction: updateInstruction,\n          signers: [authority],\n          key: params.updateInstructionKey ?? 'update',\n        });\n      })\n\n      // Set or update collection.\n      .when(shouldUpdateCollection, (builder) => {\n        const collectionMint = newCollection as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const edition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.address\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionInstruction({\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            collectionPda,\n            payer: payer.publicKey,\n            metadata,\n            mint: collectionMint,\n            edition,\n            collectionAuthorityRecord,\n            tokenMetadataProgram,\n          }),\n          signers: [payer, authority],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n\n      // Remove collection.\n      .when(shouldRemoveCollection, (builder) => {\n        const collectionMint = candyMachine.collectionMintAddress as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.address\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createRemoveCollectionInstruction({\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            collectionPda,\n            metadata,\n            mint: collectionMint,\n            collectionAuthorityRecord,\n            tokenMetadataProgram,\n          }),\n          signers: [authority],\n          key: params.removeCollectionInstructionKey ?? 'removeCollection',\n        });\n      })\n\n      // Update authority.\n      .when(shouldUpdateAuthority, (builder) =>\n        builder.add({\n          instruction: createUpdateAuthorityInstruction(\n            {\n              candyMachine: candyMachine.address,\n              authority: authority.publicKey,\n              wallet: newData?.wallet ?? candyMachine.walletAddress,\n            },\n            { newAuthority: newAuthority as PublicKey }\n          ),\n          signers: [authority],\n          key: params.updateAuthorityInstructionKey ?? 'updateAuthority',\n        })\n      )\n  );\n};\n","import {\n  createCandyMachineV2Builder,\n  CreateCandyMachineV2BuilderParams,\n  deleteCandyMachineV2Builder,\n  DeleteCandyMachineV2BuilderParams,\n  insertItemsToCandyMachineV2Builder,\n  InsertItemsToCandyMachineV2BuilderParams,\n  mintCandyMachineV2Builder,\n  MintCandyMachineV2BuilderParams,\n  updateCandyMachineV2Builder,\n  UpdateCandyMachineV2BuilderParams,\n} from './operations';\nimport type { Metaplex } from '@/Metaplex';\nimport { TransactionBuilderOptions } from '@/utils';\n\n/**\n * This client allows you to access the underlying Transaction Builders\n * for the write operations of the Candy Machine module.\n *\n * @see {@link CandyMachinesV2Client}\n * @group Module Builders\n */\nexport class CandyMachinesV2BuildersClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** {@inheritDoc createCandyMachineV2Builder} */\n  create(\n    input: CreateCandyMachineV2BuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createCandyMachineV2Builder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc deleteCandyMachineV2Builder} */\n  delete(\n    input: DeleteCandyMachineV2BuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return deleteCandyMachineV2Builder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc insertItemsToCandyMachineV2Builder} */\n  insertItems(\n    input: InsertItemsToCandyMachineV2BuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return insertItemsToCandyMachineV2Builder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc mintCandyMachineV2Builder} */\n  mint(\n    input: MintCandyMachineV2BuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return mintCandyMachineV2Builder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc updateCandyMachineV2Builder} */\n  update(\n    input: UpdateCandyMachineV2BuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return updateCandyMachineV2Builder(this.metaplex, input, options);\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport {\n  CandyMachineV2Account,\n  parseCandyMachineV2Account,\n  parseCandyMachineV2CollectionAccount,\n} from '../accounts';\nimport { CandyMachineV2GpaBuilder } from '../gpaBuilders';\nimport { CandyMachineV2, toCandyMachineV2 } from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { CandyMachineV2Program } from '../program';\nimport { zipMap } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Mint, toMint, toMintAccount } from '@/plugins/tokenModule';\nimport { Metaplex } from '@/Metaplex';\nimport { UnreachableCaseError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachinesV2ByPublicKeyOperation' as const;\n\n/**\n * Find all Candy Machines matching by a given `publicKey` or a given `type`.\n *\n * The following two types are supported.\n *\n * `authority`: Find Candy Machines whose authority is the given `publicKey`.\n * ```ts\n * const someAuthority = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'authority', someAuthority });\n * ```\n *\n * `wallet`: Find Candy Machines whose wallet address is the given `publicKey`.\n * ```ts\n * const someWallet = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'wallet', someWallet });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyMachinesV2ByPublicKeyFieldOperation =\n  useOperation<FindCandyMachinesV2ByPublicKeyFieldOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyMachinesV2ByPublicKeyFieldOperation = Operation<\n  typeof Key,\n  FindCandyMachinesV2ByPublicKeyFieldInput,\n  CandyMachineV2[]\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyMachinesV2ByPublicKeyFieldInput = {\n  /** Defines which type of account the `publicKey` field refers to.  */\n  type: 'authority' | 'wallet';\n\n  /** The publicKey to filter Candy Machine by. */\n  publicKey: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyMachinesV2ByPublicKeyFieldOperationHandler: OperationHandler<FindCandyMachinesV2ByPublicKeyFieldOperation> =\n  {\n    handle: async (\n      operation: FindCandyMachinesV2ByPublicKeyFieldOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CandyMachineV2[]> => {\n      const { commitment } = scope;\n      const { type, publicKey } = operation.input;\n      const accounts = CandyMachineV2Program.accounts(metaplex).mergeConfig({\n        commitment,\n      });\n\n      let candyMachineQuery: CandyMachineV2GpaBuilder;\n      switch (type) {\n        case 'authority':\n          candyMachineQuery =\n            accounts.candyMachineAccountsForAuthority(publicKey);\n          break;\n        case 'wallet':\n          candyMachineQuery = accounts.candyMachineAccountsForWallet(publicKey);\n          break;\n        default:\n          throw new UnreachableCaseError(type);\n      }\n\n      const unparsedAccounts = await candyMachineQuery.get();\n      scope.throwIfCanceled();\n\n      const collectionPdas = unparsedAccounts.map((unparsedAccount) =>\n        findCandyMachineV2CollectionPda(unparsedAccount.publicKey)\n      );\n\n      // Find mint details for all unique SPL tokens used\n      // in candy machines that have non-null `tokenMint`\n\n      const parsedAccounts: Record<string, CandyMachineV2Account> =\n        Object.fromEntries(\n          unparsedAccounts.map((unparsedAccount) => [\n            unparsedAccount.publicKey.toString(),\n            parseCandyMachineV2Account(unparsedAccount),\n          ])\n        );\n\n      const tokenMints = [\n        ...new Set(\n          Object.values(parsedAccounts)\n            .map((account) => account.data.tokenMint?.toString())\n            .filter((tokenMint): tokenMint is string => tokenMint !== undefined)\n        ),\n      ].map((address) => new PublicKey(address));\n\n      const result = await metaplex\n        .rpc()\n        .getMultipleAccounts(tokenMints.concat(collectionPdas), commitment);\n      scope.throwIfCanceled();\n\n      const unparsedMintAccounts = result.slice(0, tokenMints.length);\n      const unparsedCollectionAccounts = result.slice(-collectionPdas.length);\n\n      const mints: Record<string, Mint> = Object.fromEntries(\n        unparsedMintAccounts.map((account) => [\n          account.publicKey.toString(),\n          toMint(toMintAccount(account)),\n        ])\n      );\n\n      return zipMap(\n        unparsedAccounts,\n        unparsedCollectionAccounts,\n        (unparsedAccount, unparsedCollectionAccount) => {\n          const parsedAccount =\n            parsedAccounts[unparsedAccount.publicKey.toString()];\n          const collectionAccount = unparsedCollectionAccount\n            ? parseCandyMachineV2CollectionAccount(unparsedCollectionAccount)\n            : null;\n          const tokenMintAddress = parsedAccount.data.tokenMint?.toString();\n\n          return toCandyMachineV2(\n            parsedAccount,\n            unparsedAccount,\n            collectionAccount,\n            tokenMintAddress ? mints[tokenMintAddress] : null\n          );\n        }\n      );\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport {\n  parseCandyMachineV2CollectionAccount,\n  toCandyMachineV2Account,\n} from '../accounts';\nimport { CandyMachineV2, toCandyMachineV2 } from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport {\n  assertAccountExists,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachineV2ByAddressOperation' as const;\n\n/**\n * Find an existing Candy Machine by its address.\n *\n * ```ts\n * const candyMachine = await metaplex.candyMachinesV2().findbyAddress({ address });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyMachineV2ByAddressOperation =\n  useOperation<FindCandyMachineV2ByAddressOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyMachineV2ByAddressOperation = Operation<\n  typeof Key,\n  FindCandyMachineV2ByAddressInput,\n  CandyMachineV2\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyMachineV2ByAddressInput = {\n  /** The Candy Machine address. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyMachineV2ByAddressOperationHandler: OperationHandler<FindCandyMachineV2ByAddressOperation> =\n  {\n    handle: async (\n      operation: FindCandyMachineV2ByAddressOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const { commitment } = scope;\n      const { address } = operation.input;\n      const collectionPda = findCandyMachineV2CollectionPda(address);\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts([address, collectionPda], commitment);\n\n      const unparsedAccount = accounts[0];\n      assertAccountExists(unparsedAccount);\n      const account = toCandyMachineV2Account(unparsedAccount);\n      const collectionAccount = parseCandyMachineV2CollectionAccount(\n        accounts[1]\n      );\n\n      const mint = account.data.tokenMint\n        ? await metaplex\n            .tokens()\n            .findMintByAddress({ address: account.data.tokenMint }, scope)\n        : null;\n\n      return toCandyMachineV2(\n        account,\n        unparsedAccount,\n        collectionAccount,\n        mint\n      );\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { Metadata, Nft } from '../../nftModule';\nimport { findCandyMachineV2CreatorPda } from '../pdas';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindMintedNftsByCandyMachineV2Operation' as const;\n\n/**\n * Find all minted NFTs from a given Candy Machine address.\n *\n * ```ts\n * const nfts = await metaplex\n *   .candyMachinesV2()\n *   .findMintedNfts({ candyMachine };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findMintedNftsByCandyMachineV2Operation =\n  useOperation<FindMintedNftsByCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindMintedNftsByCandyMachineV2Operation = Operation<\n  typeof Key,\n  FindMintedNftsByCandyMachineV2Input,\n  FindMintedNftsByCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindMintedNftsByCandyMachineV2Input = {\n  /** The Candy Machine address. */\n  candyMachine: PublicKey;\n\n  /**\n   * The Candy Machine version\n   *\n   * @defaultValue `2`\n   */\n  version?: 1 | 2;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindMintedNftsByCandyMachineV2Output = (Metadata | Nft)[];\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findMintedNftsByCandyMachineV2OperationHandler: OperationHandler<FindMintedNftsByCandyMachineV2Operation> =\n  {\n    handle: async (\n      operation: FindMintedNftsByCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const { candyMachine, version = 2 } = operation.input;\n      const firstCreator =\n        version === 2\n          ? findCandyMachineV2CreatorPda(candyMachine)\n          : candyMachine;\n\n      const mintedNfts = await metaplex\n        .nfts()\n        .findAllByCreator({ creator: firstCreator, position: 1 }, scope);\n\n      return mintedNfts as (Nft | Metadata)[];\n    },\n  };\n","import type { PublicKey } from '@solana/web3.js';\nimport { CandyMachinesV2BuildersClient } from './CandyMachinesV2BuildersClient';\nimport { CandyMachineV2 } from './models';\nimport {\n  CreateCandyMachineV2Input,\n  createCandyMachineV2Operation,\n  DeleteCandyMachineV2Input,\n  deleteCandyMachineV2Operation,\n  FindCandyMachineV2ByAddressInput,\n  findCandyMachineV2ByAddressOperation,\n  FindCandyMachinesV2ByPublicKeyFieldInput,\n  findCandyMachinesV2ByPublicKeyFieldOperation,\n  FindMintedNftsByCandyMachineV2Input,\n  findMintedNftsByCandyMachineV2Operation,\n  InsertItemsToCandyMachineV2Input,\n  insertItemsToCandyMachineV2Operation,\n  MintCandyMachineV2Input,\n  mintCandyMachineV2Operation,\n  UpdateCandyMachineV2Input,\n  updateCandyMachineV2Operation,\n} from './operations';\nimport { OperationOptions, toPublicKey } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * This is a client for the Candy Machine module.\n *\n * It enables us to interact with the Candy Machine program in order to\n * create, update and delete Candy Machines as well as mint from them.\n *\n * You may access this client via the `candyMachinesV2()` method of your `Metaplex` instance.\n *\n * ```ts\n * const candyMachineV2Client = metaplex.candyMachinesV2();\n * ```\n *\n * @example\n * You can create a new Candy Machine with minimum input like so.\n * By default, the current identity of the Metaplex instance will be\n * the authority of the Candy Machine.\n *\n * ```ts\n * const { candyMachine } = await metaplex\n *   .candyMachinesV2()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   };\n * ```\n *\n * @see {@link CandyMachine} The `CandyMachine` model\n * @group Modules\n */\nexport class CandyMachinesV2Client {\n  constructor(readonly metaplex: Metaplex) {}\n\n  /**\n   * You may use the `builders()` client to access the\n   * underlying Transaction Builders of this module.\n   *\n   * ```ts\n   * const buildersClient = metaplex.candyMachinesV2().builders();\n   * ```\n   */\n  builders() {\n    return new CandyMachinesV2BuildersClient(this.metaplex);\n  }\n\n  /** {@inheritDoc createCandyMachineV2Operation} */\n  create(input: CreateCandyMachineV2Input, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(createCandyMachineV2Operation(input), options);\n  }\n\n  /** {@inheritDoc deleteCandyMachineV2Operation} */\n  delete(input: DeleteCandyMachineV2Input, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(deleteCandyMachineV2Operation(input), options);\n  }\n\n  /** {@inheritDoc findCandyMachinesV2ByPublicKeyFieldOperation} */\n  findAllBy(\n    input: FindCandyMachinesV2ByPublicKeyFieldInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findCandyMachinesV2ByPublicKeyFieldOperation(input), options);\n  }\n\n  /** {@inheritDoc findCandyMachineV2ByAddressOperation} */\n  findByAddress(\n    input: FindCandyMachineV2ByAddressInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findCandyMachineV2ByAddressOperation(input), options);\n  }\n\n  /** {@inheritDoc findMintedNftsByCandyMachineV2Operation} */\n  findMintedNfts(\n    input: FindMintedNftsByCandyMachineV2Input,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findMintedNftsByCandyMachineV2Operation(input), options);\n  }\n\n  /** {@inheritDoc insertItemsToCandyMachineV2Operation} */\n  insertItems(\n    input: InsertItemsToCandyMachineV2Input,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(insertItemsToCandyMachineV2Operation(input), options);\n  }\n\n  /** {@inheritDoc mintCandyMachineV2Operation} */\n  mint(input: MintCandyMachineV2Input, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(mintCandyMachineV2Operation(input), options);\n  }\n\n  /**\n   * Helper method that refetches a given Candy Machine.\n   *\n   * ```ts\n   * const candyMachine = await metaplex.candyMachinesV2().refresh(candyMachine);\n   * ```\n   */\n  refresh(\n    candyMachine: CandyMachineV2 | PublicKey,\n    options?: OperationOptions\n  ) {\n    return this.findByAddress({ address: toPublicKey(candyMachine) }, options);\n  }\n\n  /** {@inheritDoc updateCandyMachineV2Operation} */\n  update(input: UpdateCandyMachineV2Input, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(updateCandyMachineV2Operation(input), options);\n  }\n}\n","import { CandyMachinesV2Client } from './CandyMachinesV2Client';\nimport {\n  createCandyMachineV2Operation,\n  createCandyMachineV2OperationHandler,\n  deleteCandyMachineV2Operation,\n  deleteCandyMachineV2OperationHandler,\n  findCandyMachineV2ByAddressOperation,\n  findCandyMachineV2ByAddressOperationHandler,\n  findCandyMachinesV2ByPublicKeyFieldOperation,\n  findCandyMachinesV2ByPublicKeyFieldOperationHandler,\n  findMintedNftsByCandyMachineV2Operation,\n  findMintedNftsByCandyMachineV2OperationHandler,\n  insertItemsToCandyMachineV2Operation,\n  InsertItemsToCandyMachineV2OperationHandler,\n  mintCandyMachineV2Operation,\n  mintCandyMachineV2OperationHandler,\n  updateCandyMachineV2Operation,\n  updateCandyMachineV2OperationHandler,\n} from './operations';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const candyMachineV2Module = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const op = metaplex.operations();\n    op.register(\n      createCandyMachineV2Operation,\n      createCandyMachineV2OperationHandler\n    );\n    op.register(\n      deleteCandyMachineV2Operation,\n      deleteCandyMachineV2OperationHandler\n    );\n    op.register(\n      findCandyMachineV2ByAddressOperation,\n      findCandyMachineV2ByAddressOperationHandler\n    );\n    op.register(\n      findCandyMachinesV2ByPublicKeyFieldOperation,\n      findCandyMachinesV2ByPublicKeyFieldOperationHandler\n    );\n    op.register(\n      findMintedNftsByCandyMachineV2Operation,\n      findMintedNftsByCandyMachineV2OperationHandler\n    );\n    op.register(\n      insertItemsToCandyMachineV2Operation,\n      InsertItemsToCandyMachineV2OperationHandler\n    );\n    op.register(\n      mintCandyMachineV2Operation,\n      mintCandyMachineV2OperationHandler\n    );\n    op.register(\n      updateCandyMachineV2Operation,\n      updateCandyMachineV2OperationHandler\n    );\n\n    metaplex.candyMachinesV2 = function () {\n      return new CandyMachinesV2Client(this);\n    };\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    candyMachinesV2(): CandyMachinesV2Client;\n  }\n}\n","import { createSetAuthorityInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyGuardAuthorityOperation' as const;\n\n/**\n * Updates the authority of a Candy Guard account.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .updateCandyGuardAuthority({\n *     candyGuard: candyGuard.address,\n *     authority: candyGuardAuthority,\n *     newAuthority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateCandyGuardAuthorityOperation =\n  useOperation<UpdateCandyGuardAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateCandyGuardAuthorityOperation = Operation<\n  typeof Key,\n  UpdateCandyGuardAuthorityInput,\n  UpdateCandyGuardAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateCandyGuardAuthorityInput = {\n  /** The address of the Candy Guard to update. */\n  candyGuard: PublicKey;\n\n  /**\n   * The Signer authorized to update the candy Guard.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /** The address of the new authority. */\n  newAuthority: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateCandyGuardAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateCandyGuardAuthorityOperationHandler: OperationHandler<UpdateCandyGuardAuthorityOperation> =\n  {\n    async handle(\n      operation: UpdateCandyGuardAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UpdateCandyGuardAuthorityOutput> {\n      return updateCandyGuardAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateCandyGuardAuthorityBuilderParams = Omit<\n  UpdateCandyGuardAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that updates the candy guard. */\n  instructionKey?: string;\n};\n\n/**\n * Updates the authority of a Candy Guard account.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .builders()\n *   .updateCandyGuardAuthority({\n *     candyGuard: candyGuard.address,\n *     authority: candyGuardAuthority,\n *     newAuthority,\n *   };\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateCandyGuardAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: UpdateCandyGuardAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { candyGuard, newAuthority, authority = metaplex.identity() } = params;\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the candy guard account.\n      .add({\n        instruction: createSetAuthorityInstruction(\n          { candyGuard, authority: authority.publicKey },\n          { newAuthority },\n          candyGuardProgram.address\n        ),\n        signers: [authority, payer],\n        key: params.instructionKey ?? 'updateCandyGuardAuthority',\n      })\n  );\n};\n","import { MetaplexError } from '@/errors';\n\n/** @group Errors */\nexport class CandyMachineV3Error extends MetaplexError {\n  readonly name: string = 'CandyMachineV3Error';\n  constructor(message: string, cause?: Error) {\n    super(message, 'plugin', 'Candy Machine V3', cause);\n  }\n}\n\n/** @group Errors */\nexport class UnregisteredCandyGuardError extends CandyMachineV3Error {\n  readonly name: string = 'UnregisteredCandyGuardError';\n  constructor(name: string) {\n    const message =\n      `The SDK is trying to access a custom Candy Guard named [${name}] ` +\n      `but that guard was not registered in the SDK ` +\n      'Register your custom guard by calling the `metaplex.candyMachines().guards().register()` method.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineIsFullError extends CandyMachineV3Error {\n  readonly name: string = 'CandyMachineIsFullError';\n  constructor(index: number, itemsAvailable: number) {\n    const message =\n      `You are trying to add an item at index ${index} to a Candy Machine that ` +\n      `can only hold a maximum of ${itemsAvailable} items. ` +\n      'Limit number of items you are adding or create a Candy Machine that can hold more of them.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineCannotAddAmountError extends CandyMachineV3Error {\n  readonly name: string = 'CandyMachineCannotAddAmountError';\n  constructor(index: number, amount: number, itemsAvailable: number) {\n    const message =\n      `You are trying to add ${amount} items to candy machine starting at index ${index} ` +\n      ` but it can only hold a maximum of ${itemsAvailable} items. ` +\n      'Limit number of assets you are adding or create a Candy Machine that can hold more of them.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineItemTextTooLongError extends CandyMachineV3Error {\n  readonly name: string = 'CandyMachineItemTextTooLongError';\n  constructor(\n    index: number,\n    type: 'name' | 'uri',\n    text: string,\n    limit: number\n  ) {\n    const message =\n      `You are trying to add an item to a Candy Machine but its ${type} is too long. ` +\n      `The item settings define the ${type} limit as ${limit} characters but the following ` +\n      `content was provided [${text}] for the item at index ${index} ` +\n      `Reduce the size of the ${type} for the item at index ${index}.`;\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyMachineBotTaxError extends CandyMachineV3Error {\n  readonly name: string = 'CandyMachineBotTaxError';\n  constructor(explorerLink: string, cause: Error) {\n    const message =\n      `The NFT couldn't be fetched after being minted. ` +\n      `This is most likely due to a bot tax that occured during minting. ` +\n      `When someone tries to mint an NFT from a Candy Machine which cannot be minted from, ` +\n      `the program will succeed and charge a small tax to fight against bots. ` +\n      `Ensure you can mint from the Candy Machine. ` +\n      `You may want to check the transaction logs for more details: [${explorerLink}].`;\n    super(message, cause);\n  }\n}\n\n/** @group Errors */\nexport class GuardGroupRequiredError extends CandyMachineV3Error {\n  readonly name: string = 'GuardGroupRequiredError';\n  constructor(availableGroups: string[]) {\n    const message =\n      'The provided Candy Machine defines groups of guards but no' +\n      'group label was provided to identity which group we should select. ' +\n      'Please provide the label of the group you wish to select from via the `group` parameter. ' +\n      `The available groups are [${availableGroups.join(', ')}]`;\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class SelectedGuardGroupDoesNotExistError extends CandyMachineV3Error {\n  readonly name: string = 'SelectedGuardGroupDoesNotExistError';\n  constructor(selectedGroup: string, availableGroups: string[]) {\n    const message =\n      `You're trying to select the guard group [${selectedGroup}] from a ` +\n      'Candy Machine but this group does not exists on this Candy Machine. ' +\n      (availableGroups.length > 0\n        ? 'Please provide the label of a group that exists on the Candy Machine. ' +\n          `The available groups are [${availableGroups.join(', ')}]`\n        : 'There are no guard groups defined on the Candy Machine. ' +\n          'Please set the `group` parameter to `null` or remove it altogether.');\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class GuardMintSettingsMissingError extends CandyMachineV3Error {\n  readonly name: string = 'GuardMintSettingsMissingError';\n  constructor(guardName: string) {\n    const message =\n      `The Candy Machine you are trying to mint from has the [${guardName}] guard enabled. ` +\n      'This guard requires you to provide some additional settings when minting which you did not provide. ' +\n      `Please provide some minting settings for the [${guardName}] guard ` +\n      `via the \\`guards\\` parameter like so: \\`guards.${guardName} = {...}\\`.`;\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class GuardRouteNotSupportedError extends CandyMachineV3Error {\n  readonly name: string = 'GuardRouteNotSupportedError';\n  constructor(guardName: string) {\n    const message =\n      `You are trying to call the route instruction of the [${guardName}] guard ` +\n      'but this guard does not support this feature or did not register it on the SDK. ' +\n      'Please select a guard that support the route instruction feature. ' +\n      'If you are using a custom guard, make sure you registered the route instruction ' +\n      'feature by implementing the `routeSettingsParser` method on the guard manifest.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class CandyGuardRequiredOnCandyMachineError extends CandyMachineV3Error {\n  readonly name: string = 'CandyGuardRequiredOnCandyMachineError';\n  constructor() {\n    const message =\n      `The provided Candy Machine does not have a Candy Guard associated with ` +\n      `it yet, it is required for the operation you are trying to execute. ` +\n      'Please provide a Candy Machine with an associated Candy Guard account.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class GuardNotEnabledError extends CandyMachineV3Error {\n  readonly name: string = 'GuardNotEnabledError';\n  constructor(guard: string, group: string | null) {\n    const message =\n      (group\n        ? `The guard [${guard}] is not enabled on the group [${group}] of the Candy Machine.`\n        : `The guard [${guard}] is not enabled on the Candy Machine. `) +\n      'Please provide a different guard or select a different group ' +\n      'such that the provided guard is enabled on the selected group.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class GuardGroupLabelTooLongError extends CandyMachineV3Error {\n  readonly name: string = 'GuardGroupLabelTooLongError';\n  constructor(label: string, maxLength: number) {\n    const message =\n      `The provided group label [${label}] is too long. ` +\n      `Group labels cannot be longer than ${maxLength} characters. ` +\n      'Please provide a shorter group label.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class UnrecognizePathForRouteInstructionError extends CandyMachineV3Error {\n  readonly name: string = 'UnrecognizePathForRouteInstructionError';\n  constructor(guard: string, path: string) {\n    const message =\n      `The provided path [${path}] does not exist on the route instruction of the [${guard}] guard. ` +\n      'Please provide a recognized path.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class MintOwnerMustBeMintPayerError extends CandyMachineV3Error {\n  readonly name: string = 'MintOwnerMustBeMintPayerError';\n  constructor(guard: string) {\n    const message =\n      `The payer must be the owner when using the [${guard}] guard. ` +\n      'Please remove the `owner` attribute from the mint input so they can be the same.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class MaximumOfFiveAdditionalProgramsError extends CandyMachineV3Error {\n  readonly name: string = 'MaximumOfFiveAdditionalProgramsError';\n  constructor() {\n    const message =\n      `There is a maximum of five additional programs when using the [programGate] guard. ` +\n      'Please reduce the number of additional programs to <= 5.';\n    super(message);\n  }\n}\n","import { createRouteInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport * as beet from '@metaplex-foundation/beet';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from '../guards';\nimport { CandyMachine } from '../models';\nimport { CandyGuardRequiredOnCandyMachineError } from '../errors';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport { Operation, OperationHandler, OperationScope, Signer } from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CallCandyGuardRouteOperation' as const;\n\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const callCandyGuardRouteOperation = _callCandyGuardRouteOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _callCandyGuardRouteOperation<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n>(\n  input: CallCandyGuardRouteInput<Guard, Settings, RouteSettings>\n): CallCandyGuardRouteOperation<Guard, Settings, RouteSettings> {\n  return { key: Key, input };\n}\n_callCandyGuardRouteOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CallCandyGuardRouteOperation<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = Operation<\n  typeof Key,\n  CallCandyGuardRouteInput<Guard, Settings, RouteSettings>,\n  CallCandyGuardRouteOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CallCandyGuardRouteInput<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = {\n  /**\n   * The Candy Machine containing the guard we are interested in.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to execute the route instruction on the guard.\n   *\n   * This includes its address and the Candy Guard account associated with it.\n   */\n  candyMachine: Pick<CandyMachine<Settings>, 'address' | 'candyGuard'>;\n\n  /**\n   * The guard to select on the Candy Machine.\n   *\n   * If the Candy Machine uses groups of guards, the `group` property\n   * must also be provided so we known which specific guard to select.\n   */\n  guard: Guard;\n\n  /**\n   * The route settings of the selected guard.\n   *\n   * These will depend on the type of guard selected but they will\n   * usually include a `path` property to distinguish between the\n   * different paths available within their \"route\" instruction.\n   */\n  settings: RouteSettings[Guard];\n\n  /**\n   * The label of the group to mint from.\n   *\n   * If groups are configured on the Candy Machine,\n   * you must specify a group label to mint from.\n   *\n   * When set to `null` it will mint using the default\n   * guards, provided no groups are configured.\n   *\n   * @defaultValue `null`\n   */\n  group?: Option<string>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CallCandyGuardRouteOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const callCandyGuardRouteOperationHandler: OperationHandler<\n  CallCandyGuardRouteOperation<any>\n> = {\n  async handle<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    operation: CallCandyGuardRouteOperation<Guard, Settings, RouteSettings>,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<CallCandyGuardRouteOutput> {\n    const builder = callCandyGuardRouteBuilder<Guard, Settings, RouteSettings>(\n      metaplex,\n      operation.input,\n      scope\n    );\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CallCandyGuardRouteBuilderParams<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = Omit<\n  CallCandyGuardRouteInput<Guard, Settings, RouteSettings>,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that mints from the Candy Machine. */\n  instructionKey?: string;\n};\n\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const callCandyGuardRouteBuilder = <\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n>(\n  metaplex: Metaplex,\n  params: CallCandyGuardRouteBuilderParams<Guard, Settings, RouteSettings>,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { candyMachine, guard, settings, group = null } = params;\n\n  if (!candyMachine.candyGuard) {\n    throw new CandyGuardRequiredOnCandyMachineError();\n  }\n\n  // Route instruction.\n  const parsedRouteSettings = metaplex\n    .candyMachines()\n    .guards()\n    .parseRouteSettings(\n      candyMachine.address,\n      candyMachine.candyGuard,\n      payer,\n      guard,\n      settings,\n      group,\n      programs\n    );\n\n  const routeSigners: Signer[] = [payer, ...parsedRouteSettings.signers];\n  const routeInstruction = createRouteInstruction(\n    {\n      candyGuard: candyMachine.candyGuard.address,\n      candyMachine: candyMachine.address,\n      payer: payer.publicKey,\n    },\n    {\n      args: {\n        // \"GuardType\" is an enum for default guards only and will assert this\n        // whereas we want to allow custom guards, so we need to pass anything\n        // here to create the instruction and override this data afterwards.\n        guard: 0,\n        data: parsedRouteSettings.arguments,\n      },\n      label: group,\n    },\n    metaplex.programs().getCandyGuard(programs).address\n  );\n  routeInstruction.keys.push(...parsedRouteSettings.accountMetas);\n\n  // As promised, we override the guard index here.\n  const availableGuards = metaplex\n    .candyMachines()\n    .guards()\n    .forCandyGuardProgram(programs);\n  const guardIndex = availableGuards.findIndex((g) => g.name === guard);\n  beet.u8.write(routeInstruction.data, 8, guardIndex);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Route instruction.\n      .add({\n        instruction: routeInstruction,\n        signers: routeSigners,\n        key: params.instructionKey ?? 'callGuardRoute',\n      })\n  );\n};\n","export const MAX_NAME_LENGTH = 32;\nexport const MAX_SYMBOL_LENGTH = 10;\nexport const MAX_URI_LENGTH = 200;\nexport const MAX_CREATOR_LIMIT = 5;\nexport const MAX_CREATOR_LEN = 32 + 1 + 1;\nexport const CONFIG_LINE_SIZE = 4 + MAX_NAME_LENGTH + 4 + MAX_URI_LENGTH;\n\nexport const CANDY_MACHINE_HIDDEN_SECTION =\n  8 + // discriminator\n  8 + // features\n  32 + // authority\n  32 + // mint authority\n  32 + // collection mint\n  8 + // items redeemed\n  8 + // items available (config data)\n  4 +\n  MAX_SYMBOL_LENGTH + // u32 + max symbol length\n  2 + // seller fee basis points\n  8 + // max supply\n  1 + // is mutable\n  4 +\n  MAX_CREATOR_LIMIT * MAX_CREATOR_LEN + // u32 + creators vec\n  1 + // option (config lines settings)\n  4 +\n  MAX_NAME_LENGTH + // u32 + max name length\n  4 + // name length\n  4 +\n  MAX_URI_LENGTH + // u32 + max uri length\n  4 + // uri length\n  1 + // is sequential\n  1 + // option (hidden setting)\n  4 +\n  MAX_NAME_LENGTH + // u32 + max name length\n  4 +\n  MAX_URI_LENGTH + // u32 + max uri length\n  32; // hash\n\nexport const CANDY_GUARD_LABEL_SIZE = 6;\nexport const CANDY_GUARD_DATA =\n  8 + // discriminator\n  32 + // base\n  1 + // bump\n  32; // authority\n","import * as beet from '@metaplex-foundation/beet';\nimport { CandyMachineConfigLineSettings, CandyMachineItem } from '..';\nimport { deserializeFeatureFlags } from '@/types';\nimport { removeEmptyChars } from '@/utils';\n\n/** @internal */\nexport type CandyMachineHiddenSection = {\n  itemsLoaded: number;\n  items: CandyMachineItem[];\n  itemsLoadedMap: boolean[];\n  itemsLeftToMint: number[];\n};\n\n/** @internal */\nexport const deserializeCandyMachineHiddenSection = (\n  buffer: Buffer,\n  itemsAvailable: number,\n  itemsRemaining: number,\n  configLineSettings: CandyMachineConfigLineSettings,\n  offset = 0\n): CandyMachineHiddenSection => {\n  // Items loaded.\n  const itemsLoaded = beet.u32.read(buffer, offset);\n  offset += 4;\n\n  // Raw config lines.\n  const { nameLength } = configLineSettings;\n  const { uriLength } = configLineSettings;\n  const configLineSize = nameLength + uriLength;\n  const configLinesSize = configLineSize * itemsAvailable;\n  const rawConfigLines = buffer.slice(offset, offset + configLinesSize);\n  offset += configLinesSize;\n\n  // Items loaded map.\n  const itemsLoadedBuffer = buffer.slice(offset, offset + itemsAvailable);\n  const itemsLoadedMap = deserializeFeatureFlags(\n    itemsLoadedBuffer,\n    itemsAvailable\n  );\n  const itemsLoadedMapSize = Math.floor(itemsAvailable / 8) + 1;\n  offset += itemsLoadedMapSize;\n\n  // Items left to mint for random order only.\n  const itemsLeftToMint = beet\n    .uniformFixedSizeArray(beet.u32, itemsAvailable)\n    .read(buffer, offset)\n    .slice(0, itemsRemaining);\n\n  // Helper function to figure out if an item has been minted.\n  const itemsMinted = itemsAvailable - itemsRemaining;\n  const isMinted = (index: number): boolean =>\n    configLineSettings.isSequential\n      ? index < itemsMinted\n      : !itemsLeftToMint.includes(index);\n\n  // Parse config lines.\n  const items: CandyMachineItem[] = [];\n  itemsLoadedMap.forEach((loaded, index) => {\n    if (!loaded) return;\n\n    const namePosition = index * configLineSize;\n    const uriPosition = namePosition + nameLength;\n    const name = rawConfigLines\n      .slice(namePosition, namePosition + nameLength)\n      .toString('utf8');\n    const uri = rawConfigLines\n      .slice(uriPosition, uriPosition + uriLength)\n      .toString('utf8');\n\n    const prefixName = replaceCandyMachineItemPattern(\n      configLineSettings.prefixName,\n      index\n    );\n    const prefixUri = replaceCandyMachineItemPattern(\n      configLineSettings.prefixUri,\n      index\n    );\n\n    items.push({\n      index,\n      minted: isMinted(index),\n      name: prefixName + removeEmptyChars(name),\n      uri: prefixUri + removeEmptyChars(uri),\n    });\n  });\n\n  return {\n    itemsLoaded,\n    items,\n    itemsLoadedMap,\n    itemsLeftToMint,\n  };\n};\n\n/** @internal */\nexport const replaceCandyMachineItemPattern = (\n  value: string,\n  index: number\n): string => {\n  return value.replace('$ID+1$', `${index + 1}`).replace('$ID$', `${index}`);\n};\n","import { Buffer } from 'buffer';\nimport {\n  CandyMachine as MplCandyMachine,\n  candyMachineBeet,\n  CandyMachineData,\n} from '@metaplex-foundation/mpl-candy-machine-core';\nimport { CANDY_MACHINE_HIDDEN_SECTION } from '../constants';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { deserializeCandyMachineHiddenSection } from './CandyMachineHiddenSection';\nimport { CandyMachineItem } from './CandyMachineItem';\nimport { CandyGuard } from './CandyGuard';\nimport {\n  AccountInfo,\n  assertModel,\n  BigNumber,\n  createSerializerFromSolitaType,\n  Creator,\n  deserializeAccount,\n  deserializeFeatureFlags,\n  FeatureFlags,\n  isModel,\n  Model,\n  PublicKey,\n  toAccountInfo,\n  toBigNumber,\n  UnparsedAccount,\n} from '@/types';\nimport { assert, Option, removeEmptyChars } from '@/utils';\n\n/**\n * This model contains all the relevant information about a Candy Machine.\n * This includes its settings but also all of the items (a.k.a. config lines)\n * loaded inside the Candy Machine along with some statistics about the items.\n *\n * @group Models\n */\nexport type CandyMachine<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Model<'candyMachine'> & {\n  /** The address of the Candy Machine account. */\n  readonly address: PublicKey;\n\n  /** Blockchain data of the Candy Machine account. */\n  readonly accountInfo: AccountInfo;\n\n  /**\n   * Refers to the authority that is allowed to manage the Candy Machine.\n   * This includes updating its data, authorities, inserting items, etc.\n   */\n  readonly authorityAddress: PublicKey;\n\n  /**\n   * Refers to the only authority that is allowed to mint from\n   * this Candy Machine. This will refer to the address of the Candy\n   * Guard associated with the Candy Machine if any.\n   */\n  readonly mintAuthorityAddress: PublicKey;\n\n  /**\n   * The mint address of the collection NFT that should be associated with\n   * minted NFTs. When `null`, it means NFTs will not be part of a\n   * collection when minted.\n   */\n  readonly collectionMintAddress: PublicKey;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   */\n  readonly symbol: string;\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points\n   * (i.e. 250 is 2.5%).\n   */\n  readonly sellerFeeBasisPoints: number;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   */\n  readonly isMutable: boolean;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   */\n  readonly maxEditionSupply: BigNumber;\n\n  /**\n   * Array of creators that should be set on minted NFTs.\n   * creators can only verify NFTs after they have been minted.\n   * Thus, all the provided creators will have `verified` set to `false`.\n   *\n   * @see {@link Creator}\n   */\n  readonly creators: Omit<Creator, 'verified'>[];\n\n  /**\n   * The parsed items that are loaded in the Candy Machine.\n   *\n   * If the Candy Machine is using hidden settings,\n   * this will be an empty array.\n   */\n  readonly items: CandyMachineItem[];\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   */\n  readonly itemsAvailable: BigNumber;\n\n  /**\n   * The number of items that have been minted on this Candy Machine so far.\n   */\n  readonly itemsMinted: BigNumber;\n\n  /**\n   * The number of remaining items in the Candy Machine that can still be minted.\n   */\n  readonly itemsRemaining: BigNumber;\n\n  /**\n   * The number of items that have been inserted in the Candy Machine by\n   * its update authority. If this number if lower than the number of items\n   * available, the Candy Machine is not ready and cannot be minted from.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly itemsLoaded: number;\n\n  /**\n   * Whether all items in the Candy Machine have been inserted by\n   * its authority.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly isFullyLoaded: boolean;\n\n  /**\n   * Settings related to the Candy Machine's items.\n   *\n   * These can either be inserted manually within the Candy Machine or\n   * they can be infered from a set of hidden settings.\n   *\n   * - If `type` is `hidden`, the Candy Machine is using hidden settings.\n   * - If `type` is `configLines`, the Candy Machine is using config line settings.\n   *\n   * @see {@link CandyMachineHiddenSettings}\n   * @see {@link CandyMachineConfigLineSettings}\n   */\n  readonly itemSettings:\n    | CandyMachineHiddenSettings\n    | CandyMachineConfigLineSettings;\n\n  /**\n   * This array of booleans is used to keep track of which\n   * new features have been enabled on the Candy Machine.\n   */\n  readonly featureFlags: FeatureFlags;\n\n  /**\n   * The Candy Guard associted with the Candy Machine if any.\n   */\n  readonly candyGuard: Option<CandyGuard<T>>;\n};\n\n/**\n * Settings that makes items in the Candy Machine hidden by\n * providing a single URI for all minted NFTs and the hash of a file that\n * maps mint number to actual NFT URIs.\n *\n * Hidden settings serve two purposes.\n * - First, it allows the creation of larger drops (20k+), since\n *   the JSON metadata URIs are not stored on-chain for each item.\n * - In turn, this also allows the creation of hide-and-reveal drops,\n *   where users discover which items they minted after the mint is complete.\n *\n * Once hidden settings are enabled, every minted NFT will have the same URI and the\n * name will be created by appending the mint number (e.g., “#45”) to the specified\n * name. The hash is expected to be a 32 character string corresponding to\n * the hash of a cache file that has the mapping between a mint number and the\n * actual metadata URI. This allows the order of the mint to be verified by\n * others after the mint is complete.\n *\n * Since the metadata URIs are not on-chain, it is possible to create very large\n * drops. The only caveat is that there is a need for an off-chain process to\n * update the metadata for each item. This is important otherwise all items\n * will have the same metadata.\n *\n * @group Models\n */\nexport type CandyMachineHiddenSettings = {\n  /** Identifier used to distinguish the various types of item settings. */\n  readonly type: 'hidden';\n\n  /**\n   * The base name for all minted NFTs.\n   *\n   * You can use the following variables in the name:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly name: string;\n\n  /**\n   * The URI shared by all minted NFTs.\n   *\n   * You can use the following variables in the URI:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly uri: string;\n\n  /**\n   * A 32-character hash. In most cases this is the hash of the\n   * cache file with the mapping between mint numbers and metadata URIs\n   * so that the order can be verified when the mint is complete.\n   */\n  readonly hash: number[];\n};\n\n/**\n * A set of settings that aim to reduce the size of the Candy Machine\n * whilst allowing items to be manually inserted for more flexibility.\n *\n * This introduces `name` and `uri` prefixes that will be used for each\n * item inserted.\n *\n * @example\n * For instance, say all inserted items will have the following structure,\n * where zeros represent the dynamic part of the name and URI:\n * - name: \"My NFT Project #0000\"\n * - uri: \"https://arweave.net/00000000000000000000\"\n *\n * Then we can use the following prefixes:\n * - prefixName: \"My NFT Project #\"\n * - prefixUri: \"https://arweave.net/\"\n *\n * And the following lengths:\n * - nameLength: 4 (assuming we'll never have more than 9999 items)\n * - uriLength: 20\n *\n * We could even go one step further and set the `nameLength` to zero by\n * relying on template variables in the name prefix:\n * - prefixName: \"My NFT Project #$ID+1$\"\n * - nameLength: 0\n *\n * Now, the program will automatically append the item number to the\n * name of each minted NFT.\n *\n * @group Models\n */\nexport type CandyMachineConfigLineSettings = {\n  /** Identifier used to distinguish the various types of item settings. */\n  readonly type: 'configLines';\n\n  /**\n   * The prefix of the name of each item.\n   *\n   * The following template variables can be used:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly prefixName: string;\n\n  /**\n   * The maximum length to use for the name of inserted items\n   * excluding the length of the prefix.\n   *\n   * For instance, if the name prefix is \"My NFT Project #\" and we want to\n   * add item numbers up to 9999, we would set this value to 4.\n   */\n  readonly nameLength: number;\n\n  /**\n   * The prefix of the URI of each item.\n   *\n   * The following template variables can be used:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly prefixUri: string;\n\n  /**\n   * The maximum length to use for the URI of inserted items\n   * excluding the length of the prefix.\n   *\n   * For instance, if the URI prefix is \"https://arweave.net/\" and we assume\n   * Arweave identifiers are 20 characters long max, we would set this value to 20.\n   */\n  readonly uriLength: number;\n\n  /**\n   * Indicates whether to use a sequential index generator or not.\n   * When set to `true`, NFTs will be minted sequentially.\n   * When set to `false`, NFTs will be minted in a random order.\n   */\n  readonly isSequential: boolean;\n};\n\n/** @group Model Helpers */\nexport const isCandyMachine = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  value: any\n): value is CandyMachine<T> => isModel('candyMachine', value);\n\n/** @group Model Helpers */\nexport function assertCandyMachine<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(value: any): asserts value is CandyMachine<T> {\n  assertModel(isCandyMachine(value), `Expected CandyMachine model`);\n}\n\n/** @group Model Helpers */\nexport const toCandyMachine = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  account: UnparsedAccount,\n  candyGuard: Option<CandyGuard<T>> = null\n): CandyMachine<T> => {\n  const serializer = createSerializerFromSolitaType(\n    MplCandyMachine,\n    candyMachineBeet.description\n  );\n  const parsedAccount = deserializeAccount(account, serializer);\n\n  const itemsAvailable = toBigNumber(parsedAccount.data.data.itemsAvailable);\n  const itemsMinted = toBigNumber(parsedAccount.data.itemsRedeemed);\n  const itemsRemaining = toBigNumber(itemsAvailable.sub(itemsMinted));\n\n  let items: CandyMachineItem[] = [];\n  let itemsLoaded = 0;\n  let isFullyLoaded = true;\n\n  const { hiddenSettings } = parsedAccount.data.data;\n  const { configLineSettings } = parsedAccount.data.data;\n  let itemSettings: CandyMachineHiddenSettings | CandyMachineConfigLineSettings;\n  if (hiddenSettings) {\n    itemSettings = { ...hiddenSettings, type: 'hidden' };\n  } else {\n    assert(\n      !!configLineSettings,\n      'Expected either hidden or config line settings'\n    );\n    itemSettings = { ...configLineSettings, type: 'configLines' };\n    const hiddenSection = deserializeCandyMachineHiddenSection(\n      account.data,\n      itemsAvailable.toNumber(),\n      itemsRemaining.toNumber(),\n      itemSettings,\n      CANDY_MACHINE_HIDDEN_SECTION\n    );\n\n    items = hiddenSection.items;\n    itemsLoaded = hiddenSection.itemsLoaded;\n    isFullyLoaded = hiddenSection.itemsLoaded >= itemsAvailable.toNumber();\n  }\n\n  return {\n    model: 'candyMachine',\n    address: account.publicKey,\n    accountInfo: toAccountInfo(account),\n    authorityAddress: parsedAccount.data.authority,\n    mintAuthorityAddress: parsedAccount.data.mintAuthority,\n    collectionMintAddress: parsedAccount.data.collectionMint,\n    symbol: removeEmptyChars(parsedAccount.data.data.symbol),\n    sellerFeeBasisPoints: parsedAccount.data.data.sellerFeeBasisPoints,\n    isMutable: parsedAccount.data.data.isMutable,\n    maxEditionSupply: toBigNumber(parsedAccount.data.data.maxSupply),\n    creators: parsedAccount.data.data.creators.map(\n      (creator): Creator => ({ ...creator, share: creator.percentageShare })\n    ),\n    items,\n    itemsAvailable,\n    itemsMinted,\n    itemsRemaining,\n    itemsLoaded,\n    isFullyLoaded,\n    itemSettings,\n    featureFlags: deserializeFeatureFlags(\n      toBigNumber(parsedAccount.data.features)\n        .toArrayLike(Buffer, 'le', 8)\n        .reverse(),\n      64\n    ),\n    candyGuard,\n  };\n};\n\nexport const toCandyMachineData = (\n  candyMachine: Pick<\n    CandyMachine,\n    | 'itemsAvailable'\n    | 'symbol'\n    | 'sellerFeeBasisPoints'\n    | 'maxEditionSupply'\n    | 'isMutable'\n    | 'creators'\n    | 'itemSettings'\n  >\n): CandyMachineData => {\n  return {\n    itemsAvailable: candyMachine.itemsAvailable,\n    symbol: candyMachine.symbol,\n    sellerFeeBasisPoints: candyMachine.sellerFeeBasisPoints,\n    maxSupply: candyMachine.maxEditionSupply,\n    isMutable: candyMachine.isMutable,\n    creators: candyMachine.creators.map((creator) => ({\n      ...creator,\n      verified: false,\n      percentageShare: creator.share,\n    })),\n    configLineSettings:\n      candyMachine.itemSettings.type === 'configLines'\n        ? candyMachine.itemSettings\n        : null,\n    hiddenSettings:\n      candyMachine.itemSettings.type === 'hidden'\n        ? candyMachine.itemSettings\n        : null,\n  };\n};\n\nexport const getCandyMachineSize = (data: CandyMachineData): number => {\n  if (data.hiddenSettings) {\n    return CANDY_MACHINE_HIDDEN_SECTION;\n  }\n\n  // This should not happen as the candy machine input type\n  // ensures exactly on of them is provided.\n  assert(\n    !!data.configLineSettings,\n    'No config line settings nor hidden settings were provided. ' +\n      'Please provide one of them.'\n  );\n\n  const itemsAvailable = toBigNumber(data.itemsAvailable).toNumber();\n  const configLineSize =\n    data.configLineSettings.nameLength + data.configLineSettings.uriLength;\n\n  return Math.ceil(\n    CANDY_MACHINE_HIDDEN_SECTION +\n      // Number of currently items inserted.\n      4 +\n      // Config line data.\n      itemsAvailable * configLineSize +\n      // Bit mask to keep track of which ConfigLines have been added.\n      (4 + Math.floor(itemsAvailable / 8) + 1) +\n      // Mint indices.\n      (4 + itemsAvailable * 4)\n  );\n};\n","import { createInitializeInstruction } from '@metaplex-foundation/mpl-candy-machine-core';\nimport { Keypair } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport {\n  CandyMachine,\n  CandyMachineConfigLineSettings,\n  CandyMachineHiddenSettings,\n  toCandyMachineData,\n  getCandyMachineSize,\n} from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  Creator,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  toBigNumber,\n  toPublicKey,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { ExpectedSignerError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCandyMachineOperation' as const;\n\n/**\n * Creates a brand new Candy Machine with the provided settings.\n *\n * Unless the `withoutCandyGuard` option is set to `true`, a\n * Candy Guard will be created with the given guards and\n * immediately linked to the Candy Machine.\n *\n * ```ts\n *  const { candyMachine } = await metaplex\n *    .candyMachines()\n *    .create({\n *      itemsAvailable: toBigNumber(5000),\n *      sellerFeeBasisPoints: 333, // 3.33%\n *      collection: {\n *        address: collectionNft.address,\n *        updateAuthority: collectionUpdateAuthority,\n *      },\n *    });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCandyMachineOperation = _createCandyMachineOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _createCandyMachineOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(input: CreateCandyMachineInput<T>): CreateCandyMachineOperation<T> {\n  return { key: Key, input };\n}\n_createCandyMachineOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCandyMachineOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<\n  typeof Key,\n  CreateCandyMachineInput<T>,\n  CreateCandyMachineOutput<T>\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCandyMachineInput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /**\n   * The Candy Machine to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  candyMachine?: Signer;\n\n  /**\n   * Refers to the authority that is allowed to manage the Candy Machine.\n   * This includes updating its data, authorities, inserting items, etc.\n   *\n   * By default, it is required as a Signer in order to create and wrap its\n   * Candy Guard. However, when `withoutCandyGuard` is set to `true`, it\n   * may be provided as a PublicKey instead.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: PublicKey | Signer;\n\n  /**\n   * The Collection NFT that all NFTs minted from this Candy Machine should be part of.\n   * This must include its address and the update authority as a Signer.\n   *\n   * @example\n   * If you do not have a Collection NFT yet, you can create one using\n   * the `create` method of the NFT module and setting `isCollection` to `true`.\n   *\n   * ```ts\n   * const { nft } = await metaplex.\n   *   .nfts()\n   *   .create({ isCollection: true, name: 'My Collection', ... });\n   * ```\n   *\n   * You can now use `nft.address` as the address of the collection and\n   * provide the update authority as a signer, which by default, should\n   * be `metaplex.identity()`.\n   */\n  collection: {\n    address: PublicKey;\n    updateAuthority: Signer;\n  };\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points.\n   *\n   * @example\n   * ```ts\n   * { sellerFeeBasisPoints: 250 } // For 2.5% royalties.\n   * ```\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   *\n   * @example\n   * ```ts\n   * { itemsAvailable: toBigNumber(1000) } // For 1000 items.\n   * ```\n   */\n  itemsAvailable: BigNumber;\n\n  /**\n   * Settings related to the Candy Machine's items.\n   *\n   * These can either be inserted manually within the Candy Machine or\n   * they can be infered from a set of hidden settings.\n   *\n   * - If `type` is `hidden`, the Candy Machine is using hidden settings.\n   * - If `type` is `configLines`, the Candy Machine is using config line settings.\n   *\n   * @defaultValue\n   * Defaults to using `configLines` settings with:\n   * - No prefixes.\n   * - A length of 32 for the name.\n   * - A length of 200 for the URI.\n   * - Random mint ordering.\n   *\n   * ```ts\n   * {\n   *   itemSettings: {\n   *     type: 'configLines',\n   *     prefixName: '',\n   *     nameLength: 32,\n   *     prefixUri: '',\n   *     uriLength: 200,\n   *     isSequential: false,\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link CandyMachineHiddenSettings}\n   * @see {@link CandyMachineConfigLineSettings}\n   */\n  itemSettings?: CandyMachineHiddenSettings | CandyMachineConfigLineSettings;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxEditionSupply?: BigNumber;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * Array of creators that should be set on minted NFTs.\n   *\n   * @see {@link Creator}\n   *\n   * @defaultValue\n   * Defaults to using the `authority` parameter as the only creator.\n   *\n   * ```ts\n   * [{ address: authority, share: 100 }]\n   * ```\n   */\n  creators?: Omit<Creator, 'verified'>[];\n\n  /**\n   * The settings of all guards we wish to activate.\n   *\n   * Any guard not provided or set to `null` will be disabled.\n   *\n   * This parameter is ignored if `withoutCandyGuard` is set to `true`.\n   *\n   * @defaultValue `{}`, i.e. no guards are activated.\n   */\n  guards?: Partial<T>;\n\n  /**\n   * This parameter allows us to create multiple minting groups that have their\n   * own set of requirements — i.e. guards.\n   *\n   * When groups are provided, the `guards` parameter becomes a set of default\n   * guards that will be applied to all groups. If a specific group enables\n   * a guard that is also present in the default guards, the group's guard\n   * will override the default guard.\n   *\n   * For each group, any guard not provided or set to `null` will be disabled.\n   *\n   * This parameter is ignored if `withoutCandyGuard` is set to `true`.\n   *\n   * @defaultValue `[]`, i.e. no groups are created.\n   */\n  groups?: { label: string; guards: Partial<T> }[];\n\n  /**\n   * Whether to skip the part of this operation that creates a Candy Guard\n   * for the new Candy Machine. When set to `true`, no Candy Guard will be\n   * created for the Candy Machine.\n   *\n   * @defaultValue `false`\n   */\n  withoutCandyGuard?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCandyMachineOutput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The Candy Machine that was created. */\n  candyMachine: CandyMachine<T>;\n\n  /** The created Candy Machine has a Signer. */\n  candyMachineSigner: Signer;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCandyMachineOperationHandler: OperationHandler<CreateCandyMachineOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: CreateCandyMachineOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) {\n      const builder = await createCandyMachineBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const candyMachine = await metaplex\n        .candyMachines()\n        .findByAddress<T>(\n          { address: output.candyMachineSigner.publicKey },\n          scope\n        );\n      scope.throwIfCanceled();\n\n      return { ...output, candyMachine };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCandyMachineBuilderParams<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Omit<CreateCandyMachineInput<T>, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that creates the Candy Machine account. */\n  createCandyMachineAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the Candy Machine account. */\n  initializeCandyMachineInstructionKey?: string;\n\n  /** A key to distinguish the instruction that wraps the Candy Machine in a Candy Guard. */\n  wrapCandyGuardInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCandyMachineBuilderContext = Omit<\n  CreateCandyMachineOutput,\n  'response' | 'candyMachine'\n>;\n\n/**\n\n * Creates a brand new Candy Machine with the provided settings.\n *\n * Unless the `withoutCandyGuard` option is set to `true`, a\n * Candy Guard will be created with the given guards and\n * immediately linked to the Candy Machine.\n *\n * ```ts\n *  const transactionBuilder = await metaplex\n *    .candyMachines()\n *    .builders()\n *    .create({\n *      itemsAvailable: toBigNumber(5000),\n *      sellerFeeBasisPoints: 333, // 3.33%\n *      collection: {\n *        address: collectionNft.address,\n *        updateAuthority: collectionUpdateAuthority,\n *      },\n *    });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCandyMachineBuilder = async <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: CreateCandyMachineBuilderParams<T>,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateCandyMachineBuilderContext>> => {\n  // Input.\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine = Keypair.generate(),\n    authority = metaplex.identity(),\n    collection,\n    sellerFeeBasisPoints,\n    itemsAvailable,\n    symbol = '',\n    maxEditionSupply = toBigNumber(0),\n    isMutable = true,\n    withoutCandyGuard = false,\n  } = params;\n  const creators = params.creators ?? [\n    { address: toPublicKey(authority), share: 100 },\n  ];\n  const itemSettings = params.itemSettings ?? {\n    type: 'configLines',\n    prefixName: '',\n    nameLength: 32,\n    prefixUri: '',\n    uriLength: 200,\n    isSequential: false,\n  };\n\n  // PDAs.\n  const authorityPda = metaplex.candyMachines().pdas().authority({\n    candyMachine: candyMachine.publicKey,\n    programs,\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: collection.address,\n    programs,\n  });\n  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: collection.address,\n    programs,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: collection.address,\n      collectionAuthority: authorityPda,\n      programs,\n    });\n\n  // Programs.\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const candyMachineData = toCandyMachineData({\n    itemsAvailable,\n    symbol,\n    sellerFeeBasisPoints,\n    maxEditionSupply,\n    isMutable,\n    creators,\n    itemSettings,\n  });\n\n  const builder = TransactionBuilder.make<CreateCandyMachineBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ candyMachineSigner: candyMachine });\n\n  let mintAuthority = toPublicKey(authority);\n  if (!withoutCandyGuard) {\n    const createCandyGuard = metaplex\n      .candyMachines()\n      .builders()\n      .createCandyGuard<T>(\n        {\n          base: candyMachine,\n          authority: toPublicKey(authority),\n          guards: params.guards ?? {},\n          groups: params.groups,\n        },\n        { programs, payer }\n      );\n\n    const { candyGuardAddress } = createCandyGuard.getContext();\n    mintAuthority = candyGuardAddress;\n    builder.add(createCandyGuard);\n  }\n\n  return builder\n    .add(\n      await metaplex\n        .system()\n        .builders()\n        .createAccount(\n          {\n            space: getCandyMachineSize(candyMachineData),\n            newAccount: candyMachine,\n            program: candyMachineProgram.address,\n          },\n          { payer, programs }\n        )\n    )\n\n    .add({\n      instruction: createInitializeInstruction(\n        {\n          candyMachine: candyMachine.publicKey,\n          authorityPda,\n          authority: toPublicKey(authority),\n          payer: payer.publicKey,\n          collectionMetadata,\n          collectionMint: collection.address,\n          collectionMasterEdition,\n          collectionUpdateAuthority: collection.updateAuthority.publicKey,\n          collectionAuthorityRecord,\n          tokenMetadataProgram: tokenMetadataProgram.address,\n        },\n        { data: candyMachineData },\n        candyMachineProgram.address\n      ),\n      signers: [payer, candyMachine, collection.updateAuthority],\n      key:\n        params.initializeCandyMachineInstructionKey ?? 'initializeCandyMachine',\n    })\n\n    .when(!withoutCandyGuard, (builder) => {\n      if (!isSigner(authority)) {\n        throw new ExpectedSignerError(\n          'authority',\n          'PublicKey',\n          'In order to create a Candy Machine with an associated ' +\n            'Candy Guard you must provide the authority as a Signer.'\n        );\n      }\n\n      return builder.add(\n        metaplex.candyMachines().builders().wrapCandyGuard(\n          {\n            candyMachine: candyMachine.publicKey,\n            candyMachineAuthority: authority,\n            candyGuard: mintAuthority,\n            candyGuardAuthority: authority,\n            wrapCandyGuardInstructionKey: params.wrapCandyGuardInstructionKey,\n          },\n          { payer, programs }\n        )\n      );\n    });\n};\n","import { createInitializeInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { CandyGuard } from '../models/CandyGuard';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Pda,\n  Signer,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCandyGuardOperation' as const;\n\n/**\n * Creates a new Candy Guard account with the provided settings.\n *\n * ```ts\n * const { candyGuard } = await metaplex\n *   .candyMachines()\n *   .createCandyGuard({\n *     guards: {\n *       startDate: { date: toDateTime('2022-09-05T20:00:00.000Z') },\n *       solPayment: { amount: sol(1.5), },\n *       botTax: { lamports: sol(0.01), lastInstruction: true },\n *     },\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCandyGuardOperation = _createCandyGuardOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _createCandyGuardOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(input: CreateCandyGuardInput<T>): CreateCandyGuardOperation<T> {\n  return { key: Key, input };\n}\n_createCandyGuardOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCandyGuardOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, CreateCandyGuardInput<T>, CreateCandyGuardOutput<T>>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCandyGuardInput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /**\n   * The \"base\" address of the Candy Guard to create as a Signer.\n   *\n   * This address will be deterministically derived to obtain the real\n   * address of the Candy Guard account. It expects a brand new Keypair\n   * such that its derived address has no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  base?: Signer;\n\n  /**\n   * The authority that will be allowed to update the Candy Guard.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  authority?: PublicKey;\n\n  /**\n   * The settings of all guards we wish to activate.\n   *\n   * Any guard not provided or set to `null` will be disabled.\n   */\n  guards: Partial<T>;\n\n  /**\n   * This parameter allows us to create multiple minting groups that have their\n   * own set of requirements — i.e. guards.\n   *\n   * When groups are provided, the `guards` parameter becomes a set of default\n   * guards that will be applied to all groups. If a specific group enables\n   * a guard that is also present in the default guards, the group's guard\n   * will override the default guard.\n   *\n   * For each group, any guard not provided or set to `null` will be disabled.\n   *\n   * @defaultValue `[]`\n   */\n  groups?: { label: string; guards: Partial<T> }[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCandyGuardOutput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The created Candy Guard. */\n  candyGuard: CandyGuard<T>;\n\n  /** The base address of the Candy Guard's account as a Signer. */\n  base: Signer;\n\n  /** The address of the created Candy Guard. */\n  candyGuardAddress: Pda;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCandyGuardOperationHandler: OperationHandler<CreateCandyGuardOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: CreateCandyGuardOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateCandyGuardOutput<T>> {\n      const builder = createCandyGuardBuilder<T>(\n        metaplex,\n        operation.input,\n        scope\n      );\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const candyGuard = await metaplex\n        .candyMachines()\n        .findCandyGuardByBaseAddress<T>(\n          { address: output.base.publicKey },\n          scope\n        );\n\n      return { ...output, candyGuard };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCandyGuardBuilderParams<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Omit<CreateCandyGuardInput<T>, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that creates and initializes the Candy Guard account. */\n  createCandyGuardInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCandyGuardBuilderContext = Omit<\n  CreateCandyGuardOutput,\n  'response' | 'candyGuard'\n>;\n\n/**\n * Creates a new Candy Guard account with the provided settings.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .createCandyGuard({\n *     guards: {\n *       startDate: { date: toDateTime('2022-09-05T20:00:00.000Z') },\n *       solPayment: { amount: sol(1.5), },\n *       botTax: { lamports: sol(0.01), lastInstruction: true },\n *     },\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCandyGuardBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: CreateCandyGuardBuilderParams<T>,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder<CreateCandyGuardBuilderContext> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const base = params.base ?? Keypair.generate();\n  const authority = params.authority ?? metaplex.identity().publicKey;\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n  const candyGuard = metaplex.candyMachines().pdas().candyGuard({\n    base: base.publicKey,\n    programs,\n  });\n\n  const serializedSettings = metaplex\n    .candyMachines()\n    .guards()\n    .serializeSettings<T>(params.guards, params.groups ?? [], programs);\n\n  return (\n    TransactionBuilder.make<CreateCandyGuardBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({ base, candyGuardAddress: candyGuard })\n\n      // Create and initialize the candy guard account.\n      .add({\n        instruction: createInitializeInstruction(\n          {\n            candyGuard,\n            base: base.publicKey,\n            authority,\n            payer: payer.publicKey,\n          },\n          { data: serializedSettings },\n          candyGuardProgram.address\n        ),\n        signers: [base, payer],\n        key: params.createCandyGuardInstructionKey ?? 'createCandyGuard',\n      })\n  );\n};\n","import { createWithdrawInstruction } from '@metaplex-foundation/mpl-candy-machine-core';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'DeleteCandyMachineOperation' as const;\n\n/**\n * Deletes a Candy Machine account by withdrawing its rent-exempt balance.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .delete({\n *     candyMachine: candyMachine.address,\n *     candyGuard: candyMachine.candyGuard.address,\n *     authority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const deleteCandyMachineOperation =\n  useOperation<DeleteCandyMachineOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type DeleteCandyMachineOperation = Operation<\n  typeof Key,\n  DeleteCandyMachineInput,\n  DeleteCandyMachineOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type DeleteCandyMachineInput = {\n  /** The address of the Candy Machine account to delete. */\n  candyMachine: PublicKey;\n\n  /**\n   * The address of the Candy Guard associated with the Candy Machine account.\n   * When provided the Candy Guard will be deleted as well.\n   *\n   * @defaultValue Defaults to not being deleted.\n   */\n  candyGuard?: PublicKey;\n\n  /**\n   * The authority of the Candy Machine account.\n   *\n   * This is the account that will received the rent-exemption\n   * lamports from the Candy Machine account.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The authority of the Candy Guard account to delete.\n   *\n   * This is only required if `candyGuard` is provided and the Candy\n   * Guard authority is not the same as the Candy Machine authority.\n   *\n   * @defaultValue `authority`\n   */\n  candyGuardAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type DeleteCandyMachineOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const deleteCandyMachineOperationHandler: OperationHandler<DeleteCandyMachineOperation> =\n  {\n    async handle(\n      operation: DeleteCandyMachineOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<DeleteCandyMachineOutput> {\n      return deleteCandyMachineBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type DeleteCandyMachineBuilderParams = Omit<\n  DeleteCandyMachineInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that deletes the Candy Machine account. */\n  deleteCandyMachineInstructionKey?: string;\n};\n\n/**\n * Deletes a Candy Machine account by withdrawing its rent-exempt balance.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .delete({\n *     candyMachine: candyMachine.address,\n *     candyGuard: candyMachine.candyGuard.address,\n *     authority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const deleteCandyMachineBuilder = (\n  metaplex: Metaplex,\n  params: DeleteCandyMachineBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    candyGuard,\n    authority = metaplex.identity(),\n    candyGuardAuthority = authority,\n  } = params;\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  const builder = TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createWithdrawInstruction(\n        {\n          candyMachine,\n          authority: authority.publicKey,\n        },\n        candyMachineProgram.address\n      ),\n      signers: [authority],\n      key: params.deleteCandyMachineInstructionKey ?? 'deleteCandyMachine',\n    });\n\n  if (candyGuard) {\n    builder.add(\n      metaplex\n        .candyMachines()\n        .builders()\n        .deleteCandyGuard(\n          { candyGuard, authority: candyGuardAuthority },\n          { payer, programs }\n        )\n    );\n  }\n\n  return builder;\n};\n","import { createWithdrawInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'DeleteCandyGuardOperation' as const;\n\n/**\n * Deletes a Candy Guard account by withdrawing its rent-exempt balance.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .deleteCandyGuard({\n *     candyGuard,\n *     authority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const deleteCandyGuardOperation =\n  useOperation<DeleteCandyGuardOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type DeleteCandyGuardOperation = Operation<\n  typeof Key,\n  DeleteCandyGuardInput,\n  DeleteCandyGuardOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type DeleteCandyGuardInput = {\n  /** The address of the Candy Guard account to delete. */\n  candyGuard: PublicKey;\n\n  /**\n   * The authority of the Candy Guard account.\n   *\n   * This is the account that will received the rent-exemption\n   * lamports from the Candy Guard account.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type DeleteCandyGuardOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const deleteCandyGuardOperationHandler: OperationHandler<DeleteCandyGuardOperation> =\n  {\n    async handle(\n      operation: DeleteCandyGuardOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<DeleteCandyGuardOutput> {\n      return deleteCandyGuardBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type DeleteCandyGuardBuilderParams = Omit<\n  DeleteCandyGuardInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that deletes the Candy Guard account. */\n  deleteCandyGuardInstructionKey?: string;\n};\n\n/**\n * Deletes a Candy Guard account by withdrawing its rent-exempt balance.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .deleteCandyGuard({\n *     candyGuard,\n *     authority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const deleteCandyGuardBuilder = (\n  metaplex: Metaplex,\n  params: DeleteCandyGuardBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { candyGuard, authority = metaplex.identity() } = params;\n\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createWithdrawInstruction(\n        {\n          candyGuard,\n          authority: authority.publicKey,\n        },\n        candyGuardProgram.address\n      ),\n      signers: [authority],\n      key: params.deleteCandyGuardInstructionKey ?? 'deleteCandyGuard',\n    });\n};\n","import { CandyMachine, CandyMachineItem } from './models';\nimport {\n  CandyMachineItemTextTooLongError,\n  CandyMachineCannotAddAmountError,\n  CandyMachineIsFullError,\n} from './errors';\n\nexport const assertNotFull = (\n  candyMachine: Pick<CandyMachine, 'itemsAvailable' | 'itemsLoaded'>,\n  index: number\n) => {\n  if (candyMachine.itemsAvailable.lten(candyMachine.itemsLoaded)) {\n    throw new CandyMachineIsFullError(\n      index,\n      candyMachine.itemsAvailable.toNumber()\n    );\n  }\n};\n\nexport const assertCanAdd = (\n  candyMachine: Pick<CandyMachine, 'itemsAvailable'>,\n  index: number,\n  amount: number\n) => {\n  if (index + amount > candyMachine.itemsAvailable.toNumber()) {\n    throw new CandyMachineCannotAddAmountError(\n      index,\n      amount,\n      candyMachine.itemsAvailable.toNumber()\n    );\n  }\n};\n\nexport const assertAllItemConstraints = (\n  candyMachine: Pick<CandyMachine, 'itemSettings'>,\n  items: Pick<CandyMachineItem, 'name' | 'uri'>[]\n) => {\n  if (candyMachine.itemSettings.type !== 'configLines') {\n    return;\n  }\n\n  const { nameLength } = candyMachine.itemSettings;\n  const { uriLength } = candyMachine.itemSettings;\n\n  for (let i = 0; i < items.length; i++) {\n    if (items[i].name.length > nameLength) {\n      throw new CandyMachineItemTextTooLongError(\n        i,\n        'name',\n        items[i].name,\n        nameLength\n      );\n    }\n    if (items[i].uri.length > uriLength) {\n      throw new CandyMachineItemTextTooLongError(\n        i,\n        'uri',\n        items[i].uri,\n        uriLength\n      );\n    }\n  }\n};\n","import { createAddConfigLinesInstruction } from '@metaplex-foundation/mpl-candy-machine-core';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertAllItemConstraints, assertCanAdd } from '../asserts';\nimport { CandyMachine, CandyMachineItem } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'InsertCandyMachineItemsOperation' as const;\n\n/**\n * Insert items into an existing Candy Machine.\n *\n * Note that the name and URI of each item should not include\n * the prefixes configured in the config line settings.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .insertItems({\n *     candyMachine,\n *     items: [\n *       { name: 'My NFT #1', uri: 'https://example.com/nft1' },\n *       { name: 'My NFT #2', uri: 'https://example.com/nft2' },\n *       { name: 'My NFT #3', uri: 'https://example.com/nft3' },\n *     ],\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const insertCandyMachineItemsOperation =\n  useOperation<InsertCandyMachineItemsOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type InsertCandyMachineItemsOperation = Operation<\n  typeof Key,\n  InsertCandyMachineItemsInput,\n  InsertCandyMachineItemsOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type InsertCandyMachineItemsInput = {\n  /**\n   * The Candy Machine to insert items into.\n   *\n   * We only need a subset of the `CandyMachine` model.\n   * We need its address, its items settings and the number of items loaded\n   * and to be loaded so we can check if the operation is valid.\n   */\n  candyMachine: Pick<\n    CandyMachine,\n    'address' | 'itemsAvailable' | 'itemsLoaded' | 'itemSettings'\n  >;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The items to insert into the candy machine.\n   *\n   * This only requires the `name` and the `uri` to insert for each item.\n   *\n   * Important: If your config line settings use prefixes, you must\n   * only provide the part of the name or URI that comes after theses prefixes.\n   *\n   * For example, if your config line settings use the following prefixes:\n   * - `prefixName`: `My NFT #`\n   * - `prefixUri`: `https://example.com/nfts/`\n   *\n   * Then, an item to insert could be: `{ name: '1', uri: '1.json' }`.\n   *\n   * @see {@link CandyMachineItem}\n   */\n  items: Pick<CandyMachineItem, 'name' | 'uri'>[];\n\n  /**\n   * The index we should use to insert the new items. This refers to the\n   * index of the first item to insert and the others will follow after it.\n   *\n   * By defaults, this uses the `itemsLoaded` property so items are simply\n   * appended to the current items.\n   *\n   * @defaultValue `candyMachine.itemsLoaded`\n   */\n  index?: number;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type InsertCandyMachineItemsOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const insertCandyMachineItemsOperationHandler: OperationHandler<InsertCandyMachineItemsOperation> =\n  {\n    async handle(\n      operation: InsertCandyMachineItemsOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<InsertCandyMachineItemsOutput> {\n      return insertCandyMachineItemsBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type InsertCandyMachineItemsBuilderParams = Omit<\n  InsertCandyMachineItemsInput,\n  'confirmOptions'\n> & {\n  instructionKey?: string;\n};\n\n/**\n * Insert items into an existing Candy Machine.\n *\n * Note that the name and URI of each item should not include\n * the prefixes configured in the config line settings.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachines()\n *   .builders()\n *   .insertItems({ candyMachine, items });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const insertCandyMachineItemsBuilder = (\n  metaplex: Metaplex,\n  params: InsertCandyMachineItemsBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const authority = params.authority ?? metaplex.identity();\n  const index = params.index ?? params.candyMachine.itemsLoaded;\n  const { items } = params;\n\n  assertCanAdd(params.candyMachine, index, items.length);\n  assertAllItemConstraints(params.candyMachine, items);\n\n  // Programs.\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createAddConfigLinesInstruction(\n        {\n          candyMachine: params.candyMachine.address,\n          authority: authority.publicKey,\n        },\n        { index, configLines: items },\n        candyMachineProgram.address\n      ),\n      signers: [authority],\n      key: params.instructionKey ?? 'insertItems',\n    });\n};\n","import { createMintInstruction as createMintFromGuardInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { createMintInstruction as createMintFromMachineInstruction } from '@metaplex-foundation/mpl-candy-machine-core';\nimport {\n  Keypair,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyMachineBotTaxError } from '../errors';\nimport {\n  CandyGuardsMintSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardMintSettings,\n  DefaultCandyGuardSettings,\n} from '../guards';\nimport { CandyMachine } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  token as tokenAmount,\n} from '@/types';\nimport { NftWithToken } from '@/plugins/nftModule';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintFromCandyMachineOperation' as const;\n\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintFromCandyMachineOperation = _mintFromCandyMachineOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _mintFromCandyMachineOperation<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n>(\n  input: MintFromCandyMachineInput<Settings, MintSettings>\n): MintFromCandyMachineOperation<Settings, MintSettings> {\n  return { key: Key, input };\n}\n_mintFromCandyMachineOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintFromCandyMachineOperation<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = Operation<\n  typeof Key,\n  MintFromCandyMachineInput<Settings, MintSettings>,\n  MintFromCandyMachineOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintFromCandyMachineInput<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = {\n  /**\n   * The Candy Machine to mint from.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to mint from it.\n   *\n   * This includes its address, the address of its Collection NFT and,\n   * optionally, the Candy Guard account associated with it.\n   */\n  candyMachine: Pick<\n    CandyMachine<Settings>,\n    'address' | 'collectionMintAddress' | 'candyGuard'\n  >;\n\n  /**\n   * The address of the update authority of the Collection NFT\n   * that is being assigned to each minted NFT.\n   */\n  collectionUpdateAuthority: PublicKey;\n\n  /**\n   * The authority that is allowed to mint NFTs from the Candy Machine.\n   *\n   * @defaultValue\n   * `metaplex.identity()` if the Candy Machine has no associated Candy Guard.\n   * Otherwise, this parameter will be ignored.\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The mint account to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  mint?: Signer;\n\n  /**\n   * The owner of the minted NFT.\n   *\n   * Defaults to the wallet that is paying for it, i.e. `payer`.\n   *\n   * @defaultValue `payer.publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The new token account to create as a Signer.\n   *\n   * This property would typically be ignored as, by default, it will create a\n   * associated token account from the `owner` and `mint` properties.\n   *\n   * When provided, the `owner` property will be ignored.\n   *\n   * @defaultValue associated token address of `owner` and `mint`.\n   */\n  token?: Signer;\n\n  /**\n   * The label of the group to mint from.\n   *\n   * If groups are configured on the Candy Machine,\n   * you must specify a group label to mint from.\n   *\n   * When set to `null` it will mint using the default\n   * guards, provided no groups are configured.\n   *\n   * @defaultValue `null`\n   */\n  group?: Option<string>;\n\n  /**\n   * Guard-specific data required to mint from the Candy Machine.\n   *\n   * Some guards require additional data to be provided at mint time.\n   * For instance, the `allowList` guard will require a Merkle proof\n   * ensuring the minting address is allowed to mint.\n   *\n   * You only need to provide configuration data for the guards\n   * that are set up within the group your are minting from.\n   *\n   * @defaultValue `{}`\n   */\n  guards?: Partial<MintSettings>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintFromCandyMachineOutput = {\n  /** The minted NFT. */\n  nft: NftWithToken;\n\n  /** The mint account of the minted NFT as a Signer. */\n  mintSigner: Signer;\n\n  /** The address of the minted NFT's token account. */\n  tokenAddress: PublicKey;\n\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintFromCandyMachineOperationHandler: OperationHandler<MintFromCandyMachineOperation> =\n  {\n    async handle<\n      Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n      MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n    >(\n      operation: MintFromCandyMachineOperation<Settings, MintSettings>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MintFromCandyMachineOutput> {\n      const builder = await mintFromCandyMachineBuilder<Settings, MintSettings>(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      let nft: NftWithToken;\n      try {\n        nft = (await metaplex.nfts().findByMint(\n          {\n            mintAddress: output.mintSigner.publicKey,\n            tokenAddress: output.tokenAddress,\n          },\n          scope\n        )) as NftWithToken;\n      } catch (error) {\n        const { candyGuard } = operation.input.candyMachine;\n        if (!candyGuard) {\n          throw error;\n        }\n\n        const activeGuards = metaplex\n          .candyMachines()\n          .guards()\n          .resolveGroupSettings(\n            candyGuard.guards,\n            candyGuard.groups,\n            operation.input.group ?? null\n          );\n\n        if (!('botTax' in activeGuards)) {\n          throw error;\n        }\n\n        throw new CandyMachineBotTaxError(\n          metaplex.rpc().getSolanaExporerUrl(output.response.signature),\n          error as Error\n        );\n      }\n\n      return { nft, ...output };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintFromCandyMachineBuilderParams<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = Omit<\n  MintFromCandyMachineInput<Settings, MintSettings>,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account of the NFT. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account of the NFT. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account of the NFT. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account of the NFT. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account of the NFT. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the one token. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints from the Candy Machine. */\n  mintFromCandyMachineInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type MintFromCandyMachineBuilderContext = Omit<\n  MintFromCandyMachineOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintFromCandyMachineBuilder = async <\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n>(\n  metaplex: Metaplex,\n  params: MintFromCandyMachineBuilderParams<Settings, MintSettings>,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<MintFromCandyMachineBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    collectionUpdateAuthority,\n    mintAuthority = metaplex.identity(),\n    mint = Keypair.generate(),\n    owner = payer.publicKey,\n    group = null,\n    guards = {},\n    token,\n  } = params;\n\n  // Programs.\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const authorityPda = metaplex.candyMachines().pdas().authority({\n    candyMachine: candyMachine.address,\n    programs,\n  });\n  const nftMetadata = metaplex.nfts().pdas().metadata({\n    mint: mint.publicKey,\n    programs,\n  });\n  const nftMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: mint.publicKey,\n    programs,\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: candyMachine.collectionMintAddress,\n    programs,\n  });\n  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: candyMachine.collectionMintAddress,\n    programs,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: candyMachine.collectionMintAddress,\n      collectionAuthority: authorityPda,\n      programs,\n    });\n\n  // Transaction Builder that prepares the mint and token accounts.\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: tokenAmount(1),\n        mint,\n        mintAuthority: payer,\n        freezeAuthority: payer.publicKey,\n        owner,\n        token,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n\n  // Shared mint accounts\n  const sharedMintAccounts = {\n    candyMachine: candyMachine.address,\n    payer: payer.publicKey,\n    nftMetadata,\n    nftMint: mint.publicKey,\n    nftMintAuthority: payer.publicKey,\n    nftMasterEdition,\n    collectionAuthorityRecord,\n    collectionMint: candyMachine.collectionMintAddress,\n    collectionMetadata,\n    collectionMasterEdition,\n    collectionUpdateAuthority,\n    candyMachineProgram: candyMachineProgram.address,\n    tokenMetadataProgram: tokenMetadataProgram.address,\n    tokenProgram: tokenProgram.address,\n    systemProgram: systemProgram.address,\n    recentSlothashes: SYSVAR_SLOT_HASHES_PUBKEY,\n    instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,\n  };\n\n  // Mint instruction.\n  let mintNftInstruction: TransactionInstruction;\n  let mintNftSigners: Signer[];\n  if (!!candyMachine.candyGuard) {\n    const { candyGuard } = candyMachine;\n    const guardClient = metaplex.candyMachines().guards();\n    const parsedMintSettings = guardClient.parseMintSettings(\n      candyMachine.address,\n      candyGuard,\n      owner,\n      payer,\n      mint,\n      guards,\n      group,\n      programs\n    );\n\n    mintNftSigners = [payer, mint, ...parsedMintSettings.signers];\n    mintNftInstruction = createMintFromGuardInstruction(\n      {\n        ...sharedMintAccounts,\n        candyGuard: candyMachine.candyGuard.address,\n        candyMachineAuthorityPda: authorityPda,\n      },\n      {\n        mintArgs: parsedMintSettings.arguments,\n        label: group,\n      },\n      candyGuardProgram.address\n    );\n    mintNftInstruction.keys.push(...parsedMintSettings.accountMetas);\n  } else {\n    mintNftSigners = [payer, mint, mintAuthority];\n    mintNftInstruction = createMintFromMachineInstruction(\n      {\n        ...sharedMintAccounts,\n        authorityPda,\n        mintAuthority: mintAuthority.publicKey,\n      },\n      candyMachineProgram.address\n    );\n  }\n\n  return (\n    TransactionBuilder.make<MintFromCandyMachineBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({ tokenAddress, mintSigner: mint })\n\n      // Create token and mint accounts.\n      .add(tokenWithMintBuilder)\n\n      // Mint the new NFT.\n      .add({\n        instruction: mintNftInstruction,\n        signers: mintNftSigners,\n        key: params.mintFromCandyMachineInstructionKey ?? 'mintNft',\n      })\n  );\n};\n","import { createUnwrapInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UnwrapCandyGuardOperation' as const;\n\n/**\n * Unwraps the given Candy Machine from its Candy Guard.\n *\n * This makes the Candy Machine authority its own mint authority again\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .unwrapCandyGuard({\n *     candyMachine,\n *     candyGuard,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const unwrapCandyGuardOperation =\n  useOperation<UnwrapCandyGuardOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UnwrapCandyGuardOperation = Operation<\n  typeof Key,\n  UnwrapCandyGuardInput,\n  UnwrapCandyGuardOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UnwrapCandyGuardInput = {\n  /** The address of the Candy Machine to unwrap. */\n  candyMachine: PublicKey;\n\n  /** The address of the Candy Guard to unwrap the Candy Machine from. */\n  candyGuard: PublicKey;\n\n  /**\n   * The authority of the Candy Machine as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  candyMachineAuthority?: Signer;\n\n  /**\n   * The authority of the Candy Guard as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  candyGuardAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UnwrapCandyGuardOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const unwrapCandyGuardOperationHandler: OperationHandler<UnwrapCandyGuardOperation> =\n  {\n    async handle(\n      operation: UnwrapCandyGuardOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UnwrapCandyGuardOutput> {\n      return unwrapCandyGuardBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UnwrapCandyGuardBuilderParams = Omit<\n  UnwrapCandyGuardInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that unwraps the Candy Machine from its Candy Guard. */\n  unwrapCandyGuardInstructionKey?: string;\n};\n\n/**\n * Unwraps the given Candy Machine from its Candy Guard.\n *\n * This makes the Candy Machine authority its own mint authority again\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .unwrapCandyGuard({\n *     candyMachine,\n *     candyGuard,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const unwrapCandyGuardBuilder = (\n  metaplex: Metaplex,\n  params: UnwrapCandyGuardBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyGuard,\n    candyGuardAuthority = metaplex.identity(),\n    candyMachine,\n    candyMachineAuthority = metaplex.identity(),\n  } = params;\n\n  // Programs.\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createUnwrapInstruction(\n        {\n          candyGuard,\n          authority: candyGuardAuthority.publicKey,\n          candyMachine,\n          candyMachineProgram: candyMachineProgram.address,\n          candyMachineAuthority: candyMachineAuthority.publicKey,\n        },\n        candyGuardProgram.address\n      ),\n      signers: [candyGuardAuthority, candyMachineAuthority],\n      key: params.unwrapCandyGuardInstructionKey ?? 'unwrapCandyGuard',\n    });\n};\n","import {\n  CandyMachineData,\n  createSetAuthorityInstruction,\n  createSetCollectionInstruction,\n  createSetMintAuthorityInstruction,\n  createUpdateInstruction as createUpdateCandyMachineInstruction,\n} from '@metaplex-foundation/mpl-candy-machine-core';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport {\n  CandyMachine,\n  CandyMachineConfigLineSettings,\n  CandyMachineHiddenSettings,\n  isCandyMachine,\n  toCandyMachineData,\n} from '../models';\nimport { MissingInputDataError, NoInstructionsToSendError } from '@/errors';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  BigNumber,\n  Creator,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Program,\n  PublicKey,\n  Signer,\n  toPublicKey,\n} from '@/types';\nimport {\n  assertObjectHasDefinedKeys,\n  removeUndefinedAttributes,\n  TransactionBuilder,\n  TransactionBuilderOptions,\n} from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyMachineOperation' as const;\n\n/**\n * Updates the every aspect of an existing Candy Machine, including its\n * authorities, collection and guards (when associated with a Candy Guard).\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .update({\n *     candyMachine,\n *     sellerFeeBasisPoints: 500,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateCandyMachineOperation = _updateCandyMachineOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _updateCandyMachineOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(input: UpdateCandyMachineInput<T>): UpdateCandyMachineOperation<T> {\n  return { key: Key, input };\n}\n_updateCandyMachineOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateCandyMachineOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, UpdateCandyMachineInput<T>, UpdateCandyMachineOutput>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateCandyMachineInput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /**\n   * The Candy Machine to update.\n   *\n   * This can either be a Candy Machine instance or its address.\n   * When passing its address, you will need to provide enough input\n   * so the SDK knows what to update.\n   *\n   * For instance, if you only want to update the `creators` array of the Candy Machine,\n   * you will also need to provide all other Candy Machine data such as its `symbol`,\n   * its `sellerFeeBasisPoints`, etc.\n   *\n   * That's because the program requires all data to be provided at once when updating.\n   * The SDK will raise an error if you don't provide enough data letting you know\n   * what's missing.\n   *\n   * Alternatively, if you provide a Candy Machine instance, the SDK will use its\n   * current data to fill all the gaps so you can focus on what you want to update.\n   */\n  candyMachine: PublicKey | CandyMachine<T>;\n\n  /**\n   * The address of the Candy Guard associated to the Candy Machine, if any.\n   * This is only required if `candyMachine` is provided as an address and\n   * you are trying to update the `guards` or `groups` parameters.\n   *\n   * @defaultValue `candyMachine.candyGuard?.address`\n   */\n  candyGuard?: PublicKey;\n\n  /**\n   * The Signer authorized to update the Candy Machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The Signer authorized to update the associated Candy Guard, if any.\n   * This is typically the same as the Candy Machine authority.\n   *\n   * @defaultValue Defaults to the `authority` parameter.\n   */\n  candyGuardAuthority?: Signer;\n\n  /**\n   * The new authority that will be allowed to manage the Candy Machine.\n   * This includes updating its data, authorities, inserting items, etc.\n   *\n   * Warning: This means the current `authority` Signer will no longer be able\n   * to manage the Candy Machine.\n   *\n   * Note that if your Candy Machine has a Candy Guard associated to it,\n   * you might want to also update the Candy Guard's authority using the\n   * `newCandyGuardAuthority` parameter.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newAuthority?: PublicKey;\n\n  /**\n   * The new authority that will be able to mint from this Candy Machine.\n   *\n   * This must be a Signer to ensure Candy Guards are not used to mint from\n   * unexpected Candy Machines as some of its guards could have side effects.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newMintAuthority?: Signer;\n\n  /**\n   * The new authority that will be allowed to manage the Candy Guard\n   * account associated with the Candy Machine.\n   *\n   * Warning: This means the current Candy Guard `authority` Signer will\n   * no longer be able to manage the Candy Guard account.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newCandyGuardAuthority?: PublicKey;\n\n  /**\n   * The Collection NFT that all NFTs minted from this Candy Machine should be part of.\n   * This must include its address and the update authority as a Signer.\n   *\n   * If the `candyMachine` attribute is passed as a `PublicKey`, you will also need to\n   * provide the mint address of the current collection that will be overriden.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  collection?: {\n    /** The mint address of the collection. */\n    address: PublicKey;\n\n    /** The update authority of the collection as a Signer. */\n    updateAuthority: Signer;\n\n    /** The mint address of the current collection that will be overriden. */\n    currentCollectionAddress?: PublicKey;\n  };\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  sellerFeeBasisPoints?: number;\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  itemsAvailable?: BigNumber;\n\n  /**\n   * Settings related to the Candy Machine's items.\n   *\n   * These can either be inserted manually within the Candy Machine or\n   * they can be infered from a set of hidden settings.\n   *\n   * - If `type` is `hidden`, the Candy Machine is using hidden settings.\n   * - If `type` is `configLines`, the Candy Machine is using config line settings.\n   *\n   * @defaultValue Defaults to not being updated.\n   *\n   * @see {@link CandyMachineHiddenSettings}\n   * @see {@link CandyMachineConfigLineSettings}\n   */\n  itemSettings?: CandyMachineHiddenSettings | CandyMachineConfigLineSettings;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  symbol?: string;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  maxEditionSupply?: BigNumber;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  isMutable?: boolean;\n\n  /**\n   * Array of creators that should be set on minted NFTs.\n   *\n   * @defaultValue Defaults to not being updated.\n   *\n   * @see {@link Creator}\n   */\n  creators?: Omit<Creator, 'verified'>[];\n\n  /**\n   * The settings of all guards we wish to activate.\n   *\n   * Note that this will override the existing `guards` settings\n   * so you must provide all guards you wish to activate.\n   *\n   * Any guard not provided or set to `null` will be disabled.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  guards?: Partial<T>;\n\n  /**\n   * This parameter allows us to create multiple minting groups that have their\n   * own set of requirements — i.e. guards.\n   *\n   * Note that this will override the existing `groups` settings\n   * so you must provide all groups and guards you wish to activate.\n   *\n   * When groups are provided, the `guards` parameter becomes a set of default\n   * guards that will be applied to all groups. If a specific group enables\n   * a guard that is also present in the default guards, the group's guard\n   * will override the default guard.\n   *\n   * For each group, any guard not provided or set to `null` will be disabled.\n   *\n   * You may disable groups by providing an empty array `[]`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  groups?: { label: string; guards: Partial<T> }[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateCandyMachineOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateCandyMachineOperationHandler: OperationHandler<UpdateCandyMachineOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: UpdateCandyMachineOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UpdateCandyMachineOutput> {\n      const builder = updateCandyMachineBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n\n      if (builder.isEmpty()) {\n        throw new NoInstructionsToSendError(Key);\n      }\n\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateCandyMachineBuilderParams<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Omit<UpdateCandyMachineInput<T>, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that updates the Candy Machine data. */\n  updateDataInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the Candy Machine collection. */\n  setCollectionInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the associated Candy Guard, if any. */\n  updateCandyGuardInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the Candy Machine's mint authority. */\n  setMintAuthorityInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the Candy Machine's authority. */\n  setAuthorityInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the Candy Guard's authority. */\n  setCandyGuardAuthorityInstructionKey?: string;\n};\n\n/**\n * Updates the every aspect of an existing Candy Machine, including its\n * authorities, collection and guards (when associated with a Candy Guard).\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .update({\n *     candyMachine,\n *     sellerFeeBasisPoints: 500,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateCandyMachineBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { authority = metaplex.identity(), candyGuardAuthority = authority } =\n    params;\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update Candy Machine data.\n      .add(\n        updateCandyMachineDataBuilder<T>(metaplex, params, authority, programs)\n      )\n\n      // Update Candy Machine collection.\n      .add(\n        updateCandyMachineCollectionBuilder<T>(\n          metaplex,\n          params,\n          authority,\n          payer,\n          programs\n        )\n      )\n\n      // Update Candy Guard's guards and groups, if any.\n      .add(\n        updateCandyGuardsBuilder<T>(\n          metaplex,\n          params,\n          candyGuardAuthority,\n          payer,\n          programs\n        )\n      )\n\n      // Update Candy Machine mint authority.\n      .add(\n        updateCandyMachineMintAuthorityBuilder<T>(\n          metaplex,\n          params,\n          authority,\n          programs\n        )\n      )\n\n      // Update Candy Machine authority.\n      .add(\n        updateCandyMachineAuthorityBuilder<T>(\n          metaplex,\n          params,\n          authority,\n          programs\n        )\n      )\n\n      // Update Candy Guard authority.\n      .add(\n        updateCandyGuardAuthorityBuilder<T>(\n          metaplex,\n          params,\n          candyGuardAuthority,\n          payer,\n          programs\n        )\n      )\n  );\n};\n\nconst updateCandyMachineDataBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  authority: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  const dataToUpdate: Partial<CandyMachine> = removeUndefinedAttributes({\n    itemsAvailable: params.itemsAvailable,\n    symbol: params.symbol,\n    sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n    maxEditionSupply: params.maxEditionSupply,\n    isMutable: params.isMutable,\n    creators: params.creators,\n    itemSettings: params.itemSettings,\n  });\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  let data: CandyMachineData;\n  if (Object.keys(dataToUpdate).length === 0) {\n    return TransactionBuilder.make();\n  } else if (isCandyMachine(params.candyMachine)) {\n    data = toCandyMachineData({ ...params.candyMachine, ...dataToUpdate });\n  } else {\n    assertObjectHasDefinedKeys(\n      dataToUpdate,\n      [\n        'itemsAvailable',\n        'symbol',\n        'sellerFeeBasisPoints',\n        'maxEditionSupply',\n        'isMutable',\n        'creators',\n        'itemSettings',\n      ],\n      onMissingInputError\n    );\n    data = toCandyMachineData(dataToUpdate);\n  }\n\n  return TransactionBuilder.make().add({\n    instruction: createUpdateCandyMachineInstruction(\n      {\n        candyMachine: toPublicKey(params.candyMachine),\n        authority: authority.publicKey,\n      },\n      { data },\n      candyMachineProgram.address\n    ),\n    signers: [authority],\n    key: params.updateDataInstructionKey ?? 'updateCandyMachineData',\n  });\n};\n\nconst updateCandyMachineCollectionBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  authority: Signer,\n  payer: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  if (!params.collection) {\n    return TransactionBuilder.make();\n  }\n\n  const currentCollectionAddress =\n    params.collection.currentCollectionAddress ??\n    (isCandyMachine(params.candyMachine)\n      ? params.candyMachine.collectionMintAddress\n      : null);\n\n  if (!currentCollectionAddress) {\n    throw onMissingInputError(['collection.currentCollectionAddress']);\n  }\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  // Addresses.\n  const candyMachineAddress = toPublicKey(params.candyMachine);\n  const collectionAddress = params.collection.address;\n  const collectionUpdateAuthority = params.collection.updateAuthority;\n\n  // PDAs.\n  const authorityPda = metaplex.candyMachines().pdas().authority({\n    candyMachine: candyMachineAddress,\n    programs,\n  });\n  const currentCollectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: currentCollectionAddress,\n  });\n  const currentCollectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: currentCollectionAddress,\n      collectionAuthority: authorityPda,\n    });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: collectionAddress,\n  });\n  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: collectionAddress,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: collectionAddress,\n      collectionAuthority: authorityPda,\n    });\n\n  return TransactionBuilder.make().add({\n    instruction: createSetCollectionInstruction(\n      {\n        candyMachine: candyMachineAddress,\n        authority: authority.publicKey,\n        authorityPda,\n        payer: payer.publicKey,\n        collectionMint: currentCollectionAddress,\n        collectionMetadata: currentCollectionMetadata,\n        collectionAuthorityRecord: currentCollectionAuthorityRecord,\n        newCollectionUpdateAuthority: collectionUpdateAuthority.publicKey,\n        newCollectionMetadata: collectionMetadata,\n        newCollectionMint: collectionAddress,\n        newCollectionMasterEdition: collectionMasterEdition,\n        newCollectionAuthorityRecord: collectionAuthorityRecord,\n        tokenMetadataProgram: tokenMetadataProgram.address,\n      },\n      candyMachineProgram.address\n    ),\n    signers: [authority, payer, collectionUpdateAuthority],\n    key: params.setCollectionInstructionKey ?? 'setCandyMachineCollection',\n  });\n};\n\nconst updateCandyGuardsBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  candyGuardAuthority: Signer,\n  payer: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  const guardsToUpdate: {\n    candyGuard?: PublicKey;\n    guards?: Partial<T>;\n    groups?: { label: string; guards: Partial<T> }[];\n  } = removeUndefinedAttributes({\n    candyGuard: params.candyGuard,\n    guards: params.guards,\n    groups: params.groups,\n  });\n\n  let args: {\n    candyGuard: PublicKey;\n    guards: Partial<T>;\n    groups: { label: string; guards: Partial<T> }[];\n  };\n\n  if (Object.keys(guardsToUpdate).length === 0) {\n    return TransactionBuilder.make();\n  }\n\n  if (\n    isCandyMachine<T>(params.candyMachine) &&\n    params.candyMachine.candyGuard\n  ) {\n    args = {\n      candyGuard: params.candyMachine.candyGuard.address,\n      guards: params.candyMachine.candyGuard.guards,\n      groups: params.candyMachine.candyGuard.groups,\n      ...guardsToUpdate,\n    };\n  } else {\n    assertObjectHasDefinedKeys(\n      guardsToUpdate,\n      ['candyGuard', 'guards', 'groups'],\n      onMissingInputError\n    );\n    args = guardsToUpdate;\n  }\n\n  return metaplex\n    .candyMachines()\n    .builders()\n    .updateCandyGuard<T>(\n      {\n        candyGuard: args.candyGuard,\n        guards: args.guards,\n        groups: args.groups,\n        authority: candyGuardAuthority,\n        updateInstructionKey:\n          params.updateCandyGuardInstructionKey ?? 'updateCandyGuard',\n      },\n      { payer, programs }\n    );\n};\n\nconst updateCandyMachineMintAuthorityBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  authority: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  if (!params.newMintAuthority) {\n    return TransactionBuilder.make();\n  }\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  return TransactionBuilder.make().add({\n    instruction: createSetMintAuthorityInstruction(\n      {\n        candyMachine: toPublicKey(params.candyMachine),\n        authority: authority.publicKey,\n        mintAuthority: params.newMintAuthority.publicKey,\n      },\n      candyMachineProgram.address\n    ),\n    signers: [authority, params.newMintAuthority],\n    key: params.setAuthorityInstructionKey ?? 'setCandyMachineAuthority',\n  });\n};\n\nconst updateCandyMachineAuthorityBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  authority: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  if (!params.newAuthority) {\n    return TransactionBuilder.make();\n  }\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n\n  return TransactionBuilder.make().add({\n    instruction: createSetAuthorityInstruction(\n      {\n        candyMachine: toPublicKey(params.candyMachine),\n        authority: authority.publicKey,\n      },\n      { newAuthority: params.newAuthority },\n      candyMachineProgram.address\n    ),\n    signers: [authority],\n    key: params.setAuthorityInstructionKey ?? 'setCandyMachineAuthority',\n  });\n};\n\nconst updateCandyGuardAuthorityBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyMachineBuilderParams<T>,\n  candyGuardAuthority: Signer,\n  payer: Signer,\n  programs?: Program[]\n): TransactionBuilder => {\n  if (!params.newCandyGuardAuthority) {\n    return TransactionBuilder.make();\n  }\n\n  const candyGuardAddress =\n    params.candyGuard ??\n    (isCandyMachine<T>(params.candyMachine) && params.candyMachine.candyGuard\n      ? params.candyMachine.candyGuard.address\n      : null);\n\n  if (!candyGuardAddress) {\n    throw onMissingInputError(['candyGuard']);\n  }\n\n  return TransactionBuilder.make().add(\n    metaplex.candyMachines().builders().updateCandyGuardAuthority(\n      {\n        candyGuard: candyGuardAddress,\n        authority: candyGuardAuthority,\n        newAuthority: params.newCandyGuardAuthority,\n        instructionKey: params.setCandyGuardAuthorityInstructionKey,\n      },\n      { payer, programs }\n    )\n  );\n};\n\nconst onMissingInputError = (missingKeys: string[]) =>\n  new MissingInputDataError(\n    missingKeys,\n    'When passing the Candy Machine as a `PublicKey` instead of a Candy Machine model ' +\n      'the SDK cannot rely on current data to fill the gaps within the provided input. ' +\n      'Alternatively, you can pass the Candy Machine model instead.'\n  );\n","import { createUpdateInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport { Operation, OperationHandler, OperationScope, Signer } from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyGuardOperation' as const;\n\n/**\n * Updates an existing Candy Guard account.\n *\n * Note that the provided `guards` and `groups`\n * will replace the existing ones.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .updateCandyGuard({\n *     candyGuard: candyGuard.address,\n *     guards: {\n *       startDate: { date: toDateTime('2022-09-05T20:00:00.000Z') },\n *       solPayment: { amount: sol(1.5), },\n *       botTax: { lamports: sol(0.01), lastInstruction: true },\n *     },\n *     groups: [],\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateCandyGuardOperation = _updateCandyGuardOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _updateCandyGuardOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(input: UpdateCandyGuardInput<T>): UpdateCandyGuardOperation<T> {\n  return { key: Key, input };\n}\n_updateCandyGuardOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateCandyGuardOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, UpdateCandyGuardInput<T>, UpdateCandyGuardOutput>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateCandyGuardInput<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = {\n  /** The address of the Candy Guard to update. */\n  candyGuard: PublicKey;\n\n  /**\n   * The settings of all guards we wish to activate.\n   *\n   * Note that this will override the existing `guards` parameter\n   * so you must provide all guards you wish to activate.\n   *\n   * Any guard not provided or set to `null` will be disabled.\n   */\n  guards: Partial<T>;\n\n  /**\n   * This parameter allows us to create multiple minting groups that have their\n   * own set of requirements — i.e. guards.\n   *\n   * Note that this will override the existing `groups` parameter\n   * so you must provide all groups and guards you wish to activate.\n   *\n   * When groups are provided, the `guards` parameter becomes a set of default\n   * guards that will be applied to all groups. If a specific group enables\n   * a guard that is also present in the default guards, the group's guard\n   * will override the default guard.\n   *\n   * For each group, any guard not provided or set to `null` will be disabled.\n   *\n   * You may disable groups by providing an empty array `[]`.\n   */\n  groups?: { label: string; guards: Partial<T> }[];\n\n  /**\n   * The Signer authorized to update the candy Guard.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateCandyGuardOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateCandyGuardOperationHandler: OperationHandler<UpdateCandyGuardOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: UpdateCandyGuardOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UpdateCandyGuardOutput> {\n      return updateCandyGuardBuilder<T>(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateCandyGuardBuilderParams<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Omit<UpdateCandyGuardInput<T>, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that updates the candy guard. */\n  updateInstructionKey?: string;\n};\n\n/**\n * Updates an existing Candy Guard account.\n *\n * Note that the provided `guards` and `groups`\n * will replace the existing ones.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachines()\n *   .builders()\n *   .updateCandyGuard({\n *     candyGuard: candyGuard.address,\n *     guards: {\n *       startDate: { date: toDateTime('2022-09-05T20:00:00.000Z') },\n *       solPayment: { amount: sol(1.5), },\n *       botTax: { lamports: sol(0.01), lastInstruction: true },\n *     },\n *     groups: [],\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateCandyGuardBuilder = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  metaplex: Metaplex,\n  params: UpdateCandyGuardBuilderParams<T>,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyGuard,\n    guards,\n    groups,\n    authority = metaplex.identity(),\n  } = params;\n\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n  const serializedSettings = metaplex\n    .candyMachines()\n    .guards()\n    .serializeSettings<T>(guards, groups, programs);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the candy guard account.\n      .add({\n        instruction: createUpdateInstruction(\n          {\n            candyGuard,\n            authority: authority.publicKey,\n            payer: payer.publicKey,\n          },\n          { data: serializedSettings },\n          candyGuardProgram.address\n        ),\n        signers: [authority, payer],\n        key: params.updateInstructionKey ?? 'updateCandyGuard',\n      })\n  );\n};\n","import { createWrapInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'WrapCandyGuardOperation' as const;\n\n/**\n * Wraps the given Candy Machine in a Candy Guard.\n *\n * This makes the Candy Guard the mint authority for the Candy Machine\n * which means all minting will have to go through the Candy Guard.\n *\n * ```ts\n * await metaplex\n *   .candyMachines()\n *   .wrapCandyGuard({\n *     candyMachine,\n *     candyGuard,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const wrapCandyGuardOperation =\n  useOperation<WrapCandyGuardOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type WrapCandyGuardOperation = Operation<\n  typeof Key,\n  WrapCandyGuardInput,\n  WrapCandyGuardOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type WrapCandyGuardInput = {\n  /** The address of the Candy Machine to wrap. */\n  candyMachine: PublicKey;\n\n  /** The address of the Candy Guard to wrap the Candy Machine with. */\n  candyGuard: PublicKey;\n\n  /**\n   * The authority of the Candy Machine as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  candyMachineAuthority?: Signer;\n\n  /**\n   * The authority of the Candy Guard as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  candyGuardAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type WrapCandyGuardOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const wrapCandyGuardOperationHandler: OperationHandler<WrapCandyGuardOperation> =\n  {\n    async handle(\n      operation: WrapCandyGuardOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<WrapCandyGuardOutput> {\n      return wrapCandyGuardBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type WrapCandyGuardBuilderParams = Omit<\n  WrapCandyGuardInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that wraps the Candy Machine in a Candy Guard. */\n  wrapCandyGuardInstructionKey?: string;\n};\n\n/**\n * Wraps the given Candy Machine in a Candy Guard.\n *\n * This makes the Candy Guard the mint authority for the Candy Machine\n * which means all minting will have to go through the Candy Guard.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .wrapCandyGuard({\n *     candyMachine,\n *     candyGuard,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const wrapCandyGuardBuilder = (\n  metaplex: Metaplex,\n  params: WrapCandyGuardBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyGuard,\n    candyGuardAuthority = metaplex.identity(),\n    candyMachine,\n    candyMachineAuthority = metaplex.identity(),\n  } = params;\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createWrapInstruction(\n        {\n          candyGuard,\n          authority: candyGuardAuthority.publicKey,\n          candyMachine,\n          candyMachineProgram: candyMachineProgram.address,\n          candyMachineAuthority: candyMachineAuthority.publicKey,\n        },\n        candyGuardProgram.address\n      ),\n      signers: [candyGuardAuthority, candyMachineAuthority],\n      key: params.wrapCandyGuardInstructionKey ?? 'wrapCandyGuard',\n    });\n};\n","import {\n  CandyGuardsMintSettings,\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardMintSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from './guards';\nimport {\n  callCandyGuardRouteBuilder,\n  CallCandyGuardRouteBuilderParams,\n  createCandyGuardBuilder,\n  CreateCandyGuardBuilderParams,\n  createCandyMachineBuilder,\n  CreateCandyMachineBuilderParams,\n  deleteCandyGuardBuilder,\n  DeleteCandyGuardBuilderParams,\n  deleteCandyMachineBuilder,\n  DeleteCandyMachineBuilderParams,\n  insertCandyMachineItemsBuilder,\n  InsertCandyMachineItemsBuilderParams,\n  mintFromCandyMachineBuilder,\n  MintFromCandyMachineBuilderParams,\n  unwrapCandyGuardBuilder,\n  UnwrapCandyGuardBuilderParams,\n  updateCandyGuardBuilder,\n  UpdateCandyGuardBuilderParams,\n  updateCandyMachineBuilder,\n  UpdateCandyMachineBuilderParams,\n  wrapCandyGuardBuilder,\n  WrapCandyGuardBuilderParams,\n} from './operations';\nimport {\n  updateCandyGuardAuthorityBuilder,\n  UpdateCandyGuardAuthorityBuilderParams,\n} from './operations/updateCandyGuardAuthority';\nimport type { Metaplex } from '@/Metaplex';\nimport { TransactionBuilderOptions } from '@/utils';\n\n/**\n * This client allows you to access the underlying Transaction Builders\n * for the write operations of the Candy Guard module.\n *\n * @see {@link CandyMachineClient}\n * @group Module Builders\n */\nexport class CandyMachineBuildersClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** {@inheritDoc callCandyGuardRouteBuilder} */\n  callGuardRoute<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    input: CallCandyGuardRouteBuilderParams<Guard, Settings, RouteSettings>,\n    options?: TransactionBuilderOptions\n  ) {\n    return callCandyGuardRouteBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createCandyMachineBuilder} */\n  create<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: CreateCandyMachineBuilderParams<T>,\n    options?: TransactionBuilderOptions\n  ) {\n    return createCandyMachineBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createCandyGuardBuilder} */\n  createCandyGuard<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: CreateCandyGuardBuilderParams<T>,\n    options?: TransactionBuilderOptions\n  ) {\n    return createCandyGuardBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc deleteCandyMachineBuilder} */\n  delete(\n    input: DeleteCandyMachineBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return deleteCandyMachineBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc deleteCandyGuardBuilder} */\n  deleteCandyGuard(\n    input: DeleteCandyGuardBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return deleteCandyGuardBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc insertCandyMachineItemsBuilder} */\n  insertItems(\n    input: InsertCandyMachineItemsBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return insertCandyMachineItemsBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc mintFromCandyMachineBuilder} */\n  mint<\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n  >(\n    input: MintFromCandyMachineBuilderParams<Settings, MintSettings>,\n    options?: TransactionBuilderOptions\n  ) {\n    return mintFromCandyMachineBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc unwrapCandyGuardBuilder} */\n  unwrapCandyGuard(\n    input: UnwrapCandyGuardBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return unwrapCandyGuardBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc updateCandyMachineBuilder} */\n  update<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: UpdateCandyMachineBuilderParams<T>,\n    options?: TransactionBuilderOptions\n  ) {\n    return updateCandyMachineBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc updateCandyGuardBuilder} */\n  updateCandyGuard<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: UpdateCandyGuardBuilderParams<T>,\n    options?: TransactionBuilderOptions\n  ) {\n    return updateCandyGuardBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc updateCandyGuardAuthorityBuilder} */\n  updateCandyGuardAuthority(\n    input: UpdateCandyGuardAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return updateCandyGuardAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc wrapCandyGuardBuilder} */\n  wrapCandyGuard(\n    input: WrapCandyGuardBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return wrapCandyGuardBuilder(this.metaplex, input, options);\n  }\n}\n","import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { AccountMeta } from '@solana/web3.js';\nimport { CANDY_GUARD_LABEL_SIZE } from './constants';\nimport {\n  GuardGroupLabelTooLongError,\n  GuardGroupRequiredError,\n  GuardNotEnabledError,\n  GuardRouteNotSupportedError,\n  SelectedGuardGroupDoesNotExistError,\n  UnregisteredCandyGuardError,\n} from './errors';\nimport {\n  CandyGuardManifest,\n  CandyGuardsMintSettings,\n  CandyGuardsRemainingAccount,\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from './guards';\nimport { CandyGuard } from './models';\nimport { CandyGuardProgram } from './programs';\nimport { Option, padEmptyChars, removeEmptyChars } from '@/utils';\nimport {\n  deserialize,\n  deserializeFeatureFlags,\n  Program,\n  PublicKey,\n  serialize,\n  serializeFeatureFlags,\n  Signer,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * This client enables us to register custom guards from\n * custom Candy Guard programs and interact with them.\n *\n * @see {@link CandyGuardClient}\n * @group Module\n */\nexport class CandyMachineGuardsClient {\n  readonly guards: CandyGuardManifest<any, any, any>[] = [];\n\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Registers one or many guards by providing their manifest. */\n  register(...guard: CandyGuardManifest<any, any, any>[]) {\n    this.guards.push(...guard);\n  }\n\n  /** Gets the manifest of a guard using its name. */\n  get(name: string): CandyGuardManifest<any, any, any> {\n    const guard = this.guards.find((guard) => guard.name === name);\n\n    if (!guard) {\n      throw new UnregisteredCandyGuardError(name);\n    }\n\n    return guard;\n  }\n\n  /** Gets all registered guard manifests. */\n  all(): CandyGuardManifest<any, any, any>[] {\n    return this.guards;\n  }\n\n  /**\n   * Gets all guard manifests for a registered Candy Guard program.\n   *\n   * It fails if the manifest of any guard expected by the program\n   * is not registered. Manifests are returned in the order in which\n   * they are defined on the `availableGuards` property of the program.\n   */\n  forProgram(\n    program: string | PublicKey | CandyGuardProgram = 'CandyGuardProgram'\n  ): CandyGuardManifest<any, any, any>[] {\n    const candyGuardProgram =\n      typeof program === 'object' && 'availableGuards' in program\n        ? program\n        : this.metaplex.programs().get<CandyGuardProgram>(program);\n\n    return candyGuardProgram.availableGuards.map((name) => this.get(name));\n  }\n\n  /**\n   * Gets all guard manifests for the registered Candy Guard program.\n   *\n   * @see {@link CandyMachineGuardsClient.forProgram}\n   */\n  forCandyGuardProgram(\n    programs: Program[] = []\n  ): CandyGuardManifest<any, any, any>[] {\n    const candyGuardProgram = this.metaplex.programs().getCandyGuard(programs);\n\n    return this.forProgram(candyGuardProgram);\n  }\n\n  /** Serializes the settings of all guards and groups. */\n  serializeSettings<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    guards: Partial<T>,\n    groups: { label: string; guards: Partial<T> }[] = [],\n    programs: Program[] = []\n  ): Buffer {\n    const availableGuards = this.forCandyGuardProgram(programs);\n    this.assertGuardsAreRegistered<T>(\n      guards,\n      groups,\n      availableGuards.map(({ name }) => name)\n    );\n\n    const serializeSet = (set: Partial<T>): Buffer => {\n      const { features, buffer } = availableGuards.reduce(\n        (acc, guard, index) => {\n          const value = set[guard.name] ?? null;\n          acc.features[index] = Boolean(value);\n          if (value) {\n            acc.buffer = Buffer.concat([\n              acc.buffer,\n              serialize(value, guard.settingsSerializer),\n            ]);\n          }\n          return acc;\n        },\n        {\n          features: [] as boolean[],\n          buffer: Buffer.from([]),\n        }\n      );\n\n      const serializedfeatures = serializeFeatureFlags(features, 8, true);\n      serializedfeatures.reverse();\n\n      return Buffer.concat([serializedfeatures, buffer]);\n    };\n\n    let buffer = serializeSet(guards);\n\n    const groupCountBuffer = Buffer.alloc(4);\n    beet.u32.write(groupCountBuffer, 0, groups.length);\n    buffer = Buffer.concat([buffer, groupCountBuffer]);\n\n    groups.forEach((group) => {\n      if (group.label.length > CANDY_GUARD_LABEL_SIZE) {\n        throw new GuardGroupLabelTooLongError(\n          group.label,\n          CANDY_GUARD_LABEL_SIZE\n        );\n      }\n      const labelBuffer = Buffer.alloc(CANDY_GUARD_LABEL_SIZE);\n      labelBuffer.write(\n        padEmptyChars(group.label, CANDY_GUARD_LABEL_SIZE),\n        0,\n        CANDY_GUARD_LABEL_SIZE,\n        'utf8'\n      );\n      buffer = Buffer.concat([buffer, labelBuffer, serializeSet(group.guards)]);\n    });\n\n    return buffer;\n  }\n\n  /** Deserializes the settings of all guards and groups. */\n  deserializeSettings<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    buffer: Buffer,\n    program: string | PublicKey | CandyGuardProgram = 'CandyGuardProgram'\n  ): { guards: T; groups: { label: string; guards: T }[] } {\n    const availableGuards = this.forProgram(program);\n    const deserializeSet = () => {\n      const serializedFeatures = buffer.slice(0, 8);\n      serializedFeatures.reverse();\n      const features = deserializeFeatureFlags(serializedFeatures, 64, true);\n      buffer = buffer.slice(8);\n\n      return availableGuards.reduce((acc, guard, index) => {\n        const isEnabled = features[index] ?? false;\n        acc[guard.name] = null;\n        if (!isEnabled) return acc;\n\n        const [settings] = deserialize(buffer, guard.settingsSerializer);\n        buffer = buffer.slice(guard.settingsBytes);\n        acc[guard.name] = settings;\n        return acc;\n      }, {} as CandyGuardsSettings) as T;\n    };\n\n    const guards: T = deserializeSet();\n    const groups: { label: string; guards: T }[] = [];\n    const groupsCount = beet.u32.read(buffer, 0);\n    buffer = buffer.slice(4);\n\n    for (let i = 0; i < groupsCount; i++) {\n      const label = removeEmptyChars(\n        buffer.slice(0, CANDY_GUARD_LABEL_SIZE).toString('utf8')\n      );\n      buffer = buffer.slice(CANDY_GUARD_LABEL_SIZE);\n      groups.push({ label, guards: deserializeSet() });\n    }\n\n    return { guards, groups };\n  }\n\n  /**\n   * Resolves the set of settings that should be used when minting.\n   *\n   * If no group exists, the `guards` settings will be used.\n   * Otherwise, the `guards` settings will act as default settings and\n   * the settings of the selected group will override them.\n   */\n  resolveGroupSettings<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    guards: T,\n    groups: { label: string; guards: T }[] = [],\n    groupLabel: Option<string>\n  ): T {\n    const availableGroups = groups.map((group) => group.label);\n    const activeGroup = groups.find((group) => group.label === groupLabel);\n    if (groupLabel && !activeGroup) {\n      throw new SelectedGuardGroupDoesNotExistError(\n        groupLabel,\n        availableGroups\n      );\n    }\n\n    if (groups.length === 0) {\n      return guards;\n    }\n\n    if (!activeGroup) {\n      throw new GuardGroupRequiredError(availableGroups);\n    }\n\n    const activeGroupGuardsWithoutNullGuards = Object.fromEntries(\n      Object.entries(activeGroup.guards).filter(([, v]) => v != null)\n    ) as Partial<T>;\n\n    return {\n      ...guards,\n      ...activeGroupGuardsWithoutNullGuards,\n    };\n  }\n\n  /**\n   * Parses the arguments and remaining accounts of\n   * all relevant guards for the mint instruction.\n   */\n  parseMintSettings<\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    MintSettings extends CandyGuardsMintSettings = {}\n  >(\n    candyMachine: PublicKey,\n    candyGuard: CandyGuard<Settings>,\n    owner: PublicKey,\n    payer: Signer,\n    mint: Signer,\n    guardMintSettings: Partial<MintSettings>,\n    groupLabel: Option<string>,\n    programs: Program[] = []\n  ): {\n    arguments: Buffer;\n    accountMetas: AccountMeta[];\n    signers: Signer[];\n  } {\n    const availableGuards = this.forCandyGuardProgram(programs);\n    const guardSettings = this.resolveGroupSettings(\n      candyGuard.guards,\n      candyGuard.groups,\n      groupLabel\n    );\n    const initialAccumulator = {\n      arguments: Buffer.from([]),\n      accountMetas: [] as AccountMeta[],\n      signers: [] as Signer[],\n    };\n\n    return availableGuards.reduce((acc, guard) => {\n      const settings = guardSettings[guard.name] ?? null;\n      const mintSettings = guardMintSettings[guard.name] ?? null;\n      if (!guard.mintSettingsParser || !settings) return acc;\n\n      const parsedSettings = guard.mintSettingsParser({\n        metaplex: this.metaplex,\n        settings,\n        mintSettings,\n        owner,\n        payer,\n        mint,\n        candyMachine,\n        candyGuard: candyGuard.address,\n        candyGuardAuthority: candyGuard.authorityAddress,\n        programs,\n      });\n\n      const accounts = this.getAccountMetas(parsedSettings.remainingAccounts);\n      const signers = this.getSigners(parsedSettings.remainingAccounts);\n      acc.arguments = Buffer.concat([acc.arguments, parsedSettings.arguments]);\n      acc.accountMetas.push(...accounts);\n      acc.signers.push(...signers);\n      return acc;\n    }, initialAccumulator);\n  }\n\n  /**\n   * Parses the arguments and remaining accounts of\n   * the requested guard for the route instruction.\n   */\n  parseRouteSettings<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    candyMachine: PublicKey,\n    candyGuard: CandyGuard<Settings>,\n    payer: Signer,\n    guard: Guard,\n    routeSettings: RouteSettings[Guard],\n    groupLabel: Option<string>,\n    programs: Program[] = []\n  ): {\n    arguments: Buffer;\n    accountMetas: AccountMeta[];\n    signers: Signer[];\n  } {\n    const guardManifest = this.get(guard);\n    if (!guardManifest.routeSettingsParser) {\n      throw new GuardRouteNotSupportedError(guard);\n    }\n\n    const guardSettings = this.resolveGroupSettings(\n      candyGuard.guards,\n      candyGuard.groups,\n      groupLabel\n    );\n    const settings = guardSettings[guard] ?? null;\n    if (!settings) {\n      throw new GuardNotEnabledError(guard, groupLabel);\n    }\n\n    const parsedSettings = guardManifest.routeSettingsParser({\n      metaplex: this.metaplex,\n      settings,\n      routeSettings,\n      payer,\n      candyMachine,\n      candyGuard: candyGuard.address,\n      candyGuardAuthority: candyGuard.authorityAddress,\n      programs,\n    });\n\n    return {\n      arguments: parsedSettings.arguments,\n      accountMetas: this.getAccountMetas(parsedSettings.remainingAccounts),\n      signers: this.getSigners(parsedSettings.remainingAccounts),\n    };\n  }\n\n  /** @internal */\n  protected getAccountMetas(\n    remainingAccounts: CandyGuardsRemainingAccount[]\n  ): AccountMeta[] {\n    return remainingAccounts.map((account) => ({\n      pubkey: account.isSigner ? account.address.publicKey : account.address,\n      isSigner: account.isSigner,\n      isWritable: account.isWritable,\n    }));\n  }\n\n  /** @internal */\n  protected getSigners(\n    remainingAccounts: CandyGuardsRemainingAccount[]\n  ): Signer[] {\n    return remainingAccounts\n      .filter((account) => account.isSigner)\n      .map((account) => account.address as Signer);\n  }\n\n  /** @internal */\n  protected assertGuardsAreRegistered<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    guards: Partial<T>,\n    groups: { label: string; guards: Partial<T> }[],\n    availableGuardNames: string[]\n  ): void {\n    const guardNames = new Set<string>();\n    const addGuardSet = (guardSet: Partial<T>) => {\n      Object.keys(guardSet).forEach((name) => {\n        if (!!guardSet[name]) {\n          guardNames.add(name);\n        }\n      });\n    };\n\n    addGuardSet(guards);\n    groups.forEach((group) => addGuardSet(group.guards));\n\n    guardNames.forEach((name) => {\n      if (!availableGuardNames.includes(name)) {\n        throw new UnregisteredCandyGuardError(name);\n      }\n    });\n  }\n}\n","import { Buffer } from 'buffer';\nimport type { Metaplex } from '@/Metaplex';\nimport { Pda, Program, PublicKey } from '@/types';\n\n/**\n * This client allows you to build PDAs related to the Candy Machine module.\n *\n * @see {@link CandyMachineClient}\n * @group Module Pdas\n */\nexport class CandyMachinePdasClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Finds the Authority PDA for the given Candy Machine. */\n  authority({\n    candyMachine,\n    programs,\n  }: {\n    /** The Candy Machine address */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyMachine(programs);\n    return Pda.find(program.address, [\n      Buffer.from('candy_machine', 'utf8'),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /** Finds the Candy Guard PDA for the given base address it derives from. */\n  candyGuard({\n    base,\n    programs,\n  }: {\n    /** The base address which the Candy Guard PDA derives from. */\n    base: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('candy_guard', 'utf8'),\n      base.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Mint Limit Counter PDA that keeps track of how many\n   * NFTs where minted by a given user on a given Candy Machine.\n   */\n  mintLimitCounter({\n    id,\n    user,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** A unique identifier in the context of a Candy Machine/Candy Guard combo. */\n    id: number;\n    /** The address of the wallet trying to mint. */\n    user: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('mint_limit', 'utf8'),\n      Buffer.from([id]),\n      user.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Allow List Proof PDA that keeps track of whether a user\n   * has provided the correct Merkle Proof for the given Merkle Root.\n   */\n  merkleProof({\n    merkleRoot,\n    user,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** The Merkle Root used when verifying the user. */\n    merkleRoot: Uint8Array;\n    /** The address of the wallet trying to mint. */\n    user: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('allow_list', 'utf8'),\n      merkleRoot,\n      user.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Freeze PDA used as an escrow account by\n   * the freezeSolPayment and freezeTokenPayment guards.\n   */\n  freezeEscrow({\n    destination,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** The wallet that will eventually receive the funds. */\n    destination: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('freeze_escrow', 'utf8'),\n      destination.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n}\n","import {\n  CandyGuard as MplCandyGuard,\n  candyGuardBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport { CANDY_GUARD_DATA } from '../constants';\nimport { CandyGuardsSettings } from '../guards';\nimport {\n  AccountInfo,\n  assertModel,\n  createSerializerFromSolitaType,\n  deserializeAccount,\n  isModel,\n  Model,\n  Pda,\n  PublicKey,\n  toAccountInfo,\n  UnparsedAccount,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n/** @group Models */\nexport type CandyGuard<T extends CandyGuardsSettings> = Model<'candyGuard'> & {\n  /** The PDA address of the Candy Guard account. */\n  readonly address: Pda;\n\n  /** Blockchain data of the Candy Guard account. */\n  readonly accountInfo: AccountInfo;\n\n  /** The address used to derive the Candy Guard's PDA. */\n  readonly baseAddress: PublicKey;\n\n  /** The address allowed to update the Candy Guard account */\n  readonly authorityAddress: PublicKey;\n\n  /**\n   * This object provides the settings for all guards in the Candy Guard.\n   *\n   * If a guard is set to `null`, it is disabled. Otherwise, it is enabled and\n   * the object contains the settings for that guard.\n   */\n  readonly guards: T;\n\n  /**\n   * This parameter allows us to create multiple minting groups that have their\n   * own set of requirements — i.e. guards.\n   *\n   * When groups are provided, the `guards` parameter becomes a set of default\n   * guards that will be applied to all groups. If a specific group enables\n   * a guard that is also present in the default guards, the group's guard\n   * will override the default guard.\n   *\n   * Each group functions the same way as the `guards` parameter, where a guard\n   * is enabled if and only if it is not `null`.\n   */\n  readonly groups: { label: string; guards: T }[];\n};\n\n/** @group Model Helpers */\nexport const isCandyGuard = <T extends CandyGuardsSettings>(\n  value: any\n): value is CandyGuard<T> => isModel('candyGuard', value);\n\n/** @group Model Helpers */\nexport function assertCandyGuard<T extends CandyGuardsSettings>(\n  value: any\n): asserts value is CandyGuard<T> {\n  assertModel(isCandyGuard(value), `Expected CandyGuard model`);\n}\n\n/** @group Model Helpers */\nexport const toCandyGuard = <T extends CandyGuardsSettings>(\n  account: UnparsedAccount,\n  metaplex: Metaplex\n): CandyGuard<T> => {\n  const candyGuardSerializer = createSerializerFromSolitaType(\n    MplCandyGuard,\n    candyGuardBeet.description\n  );\n  const parsedCandyGuard = deserializeAccount(account, candyGuardSerializer);\n\n  const { guards, groups } = metaplex\n    .candyMachines()\n    .guards()\n    .deserializeSettings<T>(\n      account.data.slice(CANDY_GUARD_DATA),\n      account.owner\n    );\n\n  return {\n    model: 'candyGuard',\n    address: new Pda(parsedCandyGuard.publicKey, parsedCandyGuard.data.bump),\n    accountInfo: toAccountInfo(account),\n    baseAddress: parsedCandyGuard.data.base,\n    authorityAddress: parsedCandyGuard.data.authority,\n    guards,\n    groups,\n  };\n};\n","import { CandyGuard as MplCandyGuard } from '@metaplex-foundation/mpl-candy-guard';\nimport { PublicKey } from '@solana/web3.js';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { CandyGuard, toCandyGuard } from '../models';\nimport { GpaBuilder } from '@/utils';\nimport { Operation, OperationHandler, OperationScope } from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyGuardsByAuthorityOperation' as const;\n\n/**\n * Find all Candy Guards matching by a given authority.\n *\n * ```ts\n * const candyGuards = await metaplex\n *   .candyMachines()\n *   .findAllCandyGuardsByAuthority({ authority: new PublicKey('...') });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyGuardsByAuthorityOperation =\n  _findCandyGuardsByAuthorityOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _findCandyGuardsByAuthorityOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  input: FindCandyGuardsByAuthorityInput\n): FindCandyGuardsByAuthorityOperation<T> {\n  return { key: Key, input };\n}\n_findCandyGuardsByAuthorityOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyGuardsByAuthorityOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, FindCandyGuardsByAuthorityInput, CandyGuard<T>[]>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyGuardsByAuthorityInput = {\n  /** The authority to filter Candy Guards by. */\n  authority: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyGuardsByAuthorityOperationHandler: OperationHandler<FindCandyGuardsByAuthorityOperation> =\n  {\n    handle: async <T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: FindCandyGuardsByAuthorityOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const { authority } = operation.input;\n      const { programs, commitment } = scope;\n      const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n      const query = MplCandyGuard.gpaBuilder(\n        candyGuardProgram.address\n      ).addFilter('authority', authority);\n\n      const gpaBuilder = new GpaBuilder(metaplex, candyGuardProgram.address);\n      gpaBuilder.mergeConfig({ ...query.config, commitment });\n\n      return gpaBuilder.getAndMap((account) => toCandyGuard(account, metaplex));\n    },\n  };\n","import { AddressGateGuardSettings } from './addressGate';\nimport {\n  AllowListGuardRouteSettings,\n  AllowListGuardSettings,\n} from './allowList';\nimport { BotTaxGuardSettings } from './botTax';\nimport {\n  CandyGuardsMintSettings,\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n} from './core';\nimport { EndDateGuardSettings } from './endDate';\nimport {\n  GatekeeperGuardMintSettings,\n  GatekeeperGuardSettings,\n} from './gatekeeper';\nimport { MintLimitGuardSettings } from './mintLimit';\nimport { NftBurnGuardMintSettings, NftBurnGuardSettings } from './nftBurn';\nimport { NftGateGuardMintSettings, NftGateGuardSettings } from './nftGate';\nimport {\n  NftPaymentGuardMintSettings,\n  NftPaymentGuardSettings,\n} from './nftPayment';\nimport { ProgramGateGuardSettings } from './programGate';\nimport { RedeemedAmountGuardSettings } from './redeemedAmount';\nimport { SolPaymentGuardSettings } from './solPayment';\nimport { StartDateGuardSettings } from './startDate';\nimport {\n  ThirdPartySignerGuardMintSettings,\n  ThirdPartySignerGuardSettings,\n} from './thirdPartySigner';\nimport { TokenBurnGuardSettings } from './tokenBurn';\nimport { TokenGateGuardSettings } from './tokenGate';\nimport { TokenPaymentGuardSettings } from './tokenPayment';\nimport {\n  FreezeSolPaymentGuardRouteSettings,\n  FreezeSolPaymentGuardSettings,\n} from './freezeSolPayment';\nimport {\n  FreezeTokenPaymentGuardRouteSettings,\n  FreezeTokenPaymentGuardSettings,\n} from './freezeTokenPayment';\nimport { Option } from '@/utils';\n\n/**\n * The settings for all default Candy Machine guards.\n */\nexport type DefaultCandyGuardSettings = CandyGuardsSettings & {\n  botTax: Option<BotTaxGuardSettings>;\n  solPayment: Option<SolPaymentGuardSettings>;\n  tokenPayment: Option<TokenPaymentGuardSettings>;\n  startDate: Option<StartDateGuardSettings>;\n  thirdPartySigner: Option<ThirdPartySignerGuardSettings>;\n  tokenGate: Option<TokenGateGuardSettings>;\n  gatekeeper: Option<GatekeeperGuardSettings>;\n  endDate: Option<EndDateGuardSettings>;\n  allowList: Option<AllowListGuardSettings>;\n  mintLimit: Option<MintLimitGuardSettings>;\n  nftPayment: Option<NftPaymentGuardSettings>;\n  redeemedAmount: Option<RedeemedAmountGuardSettings>;\n  addressGate: Option<AddressGateGuardSettings>;\n  nftGate: Option<NftGateGuardSettings>;\n  nftBurn: Option<NftBurnGuardSettings>;\n  tokenBurn: Option<TokenBurnGuardSettings>;\n  freezeSolPayment: Option<FreezeSolPaymentGuardSettings>;\n  freezeTokenPayment: Option<FreezeTokenPaymentGuardSettings>;\n  programGate: Option<ProgramGateGuardSettings>;\n};\n\n/**\n * The mint settings for all default Candy Machine guards.\n */\nexport type DefaultCandyGuardMintSettings = CandyGuardsMintSettings & {\n  // botTax: no mint settings\n  // solPayment: no mint settings\n  // tokenPayment: no mint settings\n  // startDate: no mint settings\n  thirdPartySigner: Option<ThirdPartySignerGuardMintSettings>;\n  // tokenGate: no mint settings\n  gatekeeper: Option<GatekeeperGuardMintSettings>;\n  // endDate: no mint settings\n  // allowList: no mint settings\n  // mintLimit: no mint settings\n  nftPayment: Option<NftPaymentGuardMintSettings>;\n  // redeemedAmount: no mint settings\n  // addressGate: no mint settings\n  nftGate: Option<NftGateGuardMintSettings>;\n  nftBurn: Option<NftBurnGuardMintSettings>;\n  // tokenBurn: no mint settings\n  // freezeSolPayment: no mint settings\n  // freezeTokenPayment: no mint settings\n  // programGate: no mint settings\n};\n\n/**\n * The mint settings for all default Candy Machine guards.\n */\nexport type DefaultCandyGuardRouteSettings = CandyGuardsRouteSettings & {\n  // botTax: no route settings\n  // solPayment: no route settings\n  // tokenPayment: no route settings\n  // startDate: no route settings\n  // thirdPartySigner: no route settings\n  // tokenGate: no route settings\n  // gatekeeper: no route settings\n  // endDate: no route settings\n  allowList: AllowListGuardRouteSettings;\n  // mintLimit: no route settings\n  // nftPayment: no route settings\n  // redeemedAmount: no route settings\n  // addressGate: no route settings\n  // nftGate: no route settings\n  // nftBurn: no route settings\n  // tokenBurn: no route settings\n  freezeSolPayment: FreezeSolPaymentGuardRouteSettings;\n  freezeTokenPayment: FreezeTokenPaymentGuardRouteSettings;\n  // programGate: no route settings\n};\n\n/** @internal */\nexport const defaultCandyGuardNames: string[] = [\n  'botTax',\n  'solPayment',\n  'tokenPayment',\n  'startDate',\n  'thirdPartySigner',\n  'tokenGate',\n  'gatekeeper',\n  'endDate',\n  'allowList',\n  'mintLimit',\n  'nftPayment',\n  'redeemedAmount',\n  'addressGate',\n  'nftGate',\n  'nftBurn',\n  'tokenBurn',\n  'freezeSolPayment',\n  'freezeTokenPayment',\n  'programGate',\n];\n\n/** @internal */\nexport const emptyDefaultCandyGuardSettings: {\n  [key in keyof DefaultCandyGuardSettings]: null;\n} = defaultCandyGuardNames.reduce((acc, name) => {\n  acc[name] = null;\n  return acc;\n}, {} as { [key in keyof DefaultCandyGuardSettings]: null });\n","import {\n  cusper as defaultCandyGuardCusper,\n  PROGRAM_ID as DEFAULT_CANDY_GUARD_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport {\n  cusper as candyMachineCusper,\n  PROGRAM_ID as CANDY_MACHINE_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-candy-machine-core';\nimport { defaultCandyGuardNames } from './guards';\nimport { assert } from '@/utils';\nimport { ErrorWithLogs, Program, PublicKey } from '@/types';\n\n/** @group Programs */\nexport const candyMachineProgram: Program = {\n  name: 'CandyMachineProgram',\n  address: CANDY_MACHINE_PROGRAM_ID,\n  errorResolver: (error: ErrorWithLogs) =>\n    candyMachineCusper.errorFromProgramLogs(error.logs, false),\n};\n\n/** @group Programs */\nexport type CandyGuardProgram = Program & { availableGuards: string[] };\n\nexport const isCandyGuardProgram = (\n  value: Program\n): value is CandyGuardProgram =>\n  typeof value === 'object' && 'availableGuards' in value;\n\nexport function assertCandyGuardProgram(\n  value: Program\n): asserts value is CandyGuardProgram {\n  assert(isCandyGuardProgram(value), `Expected CandyGuardProgram model`);\n}\n\n/** @group Programs */\nexport const defaultCandyGuardProgram: CandyGuardProgram = {\n  name: 'CandyGuardProgram',\n  address: DEFAULT_CANDY_GUARD_PROGRAM_ID,\n  errorResolver: (error: ErrorWithLogs) =>\n    defaultCandyGuardCusper.errorFromProgramLogs(error.logs, false),\n  availableGuards: defaultCandyGuardNames,\n};\n\n/** @group Programs */\nexport const gatewayProgram: Program = {\n  name: 'GatewayProgram',\n  address: new PublicKey('gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs'),\n};\n","import { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { CandyMachine, toCandyGuard, toCandyMachine } from '../models';\nimport { assertCandyGuardProgram } from '../programs';\nimport {\n  assertAccountExists,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachineByAddressOperation' as const;\n\n/**\n * Find an existing Candy Machine by its address.\n *\n * ```ts\n * const candyMachine = await metaplex\n *   .candyMachines()\n *   .findbyAddress({ address };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyMachineByAddressOperation =\n  _findCandyMachineByAddressOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _findCandyMachineByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  input: FindCandyMachineByAddressInput\n): FindCandyMachineByAddressOperation<T> {\n  return { key: Key, input };\n}\n_findCandyMachineByAddressOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyMachineByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, FindCandyMachineByAddressInput, CandyMachine<T>>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyMachineByAddressInput = {\n  /** The Candy Machine address. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyMachineByAddressOperationHandler: OperationHandler<FindCandyMachineByAddressOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: FindCandyMachineByAddressOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) {\n      const { address } = operation.input;\n      const { commitment, programs } = scope;\n      const potentialCandyGuardAddress = metaplex\n        .candyMachines()\n        .pdas()\n        .candyGuard({ base: address, programs });\n      const [candyMachineAccount, potentialCandyGuardAccount] = await metaplex\n        .rpc()\n        .getMultipleAccounts([address, potentialCandyGuardAddress], commitment);\n      scope.throwIfCanceled();\n\n      assertAccountExists(candyMachineAccount, 'CandyMachine');\n      const candyMachine = toCandyMachine<T>(candyMachineAccount);\n      const mintAuthority = candyMachine.mintAuthorityAddress;\n\n      // Optimisation that tries to load both the Candy Machine\n      // And the Candy Guard in one RPC call assuming the Candy\n      // Machine's address is the base address of the Candy Guard.\n      if (\n        potentialCandyGuardAccount.exists &&\n        potentialCandyGuardAccount.publicKey.equals(mintAuthority)\n      ) {\n        return {\n          ...candyMachine,\n          candyGuard: toCandyGuard<T>(potentialCandyGuardAccount, metaplex),\n        };\n      }\n\n      // If the Candy Machine's mint authority is not a PDA,\n      // it cannot have an associated Candy Guard.\n      // TODO(loris): Does not seem to work when the Candy Guard does not derive from the Candy Machine.\n      if (PublicKey.isOnCurve(mintAuthority)) {\n        return candyMachine;\n      }\n\n      // Fetch the content of the mint authority PDA.\n      const mintAuthorityAccount = await metaplex\n        .rpc()\n        .getAccount(mintAuthority, commitment);\n      scope.throwIfCanceled();\n\n      try {\n        // Identity the program owner as a Candy Guard program\n        // and parse the Candy Guard accordingly.\n        assertAccountExists(mintAuthorityAccount);\n        const program = metaplex.programs().get(mintAuthorityAccount.owner);\n        assertCandyGuardProgram(program);\n\n        return {\n          ...candyMachine,\n          candyGuard: toCandyGuard<T>(mintAuthorityAccount, metaplex),\n        };\n      } catch (error) {\n        // If anything goes wrong, assume there is no Candy Guard\n        // attached to this Candy Machine.\n        return candyMachine;\n      }\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { CandyGuard, toCandyGuard } from '../models';\nimport {\n  assertAccountExists,\n  Operation,\n  OperationHandler,\n  OperationScope,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyGuardByAddressOperation' as const;\n\n/**\n * Find an existing Candy Guard by its address.\n *\n * ```ts\n * const candyGuard = await metaplex\n *   .candyMachines()\n *   .findCandyGuardbyAddress({ address };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyGuardByAddressOperation =\n  _findCandyGuardByAddressOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _findCandyGuardByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(input: FindCandyGuardByAddressInput): FindCandyGuardByAddressOperation<T> {\n  return { key: Key, input };\n}\n_findCandyGuardByAddressOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyGuardByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, FindCandyGuardByAddressInput, CandyGuard<T>>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyGuardByAddressInput = {\n  /** The Candy Guard address. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyGuardByAddressOperationHandler: OperationHandler<FindCandyGuardByAddressOperation> =\n  {\n    handle: async <T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: FindCandyGuardByAddressOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CandyGuard<T>> => {\n      const { address } = operation.input;\n      const account = await metaplex\n        .rpc()\n        .getAccount(address, scope.commitment);\n      assertAccountExists(account);\n\n      return toCandyGuard<T>(account, metaplex);\n    },\n  };\n","import { CandyMachineBuildersClient } from './CandyMachineBuildersClient';\nimport { CandyMachineGuardsClient } from './CandyMachineGuardsClient';\nimport { CandyMachinePdasClient } from './CandyMachinePdasClient';\nimport {\n  CandyGuardsMintSettings,\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardMintSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from './guards';\nimport { CandyGuard, CandyMachine, isCandyMachine } from './models';\nimport {\n  CallCandyGuardRouteInput,\n  callCandyGuardRouteOperation,\n  CreateCandyGuardInput,\n  createCandyGuardOperation,\n  CreateCandyMachineInput,\n  createCandyMachineOperation,\n  DeleteCandyGuardInput,\n  deleteCandyGuardOperation,\n  DeleteCandyMachineInput,\n  deleteCandyMachineOperation,\n  FindCandyGuardByAddressInput,\n  findCandyGuardByAddressOperation,\n  FindCandyGuardsByAuthorityInput,\n  findCandyGuardsByAuthorityOperation,\n  FindCandyMachineByAddressInput,\n  findCandyMachineByAddressOperation,\n  InsertCandyMachineItemsInput,\n  insertCandyMachineItemsOperation,\n  MintFromCandyMachineInput,\n  mintFromCandyMachineOperation,\n  UnwrapCandyGuardInput,\n  unwrapCandyGuardOperation,\n  UpdateCandyGuardInput,\n  updateCandyGuardOperation,\n  UpdateCandyMachineInput,\n  updateCandyMachineOperation,\n  WrapCandyGuardInput,\n  wrapCandyGuardOperation,\n} from './operations';\nimport {\n  UpdateCandyGuardAuthorityInput,\n  updateCandyGuardAuthorityOperation,\n} from './operations/updateCandyGuardAuthority';\nimport { OperationOptions, toPublicKey } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * This is a client for the Candy Machine V3 module.\n *\n * It enables us to interact with the Candy Machine V3 and Candy Guard programs\n * in order to create, update, delete and mint from Candy Machines as well as\n * registering your own custom Candy Guards.\n *\n * You may access this client via the `candyMachines()` method of your `Metaplex` instance.\n *\n * ```ts\n * const candyMachineClient = metaplex.candyMachines();\n * ```\n *\n * @example\n * You can create a new Candy Machine with minimum input like so.\n * By default, the current identity of the Metaplex instance will be\n * the authority of the Candy Machine and it will immediately create\n * a Candy Guard linked to the new Candy Machine.\n *\n * ```ts\n *  const { candyMachine } = await metaplex\n *    .candyMachines()\n *    .create({\n *      itemsAvailable: toBigNumber(5000),\n *      sellerFeeBasisPoints: 333, // 3.33%\n *      collection: {\n *        address: collectionNft.address,\n *        updateAuthority: collectionUpdateAuthority,\n *      },\n *    });\n * ```\n *\n * @see {@link CandyGuard} The `CandyGuard` model\n * @group Modules\n */\nexport class CandyMachineClient {\n  protected readonly guardsClient: CandyMachineGuardsClient;\n\n  constructor(readonly metaplex: Metaplex) {\n    this.guardsClient = new CandyMachineGuardsClient(metaplex);\n  }\n\n  /**\n   * You may use the `guards()` client to access the default guards\n   * available as well as register your own guards.\n   *\n   * ```ts\n   * const guardsClient = metaplex.candyMachines().guards();\n   * ```\n   */\n  guards() {\n    return this.guardsClient;\n  }\n\n  /**\n   * You may use the `builders()` client to access the\n   * underlying Transaction Builders of this module.\n   *\n   * ```ts\n   * const buildersClient = metaplex.candyMachines().builders();\n   * ```\n   */\n  builders() {\n    return new CandyMachineBuildersClient(this.metaplex);\n  }\n\n  /**\n   * You may use the `pdas()` client to build PDAs related to this module.\n   *\n   * ```ts\n   * const pdasClient = metaplex.candyMachines().pdas();\n   * ```\n   */\n  pdas() {\n    return new CandyMachinePdasClient(this.metaplex);\n  }\n\n  /** {@inheritDoc callCandyGuardRouteOperation} */\n  callGuardRoute<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    input: CallCandyGuardRouteInput<\n      Guard,\n      Settings extends undefined ? DefaultCandyGuardSettings : Settings,\n      RouteSettings extends undefined\n        ? DefaultCandyGuardRouteSettings\n        : RouteSettings\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(callCandyGuardRouteOperation(input), options);\n  }\n\n  /** {@inheritDoc createCandyMachineOperation} */\n  create<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: CreateCandyMachineInput<\n      T extends undefined ? DefaultCandyGuardSettings : T\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(createCandyMachineOperation(input), options);\n  }\n\n  /** {@inheritDoc createCandyGuardOperation} */\n  createCandyGuard<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: CreateCandyGuardInput<\n      T extends undefined ? DefaultCandyGuardSettings : T\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(createCandyGuardOperation(input), options);\n  }\n\n  /** {@inheritDoc deleteCandyMachineOperation} */\n  delete(input: DeleteCandyMachineInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(deleteCandyMachineOperation(input), options);\n  }\n\n  /** {@inheritDoc deleteCandyGuardOperation} */\n  deleteCandyGuard(input: DeleteCandyGuardInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(deleteCandyGuardOperation(input), options);\n  }\n\n  /** {@inheritDoc findCandyGuardsByAuthorityOperation} */\n  findAllCandyGuardsByAuthority<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(input: FindCandyGuardsByAuthorityInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findCandyGuardsByAuthorityOperation<T>(input), options);\n  }\n\n  /** {@inheritDoc findCandyMachineByAddressOperation} */\n  findByAddress<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: FindCandyMachineByAddressInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findCandyMachineByAddressOperation<T>(input), options);\n  }\n\n  /** {@inheritDoc findCandyGuardByAddressOperation} */\n  findCandyGuardByAddress<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(input: FindCandyGuardByAddressInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findCandyGuardByAddressOperation<T>(input), options);\n  }\n\n  /**\n   * Helper method that fetches a Candy Guard via the base\n   * address used to derived its PDA.\n   *\n   * ```ts\n   * const candyGuard = await metaplex\n   *   .candyMachines()\n   *   .findCandyGuardByBaseAddress({ address: base });\n   * ```\n   */\n  findCandyGuardByBaseAddress<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(input: FindCandyGuardByAddressInput, options?: OperationOptions) {\n    const address = this.pdas().candyGuard({ base: input.address });\n    return this.findCandyGuardByAddress<T>({ ...input, address }, options);\n  }\n\n  /** {@inheritDoc insertCandyMachineItemsOperation} */\n  insertItems(input: InsertCandyMachineItemsInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(insertCandyMachineItemsOperation(input), options);\n  }\n\n  /** {@inheritDoc mintFromCandyMachineOperation} */\n  mint<\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n  >(\n    input: MintFromCandyMachineInput<\n      Settings extends undefined ? DefaultCandyGuardSettings : Settings,\n      MintSettings extends undefined\n        ? DefaultCandyGuardMintSettings\n        : MintSettings\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(mintFromCandyMachineOperation(input), options);\n  }\n\n  /**\n   * Helper method that refetches a given Candy Machine or Candy Guard.\n   *\n   * ```ts\n   * const candyMachine = await metaplex.candyMachines().refresh(candyMachine);\n   * const candyGuard = await metaplex.candyMachines().refresh(candyGuard);\n   * ```\n   */\n  async refresh<\n    T extends CandyGuardsSettings,\n    M extends CandyMachine<T> | CandyGuard<T>\n  >(model: M, options?: OperationOptions): Promise<M> {\n    const input = { address: toPublicKey(model) };\n    const refreshedModel = isCandyMachine(model)\n      ? await this.findByAddress<T>(input, options)\n      : await this.findCandyGuardByAddress<T>(input, options);\n\n    return refreshedModel as M;\n  }\n\n  /** {@inheritDoc unwrapCandyGuardOperation} */\n  unwrapCandyGuard(input: UnwrapCandyGuardInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(unwrapCandyGuardOperation(input), options);\n  }\n\n  /** {@inheritDoc updateCandyMachineOperation} */\n  update<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: UpdateCandyMachineInput<\n      T extends undefined ? DefaultCandyGuardSettings : T\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(updateCandyMachineOperation(input), options);\n  }\n\n  /** {@inheritDoc updateCandyGuardOperation} */\n  updateCandyGuard<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    input: UpdateCandyGuardInput<\n      T extends undefined ? DefaultCandyGuardSettings : T\n    >,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(updateCandyGuardOperation(input), options);\n  }\n\n  /** {@inheritDoc updateCandyGuardAuthorityOperation} */\n  updateCandyGuardAuthority(\n    input: UpdateCandyGuardAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(updateCandyGuardAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc wrapCandyGuardOperation} */\n  wrapCandyGuard(input: WrapCandyGuardInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(wrapCandyGuardOperation(input), options);\n  }\n}\n","import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport {\n  FreezeInstruction,\n  FreezeSolPayment,\n  freezeSolPaymentBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport {\n  MintOwnerMustBeMintPayerError,\n  UnrecognizePathForRouteInstructionError,\n} from '../errors';\nimport {\n  CandyGuardManifest,\n  CandyGuardsRemainingAccount,\n  RouteSettingsParserInput,\n} from './core';\nimport { assert } from '@/utils';\nimport {\n  createSerializerFromBeet,\n  lamports,\n  mapSerializer,\n  PublicKey,\n  Signer,\n  SolAmount,\n} from '@/types';\n\n/**\n * The freezeSolPayment guard allows minting frozen NFTs by charging\n * the payer an amount in SOL. Frozen NFTs cannot be transferred\n * or listed on any marketplaces until thawed.\n *\n * The funds are transferred to a freeze escrow until all NFTs are thaw,\n * at which point, they can be transferred (unlocked) to the configured\n * destination account.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link FreezeSolPaymentGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type FreezeSolPaymentGuardSettings = {\n  /** The amount in SOL to charge for. */\n  amount: SolAmount;\n\n  /** The configured destination address to send the funds to. */\n  destination: PublicKey;\n};\n\n/**\n * The settings for the freezeSolPayment guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Initialize\n * The `initialize` path creates the freeze escrow account that will\n * hold the funds until all NFTs are thawed. It must be called before\n * any NFTs can be minted.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeSolPayment',\n *   settings: {\n *     path: 'initialize',\n *     period: 15 * 24 * 60 * 60, // 15 days.\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * ## Thaw\n * The `thaw` path unfreezes one NFT if one of the following conditions are met:\n * - All NFTs have been minted.\n * - The configured period has elapsed (max 30 days).\n * - The Candy Machine account was deleted.\n *\n * Anyone can call this instruction. Since the funds are not transferrable\n * until all NFTs are thawed, it creates an incentive for the treasury to\n * thaw all NFTs as soon as possible.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeSolPayment',\n *   settings: {\n *     path: 'thaw',\n *     nftMint: nftToThaw.address,\n *     nftOwner: nftToThaw.token.ownerAddress,\n *   },\n * });\n * ```\n *\n * ## Unlock Funds\n * The `unlockFunds` path transfers all of the escrow funds to the\n * configured destination address once all NFTs have been thawed.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeSolPayment',\n *   settings: {\n *     path: 'unlockFunds',\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * @see {@link FreezeSolPaymentGuardSettings} for more\n * information on the freezeSolPayment guard itself.\n */\nexport type FreezeSolPaymentGuardRouteSettings =\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'initialize';\n\n      /** The freeze period in seconds (maximum 30 days). */\n      period: number;\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'thaw';\n\n      /** The mint address of the NFT to thaw. */\n      nftMint: PublicKey;\n\n      /** The owner address of the NFT to thaw. */\n      nftOwner: PublicKey;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'unlockFunds';\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    };\n\n/** @internal */\nexport const freezeSolPaymentGuardManifest: CandyGuardManifest<\n  FreezeSolPaymentGuardSettings,\n  {},\n  FreezeSolPaymentGuardRouteSettings\n> = {\n  name: 'freezeSolPayment',\n  settingsBytes: 40,\n  settingsSerializer: mapSerializer<\n    FreezeSolPayment,\n    FreezeSolPaymentGuardSettings\n  >(\n    createSerializerFromBeet(freezeSolPaymentBeet),\n    (settings) => ({\n      amount: lamports(settings.lamports),\n      destination: settings.destination,\n    }),\n    (settings) => ({\n      lamports: settings.amount.basisPoints,\n      destination: settings.destination,\n    })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    owner,\n    payer,\n    mint,\n    candyMachine,\n    candyGuard,\n    programs,\n  }) => {\n    if (!owner.equals(payer.publicKey)) {\n      throw new MintOwnerMustBeMintPayerError('freezeSolPayment');\n    }\n\n    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n      destination: settings.destination,\n      candyMachine,\n      candyGuard,\n      programs,\n    });\n    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mint.publicKey,\n      owner: payer.publicKey,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: freezeEscrow,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: nftAta,\n          isWritable: false,\n        },\n      ],\n    };\n  },\n  routeSettingsParser: (input) => {\n    switch (input.routeSettings.path) {\n      case 'initialize':\n        return initializeRouteInstruction(input);\n      case 'thaw':\n        return thawRouteInstruction(input);\n      case 'unlockFunds':\n        return unlockFundsRouteInstruction(input);\n      default:\n        throw new UnrecognizePathForRouteInstructionError(\n          'freezeSolPayment',\n          // @ts-ignore\n          input.routeSettings.path\n        );\n    }\n  },\n};\n\nfunction initializeRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeSolPaymentGuardSettings,\n  FreezeSolPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'initialize');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destination,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  const args = Buffer.alloc(9);\n  beet.u8.write(args, 0, FreezeInstruction.Initialize);\n  beet.u64.write(args, 1, routeSettings.period);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction thawRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeSolPaymentGuardSettings,\n  FreezeSolPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'thaw');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destination,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: routeSettings.nftMint,\n    owner: routeSettings.nftOwner,\n    programs,\n  });\n  const nftEdition = metaplex.nfts().pdas().masterEdition({\n    mint: routeSettings.nftMint,\n    programs,\n  });\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.Thaw);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftMint,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftOwner,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: nftAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: nftEdition,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenMetadataProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction unlockFundsRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeSolPaymentGuardSettings,\n  FreezeSolPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'unlockFunds');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destination,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: settings.destination,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n","import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport {\n  FreezeInstruction,\n  FreezeTokenPayment,\n  freezeTokenPaymentBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport {\n  MintOwnerMustBeMintPayerError,\n  UnrecognizePathForRouteInstructionError,\n} from '../errors';\nimport {\n  CandyGuardManifest,\n  CandyGuardsRemainingAccount,\n  RouteSettingsParserInput,\n} from './core';\nimport { assert } from '@/utils';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  PublicKey,\n  Signer,\n  SplTokenAmount,\n  token,\n} from '@/types';\n\n/**\n * The freezeTokenPayment guard allows minting frozen NFTs by charging\n * the payer a specific amount of tokens from a certain mint acount.\n * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.\n *\n * The funds are transferred to a freeze escrow until all NFTs are thaw,\n * at which point, they can be transferred (unlocked) to the configured\n * destination account.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link FreezeTokenPaymentGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type FreezeTokenPaymentGuardSettings = {\n  /** The mint address of the required tokens. */\n  mint: PublicKey;\n\n  /** The amount of tokens required to mint an NFT. */\n  amount: SplTokenAmount;\n\n  /** The associated token address to send the tokens to. */\n  destinationAta: PublicKey;\n};\n\n/**\n * The settings for the freezeTokenPayment guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Initialize\n * The `initialize` path creates the freeze escrow account that will\n * hold the funds until all NFTs are thawed. It must be called before\n * any NFTs can be minted.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'initialize',\n *     period: 15 * 24 * 60 * 60, // 15 days.\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * ## Thaw\n * The `thaw` path unfreezes one NFT if one of the following conditions are met:\n * - All NFTs have been minted.\n * - The configured period has elapsed (max 30 days).\n * - The Candy Machine account was deleted.\n *\n * Anyone can call this instruction. Since the funds are not transferrable\n * until all NFTs are thawed, it creates an incentive for the treasury to\n * thaw all NFTs as soon as possible.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'thaw',\n *     nftMint: nftToThaw.address,\n *     nftOwner: nftToThaw.token.ownerAddress,\n *   },\n * });\n * ```\n *\n * ## Unlock Funds\n * The `unlockFunds` path transfers all of the escrow funds to the\n * configured destination token address once all NFTs have been thawed.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'unlockFunds',\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * @see {@link FreezeTokenPaymentGuardSettings} for more\n * information on the freezeTokenPayment guard itself.\n */\nexport type FreezeTokenPaymentGuardRouteSettings =\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'initialize';\n\n      /** The freeze period in seconds (maximum 30 days). */\n      period: number;\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'thaw';\n\n      /** The mint address of the NFT to thaw. */\n      nftMint: PublicKey;\n\n      /** The owner address of the NFT to thaw. */\n      nftOwner: PublicKey;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'unlockFunds';\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    };\n\n/** @internal */\nexport const freezeTokenPaymentGuardManifest: CandyGuardManifest<\n  FreezeTokenPaymentGuardSettings,\n  {},\n  FreezeTokenPaymentGuardRouteSettings\n> = {\n  name: 'freezeTokenPayment',\n  settingsBytes: 72,\n  settingsSerializer: mapSerializer<\n    FreezeTokenPayment,\n    FreezeTokenPaymentGuardSettings\n  >(\n    createSerializerFromBeet(freezeTokenPaymentBeet),\n    (settings) => ({\n      mint: settings.mint,\n      amount: token(settings.amount),\n      destinationAta: settings.destinationAta,\n    }),\n    (settings) => ({\n      mint: settings.mint,\n      amount: settings.amount.basisPoints,\n      destinationAta: settings.destinationAta,\n    })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    owner,\n    payer,\n    mint: nftMint,\n    candyMachine,\n    candyGuard,\n    programs,\n  }) => {\n    if (!owner.equals(payer.publicKey)) {\n      throw new MintOwnerMustBeMintPayerError('freezeTokenPayment');\n    }\n\n    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n      destination: settings.destinationAta,\n      candyMachine,\n      candyGuard,\n      programs,\n    });\n    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftMint.publicKey,\n      owner: payer.publicKey,\n    });\n    const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: payer.publicKey,\n      programs,\n    });\n    const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: freezeEscrow,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: freezeEscrow,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: nftAta,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: tokenAddress,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: freezeAta,\n          isWritable: true,\n        },\n      ],\n    };\n  },\n  routeSettingsParser: (input) => {\n    switch (input.routeSettings.path) {\n      case 'initialize':\n        return initializeRouteInstruction(input);\n      case 'thaw':\n        return thawRouteInstruction(input);\n      case 'unlockFunds':\n        return unlockFundsRouteInstruction(input);\n      default:\n        throw new UnrecognizePathForRouteInstructionError(\n          'freezeTokenPayment',\n          // @ts-ignore\n          input.routeSettings.path\n        );\n    }\n  },\n};\n\nfunction initializeRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'initialize');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs,\n  });\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex\n    .programs()\n    .getAssociatedToken(programs);\n\n  const args = Buffer.alloc(9);\n  beet.u8.write(args, 0, FreezeInstruction.Initialize);\n  beet.u64.write(args, 1, routeSettings.period);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: freezeAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: settings.mint,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: associatedTokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: settings.destinationAta,\n        isWritable: true,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction thawRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'thaw');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: routeSettings.nftMint,\n    owner: routeSettings.nftOwner,\n    programs,\n  });\n  const nftEdition = metaplex.nfts().pdas().masterEdition({\n    mint: routeSettings.nftMint,\n    programs,\n  });\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.Thaw);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftMint,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftOwner,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: nftAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: nftEdition,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenMetadataProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction unlockFundsRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'unlockFunds');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs,\n  });\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: freezeAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: settings.destinationAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n","import { BotTax, botTaxBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  lamports,\n  mapSerializer,\n  SolAmount,\n} from '@/types';\n\n/**\n * The botTax guard charges a penalty for invalid transactions\n * in order to discourage bots from attempting to mint NFTs.\n *\n * This bot tax works in combinaison with other guards and\n * will trigger whenever a minting wallet attempts to mint\n * an NFT such that other guards would have rejected the mint.\n *\n * For example, if you have a startDate guard and a botTax guard,\n * anyone trying to mint before the defined start date will be\n * charged the bot tax instead of receiving a specific startDate error.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type BotTaxGuardSettings = {\n  /** The amount in SOL to charge for an invalid transaction. */\n  lamports: SolAmount;\n\n  /**\n   * Whether or not we should charge the bot tax when a mint instruction\n   * is not the last instruction of the transaction.\n   *\n   * This is useful if you want to prevent bots from adding extra instructions\n   * after minting to detect if a bot tax was charged and, in this case,\n   * throw an error to make the transaction fail and avoid the bot tax.\n   */\n  lastInstruction: boolean;\n};\n\n/** @internal */\nexport const botTaxGuardManifest: CandyGuardManifest<BotTaxGuardSettings> = {\n  name: 'botTax',\n  settingsBytes: 9,\n  settingsSerializer: mapSerializer<BotTax, BotTaxGuardSettings>(\n    createSerializerFromBeet(botTaxBeet),\n    (settings) => ({ ...settings, lamports: lamports(settings.lamports) }),\n    (settings) => ({ ...settings, lamports: settings.lamports.basisPoints })\n  ),\n};\n","import { Buffer } from 'buffer';\nimport {\n  SolPayment,\n  solPaymentBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  lamports,\n  mapSerializer,\n  PublicKey,\n  SolAmount,\n} from '@/types';\n\n/**\n * The solPayment guard is used to charge an\n * amount in SOL for the minted NFT.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type SolPaymentGuardSettings = {\n  /** The amount in SOL to charge for. */\n  amount: SolAmount;\n\n  /** The configured destination address to send the funds to. */\n  destination: PublicKey;\n};\n\n/** @internal */\nexport const solPaymentGuardManifest: CandyGuardManifest<SolPaymentGuardSettings> =\n  {\n    name: 'solPayment',\n    settingsBytes: 40,\n    settingsSerializer: mapSerializer<SolPayment, SolPaymentGuardSettings>(\n      createSerializerFromBeet(solPaymentBeet),\n      (settings) => ({ ...settings, amount: lamports(settings.lamports) }),\n      (settings) => ({ ...settings, lamports: settings.amount.basisPoints })\n    ),\n    mintSettingsParser: ({ settings }) => {\n      return {\n        arguments: Buffer.from([]),\n        remainingAccounts: [\n          {\n            isSigner: false,\n            address: settings.destination,\n            isWritable: true,\n          },\n        ],\n      };\n    },\n  };\n","import { Buffer } from 'buffer';\nimport {\n  TokenPayment,\n  tokenPaymentBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  PublicKey,\n  SplTokenAmount,\n  token,\n} from '@/types';\n\n/**\n * The tokenPayment guard allows minting by charging the\n * payer a specific amount of tokens from a certain mint acount.\n * The tokens will be transfered to a predefined destination.\n *\n * This guard alone does not limit how many times a holder\n * can mint. A holder can mint as many times as they have\n * the required amount of tokens to pay with.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type TokenPaymentGuardSettings = {\n  /** The mint address of the required tokens. */\n  mint: PublicKey;\n\n  /** The amount of tokens required to mint an NFT. */\n  amount: SplTokenAmount;\n\n  /** The associated token address to send the tokens to. */\n  destinationAta: PublicKey;\n};\n\n/** @internal */\nexport const tokenPaymentGuardManifest: CandyGuardManifest<TokenPaymentGuardSettings> =\n  {\n    name: 'tokenPayment',\n    settingsBytes: 72,\n    settingsSerializer: mapSerializer<TokenPayment, TokenPaymentGuardSettings>(\n      createSerializerFromBeet(tokenPaymentBeet),\n      (settings) => ({\n        mint: settings.mint,\n        amount: token(settings.amount),\n        destinationAta: settings.destinationAta,\n      }),\n      (settings) => ({\n        mint: settings.mint,\n        amount: settings.amount.basisPoints,\n        destinationAta: settings.destinationAta,\n      })\n    ),\n    mintSettingsParser: ({ metaplex, settings, payer, programs }) => {\n      const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({\n        mint: settings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n      return {\n        arguments: Buffer.from([]),\n        remainingAccounts: [\n          {\n            isSigner: false,\n            address: tokenAddress,\n            isWritable: true,\n          },\n          {\n            isSigner: false,\n            address: settings.destinationAta,\n            isWritable: true,\n          },\n        ],\n      };\n    },\n  };\n","import { StartDate, startDateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  DateTime,\n  mapSerializer,\n  toDateTime,\n} from '@/types';\n\n/**\n * The startDate guard determines the start date of the mint.\n * Before this date, minting is not allowed.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type StartDateGuardSettings = {\n  /** The date before which minting is not yet possible. */\n  date: DateTime;\n};\n\n/** @internal */\nexport const startDateGuardManifest: CandyGuardManifest<StartDateGuardSettings> =\n  {\n    name: 'startDate',\n    settingsBytes: 8,\n    settingsSerializer: mapSerializer<StartDate, StartDateGuardSettings>(\n      createSerializerFromBeet(startDateBeet),\n      (settings) => ({ date: toDateTime(settings.date) }),\n      (settings) => settings\n    ),\n  };\n","import { Buffer } from 'buffer';\nimport { thirdPartySignerBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey, Signer } from '@/types';\n\n/**\n * The thirdPartySigner guard requires a predefined\n * address to sign the mint transaction. The signer will need\n * to be passed within the mint settings of this guard.\n *\n * This allows for more centralized mints where every single\n * mint transaction has to go through a specific signer.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link ThirdPartySignerGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type ThirdPartySignerGuardSettings = {\n  /**\n   * The address of the signer that will\n   * need to sign each mint transaction.\n   */\n  signerKey: PublicKey;\n};\n\n/**\n * The settings for the thirdPartySigner guard that could\n * be provided when minting from the Candy Machine.\n *\n * @see {@link ThirdPartySignerGuardSettings} for more\n * information on the thirdPartySigner guard itself.\n */\nexport type ThirdPartySignerGuardMintSettings = {\n  /** The required third party signer. */\n  signer: Signer;\n};\n\n/** @internal */\nexport const thirdPartySignerGuardManifest: CandyGuardManifest<\n  ThirdPartySignerGuardSettings,\n  ThirdPartySignerGuardMintSettings\n> = {\n  name: 'thirdPartySigner',\n  settingsBytes: 32,\n  settingsSerializer: createSerializerFromBeet(thirdPartySignerBeet),\n  mintSettingsParser: ({ mintSettings }) => {\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('thirdPartySigner');\n    }\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: true,\n          address: mintSettings.signer,\n          isWritable: true,\n        },\n      ],\n    };\n  },\n};\n","import { TokenGate, tokenGateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  PublicKey,\n  SplTokenAmount,\n  token,\n} from '@/types';\n\n/**\n * The tokenGate guard restricts minting to token holders\n * of a specified mint account. The `amount` determines\n * how many tokens are required.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type TokenGateGuardSettings = {\n  /** The mint address of the required tokens. */\n  mint: PublicKey;\n\n  /** The amount of tokens required to mint an NFT. */\n  amount: SplTokenAmount;\n};\n\n/** @internal */\nexport const tokenGateGuardManifest: CandyGuardManifest<TokenGateGuardSettings> =\n  {\n    name: 'tokenGate',\n    settingsBytes: 40,\n    settingsSerializer: mapSerializer<TokenGate, TokenGateGuardSettings>(\n      createSerializerFromBeet(tokenGateBeet),\n      (settings) => ({ ...settings, amount: token(settings.amount) }),\n      (settings) => ({ ...settings, amount: settings.amount.basisPoints })\n    ),\n    mintSettingsParser: ({ metaplex, settings, payer, programs }) => {\n      const tokenAccount = metaplex.tokens().pdas().associatedTokenAccount({\n        mint: settings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n      return {\n        arguments: Buffer.from([]),\n        remainingAccounts: [\n          {\n            isSigner: false,\n            address: tokenAccount,\n            isWritable: false,\n          },\n        ],\n      };\n    },\n  };\n","import { Buffer } from 'buffer';\nimport {\n  Gatekeeper,\n  gatekeeperBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest, CandyGuardsRemainingAccount } from './core';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  Pda,\n  PublicKey,\n} from '@/types';\n\n/**\n * The gatekeeper guard checks whether the minting wallet\n * has a valid Gateway Token from a specified Gateway Network.\n *\n * In most cases, this token will be obtain after completing a\n * captcha challenge but any Gateway Network may be used.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link GatekeeperGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type GatekeeperGuardSettings = {\n  /**\n   * The public key of the Gatekeeper Network that will\n   * be used to check the validity of the minting wallet.\n   *\n   * For instance, you may use the \"Civic Captcha Pass\" Network,\n   * which ensures the minting wallet has passed a captcha, by using\n   * the following address: `ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6`.\n   */\n  network: PublicKey;\n\n  /**\n   * Whether we should mark the Gateway Token of the minting wallet\n   * as expired after the NFT has been minting.\n   *\n   * When set to `true`, they will need to go through the Gatekeeper\n   * Network again in order to mint another NFT.\n   *\n   * When set to `false`, they will be able to mint another NFT\n   * until the Gateway Token expires naturally.\n   */\n  expireOnUse: boolean;\n};\n\n/**\n * The settings for the gatekeeper guard that may\n * be provided when minting from the Candy Machine.\n *\n * @see {@link GatekeeperGuardSettings} for more\n * information on the gatekeeper guard itself.\n */\nexport type GatekeeperGuardMintSettings = {\n  /**\n   * The Gateway Token PDA derived from the payer\n   * and the Gatekeeper Network which is used to\n   * verify the payer's eligibility to mint.\n   *\n   * @defaultValue\n   * Computes the Gateway Token PDA using the payer's and the\n   * Gatekeeper Network's public keys as well as the default\n   * `seed` value which is `[0, 0, 0, 0, 0, 0, 0, 0]`.\n   */\n  tokenAccount?: PublicKey;\n};\n\n/** @internal */\nexport const gatekeeperGuardManifest: CandyGuardManifest<\n  GatekeeperGuardSettings,\n  GatekeeperGuardMintSettings\n> = {\n  name: 'gatekeeper',\n  settingsBytes: 33,\n  settingsSerializer: mapSerializer<Gatekeeper, GatekeeperGuardSettings>(\n    createSerializerFromBeet(gatekeeperBeet),\n    (settings) => ({ ...settings, network: settings.gatekeeperNetwork }),\n    (settings) => ({ ...settings, gatekeeperNetwork: settings.network })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    mintSettings,\n    payer,\n    programs,\n  }) => {\n    const gatewayProgram = metaplex.programs().getGateway(programs);\n    const tokenAccount =\n      mintSettings?.tokenAccount ??\n      Pda.find(gatewayProgram.address, [\n        payer.publicKey.toBuffer(),\n        Buffer.from('gateway'),\n        Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n        settings.network.toBuffer(),\n      ]);\n\n    const remainingAccounts: CandyGuardsRemainingAccount[] = [\n      {\n        isSigner: false,\n        address: tokenAccount,\n        isWritable: true,\n      },\n    ];\n\n    if (settings.expireOnUse) {\n      const expireAccount = Pda.find(gatewayProgram.address, [\n        settings.network.toBuffer(),\n        Buffer.from('expire'),\n      ]);\n\n      remainingAccounts.push({\n        isSigner: false,\n        address: gatewayProgram.address,\n        isWritable: false,\n      });\n      remainingAccounts.push({\n        isSigner: false,\n        address: expireAccount,\n        isWritable: false,\n      });\n    }\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts,\n    };\n  },\n};\n","import { EndDate, endDateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  DateTime,\n  mapSerializer,\n  toDateTime,\n} from '@/types';\n\n/**\n * The endDate guard is used to specify a date to end the mint.\n * Any transaction received after the end date will fail.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type EndDateGuardSettings = {\n  /** The date after which minting is no longer possible. */\n  date: DateTime;\n};\n\n/** @internal */\nexport const endDateGuardManifest: CandyGuardManifest<EndDateGuardSettings> = {\n  name: 'endDate',\n  settingsBytes: 8,\n  settingsSerializer: mapSerializer<EndDate, EndDateGuardSettings>(\n    createSerializerFromBeet(endDateBeet),\n    (settings) => ({ date: toDateTime(settings.date) }),\n    (settings) => settings\n  ),\n};\n","import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { AllowList, allowListBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, mapSerializer } from '@/types';\n\n/**\n * The allowList guard validates the minting wallet against\n * a predefined list of wallets.\n *\n * Instead of passing the entire list of wallets as settings,\n * this guard accepts the Root of a Merkle Tree created from\n * this allow list. The program can then validate that the minting\n * wallet is part of the allow list by requiring a Merkle Proof.\n * Minting will fail if either the minting address is not part of\n * the merkle tree or if no Merkle Proof is specified.\n *\n * You may use the `getMerkleRoot` and `getMerkleProof` helper\n * functions provided by the SDK to help you set up this guard.\n * Here is an example.\n *\n * ```ts\n * import { getMerkleProof, getMerkleRoot } from '@metaplex-foundation/js';\n * const allowList = [\n *   'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',\n *   'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n *   'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n * ];\n * const merkleRoot = getMerkleRoot(allowList);\n * const validMerkleProof = getMerkleProof(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');\n * const invalidMerkleProof = getMerkleProof(allowList, 'invalid-address');\n * ```\n *\n * Note that you will need to provide the Merkle Proof for the\n * minting wallet before calling the mint instruction via the\n * special \"route\" instruction of the guard.\n * See {@link AllowListGuardRouteSettings} for more information.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link AllowListGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type AllowListGuardSettings = {\n  /**\n   * The Root of the Merkle Tree representing the allow list.\n   * You may use the `getMerkleRoot` helper function to generate this.\n   */\n  merkleRoot: Uint8Array;\n};\n\n/**\n * The settings for the allowList guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Proof\n * The `proof` path allows you to provide a Merkle Proof\n * for a specific wallet in order to allow minting for that wallet.\n * This will create a small PDA account on the Program as a proof\n * that the wallet has been allowed to mint.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'allowList',\n *   settings: {\n *     path: 'proof',\n *     merkleProof: getMerkleProof(allowedWallets, metaplex.identity().publicKey.toBase58()),\n *   },\n * });\n *\n * // You are now allows to mint with this wallet.\n * ```\n *\n * @see {@link AllowListGuardSettings} for more\n * information on the allowList guard itself.\n */\nexport type AllowListGuardRouteSettings = {\n  /** Selects the path to execute in the route instruction. */\n  path: 'proof';\n\n  /**\n   * The Proof that the minting wallet is part of the\n   * Merkle Tree-based allow list. You may use the\n   * `getMerkleProof` helper function to generate this.\n   */\n  merkleProof: Uint8Array[];\n};\n\n/** @internal */\nexport const allowListGuardManifest: CandyGuardManifest<\n  AllowListGuardSettings,\n  {},\n  AllowListGuardRouteSettings\n> = {\n  name: 'allowList',\n  settingsBytes: 32,\n  settingsSerializer: mapSerializer<AllowList, AllowListGuardSettings>(\n    createSerializerFromBeet(allowListBeet),\n    (settings) => ({ merkleRoot: new Uint8Array(settings.merkleRoot) }),\n    (settings) => ({ merkleRoot: Array.from(settings.merkleRoot) })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    payer,\n    candyMachine,\n    candyGuard,\n  }) => {\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n      ],\n    };\n  },\n  routeSettingsParser: ({\n    metaplex,\n    settings,\n    routeSettings,\n    programs,\n    candyMachine,\n    candyGuard,\n    payer,\n  }) => {\n    const proof = routeSettings.merkleProof;\n    const vectorSize = Buffer.alloc(4);\n    beet.u32.write(vectorSize, 0, proof.length);\n\n    return {\n      arguments: Buffer.concat([vectorSize, ...proof]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: true,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.programs().getSystem(programs).address,\n        },\n      ],\n    };\n  },\n};\n","import { Buffer } from 'buffer';\nimport { mintLimitBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet } from '@/types';\n\n/**\n * The mintLimit guard allows to specify a limit on the\n * number of mints for each individual wallet.\n *\n * The limit is set per wallet, per candy machine and per\n * identified (provided in the settings) to allow multiple\n * mint limits within a Candy Machine. This is particularly\n * useful when using groups of guards and we want each of them\n * to have a different mint limit.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type MintLimitGuardSettings = {\n  /**\n   * A unique identitifer for the limit\n   * for a given wallet and candy machine.\n   */\n  id: number;\n\n  /** The maximum number of mints allowed. */\n  limit: number;\n};\n\n/** @internal */\nexport const mintLimitGuardManifest: CandyGuardManifest<MintLimitGuardSettings> =\n  {\n    name: 'mintLimit',\n    settingsBytes: 3,\n    settingsSerializer: createSerializerFromBeet(mintLimitBeet),\n    mintSettingsParser: ({\n      metaplex,\n      settings,\n      payer,\n      candyMachine,\n      candyGuard,\n      programs,\n    }) => {\n      const counterPda = metaplex.candyMachines().pdas().mintLimitCounter({\n        id: settings.id,\n        user: payer.publicKey,\n        candyMachine,\n        candyGuard,\n        programs,\n      });\n\n      return {\n        arguments: Buffer.from([]),\n        remainingAccounts: [\n          {\n            address: counterPda,\n            isSigner: false,\n            isWritable: true,\n          },\n        ],\n      };\n    },\n  };\n","import { nftPaymentBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey } from '@/types';\n\n/**\n * The nftPayment guard allows minting by charging the\n * payer an NFT from a specified NFT collection.\n * The NFT will be transfered to a predefined destination.\n *\n * This means the mint address of the NFT to transfer must be\n * passed when minting. This guard alone does not limit how many\n * times a holder can mint. A holder can mint as many times\n * as they have NFTs from the required collection to pay with.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link NftPaymentGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type NftPaymentGuardSettings = {\n  /** The mint address of the required NFT Collection. */\n  requiredCollection: PublicKey;\n\n  /** The address of the account to send the NFTs to. */\n  destination: PublicKey;\n};\n\n/**\n * The settings for the nftPayment guard that could\n * be provided when minting from the Candy Machine.\n *\n * @see {@link NftPaymentGuardSettings} for more\n * information on the nftPayment guard itself.\n */\nexport type NftPaymentGuardMintSettings = {\n  /**\n   * The mint address of the NFT to pay with.\n   * This must be part of the required collection and must\n   * belong to the payer.\n   */\n  mint: PublicKey;\n\n  /**\n   * The token account linking the NFT with its owner.\n   *\n   * @defaultValue\n   * Defaults to the associated token address using the\n   * mint address of the NFT and the payer's address.\n   */\n  tokenAccount?: PublicKey;\n};\n\n/** @internal */\nexport const nftPaymentGuardManifest: CandyGuardManifest<\n  NftPaymentGuardSettings,\n  NftPaymentGuardMintSettings\n> = {\n  name: 'nftPayment',\n  settingsBytes: 64,\n  settingsSerializer: createSerializerFromBeet(nftPaymentBeet),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    mintSettings,\n    payer,\n    programs,\n  }) => {\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('nftPayment');\n    }\n\n    const associatedTokenProgram = metaplex\n      .programs()\n      .getAssociatedToken(programs);\n\n    const nftTokenAccount =\n      mintSettings.tokenAccount ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintSettings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n    const nftMetadata = metaplex.nfts().pdas().metadata({\n      mint: mintSettings.mint,\n      programs,\n    });\n\n    const destinationAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintSettings.mint,\n      owner: settings.destination,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: nftTokenAccount,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: nftMetadata,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: mintSettings.mint,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: settings.destination,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: destinationAta,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: associatedTokenProgram.address,\n          isWritable: false,\n        },\n      ],\n    };\n  },\n};\n","import {\n  RedeemedAmount,\n  redeemedAmountBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  BigNumber,\n  createSerializerFromBeet,\n  mapSerializer,\n  toBigNumber,\n} from '@/types';\n\n/**\n * The redeemedAmount guard forbids minting when the\n * number of minted NFTs for the entire Candy Machine\n * reaches the configured maximum amount.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type RedeemedAmountGuardSettings = {\n  /** The maximum amount of NFTs that can be minted using that guard. */\n  maximum: BigNumber;\n};\n\n/** @internal */\nexport const redeemedAmountGuardManifest: CandyGuardManifest<RedeemedAmountGuardSettings> =\n  {\n    name: 'redeemedAmount',\n    settingsBytes: 8,\n    settingsSerializer: mapSerializer<\n      RedeemedAmount,\n      RedeemedAmountGuardSettings\n    >(\n      createSerializerFromBeet(redeemedAmountBeet),\n      (settings) => ({ maximum: toBigNumber(settings.maximum) }),\n      (settings) => settings\n    ),\n  };\n","import { addressGateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey } from '@/types';\n\n/**\n * The addressGate guard restricts the mint to a single\n * address which must match the minting wallet's address.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type AddressGateGuardSettings = {\n  /** The only address that is allowed to mint from the Candy Machine. */\n  address: PublicKey;\n};\n\n/** @internal */\nexport const addressGateGuardManifest: CandyGuardManifest<AddressGateGuardSettings> =\n  {\n    name: 'addressGate',\n    settingsBytes: 32,\n    settingsSerializer: createSerializerFromBeet(addressGateBeet),\n  };\n","import { nftGateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey } from '@/types';\n\n/**\n * The nftGate guard restricts minting to holders\n * of a specified NFT collection.\n *\n * This means the mint address of an NFT from this\n * collection must be passed when minting.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link NftGateGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type NftGateGuardSettings = {\n  /** The mint address of the required NFT Collection. */\n  requiredCollection: PublicKey;\n};\n\n/**\n * The settings for the nftGate guard that could\n * be provided when minting from the Candy Machine.\n *\n * @see {@link NftGateGuardSettings} for more\n * information on the nftGate guard itself.\n */\nexport type NftGateGuardMintSettings = {\n  /**\n   * The mint address of an NFT from the required\n   * collection that belongs to the payer.\n   */\n  mint: PublicKey;\n\n  /**\n   * The token account linking the NFT with its owner.\n   *\n   * @defaultValue\n   * Defaults to the associated token address using the\n   * mint address of the NFT and the payer's address.\n   */\n  tokenAccount?: PublicKey;\n};\n\n/** @internal */\nexport const nftGateGuardManifest: CandyGuardManifest<\n  NftGateGuardSettings,\n  NftGateGuardMintSettings\n> = {\n  name: 'nftGate',\n  settingsBytes: 32,\n  settingsSerializer: createSerializerFromBeet(nftGateBeet),\n  mintSettingsParser: ({ metaplex, mintSettings, payer, programs }) => {\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('nftGate');\n    }\n\n    const tokenAccount =\n      mintSettings.tokenAccount ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintSettings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n    const tokenMetadata = metaplex.nfts().pdas().metadata({\n      mint: mintSettings.mint,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: tokenAccount,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: tokenMetadata,\n          isWritable: false,\n        },\n      ],\n    };\n  },\n};\n","import { nftBurnBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey } from '@/types';\n\n/**\n * The nftBurn guard restricts the mint to holders of a predefined\n * NFT Collection and burns the holder's NFT when minting.\n *\n * This means the mint address of the NFT to burn must be\n * passed when minting. This guard alone does not limit how many\n * times a holder can mint. A holder can mint as many times\n * as they have NFTs from the required collection to burn.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link NftBurnGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type NftBurnGuardSettings = {\n  /** The mint address of the required NFT Collection. */\n  requiredCollection: PublicKey;\n};\n\n/**\n * The settings for the nftBurn guard that could\n * be provided when minting from the Candy Machine.\n *\n * @see {@link NftBurnGuardSettings} for more\n * information on the nftBurn guard itself.\n */\nexport type NftBurnGuardMintSettings = {\n  /**\n   * The mint address of the NFT to burn.\n   * This must be part of the required collection and must\n   * belong to the payer.\n   */\n  mint: PublicKey;\n\n  /**\n   * The token account linking the NFT with its owner.\n   *\n   * @defaultValue\n   * Defaults to the associated token address using the\n   * mint address of the NFT and the payer's address.\n   */\n  tokenAccount?: PublicKey;\n};\n\n/** @internal */\nexport const nftBurnGuardManifest: CandyGuardManifest<\n  NftBurnGuardSettings,\n  NftBurnGuardMintSettings\n> = {\n  name: 'nftBurn',\n  settingsBytes: 32,\n  settingsSerializer: createSerializerFromBeet(nftBurnBeet),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    mintSettings,\n    payer,\n    programs,\n  }) => {\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('nftBurn');\n    }\n\n    const tokenAccount =\n      mintSettings.tokenAccount ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintSettings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n    const tokenMetadata = metaplex.nfts().pdas().metadata({\n      mint: mintSettings.mint,\n      programs,\n    });\n\n    const tokenEdition = metaplex.nfts().pdas().masterEdition({\n      mint: mintSettings.mint,\n      programs,\n    });\n\n    const mintCollectionMetadata = metaplex.nfts().pdas().metadata({\n      mint: settings.requiredCollection,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: tokenAccount,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: tokenMetadata,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: tokenEdition,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: mintSettings.mint,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: mintCollectionMetadata,\n          isWritable: true,\n        },\n      ],\n    };\n  },\n};\n","import { TokenBurn, tokenBurnBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  PublicKey,\n  SplTokenAmount,\n  token,\n} from '@/types';\n\n/**\n * The tokenBurn guard restricts minting to token holders\n * of a specified mint account and burns the holder's tokens\n * when minting. The `amount` determines how many tokens are required.\n *\n * This guard alone does not limit how many times a holder\n * can mint. A holder can mint as many times as they have\n * the required amount of tokens to burn.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type TokenBurnGuardSettings = {\n  /** The mint address of the required tokens. */\n  mint: PublicKey;\n\n  /** The amount of tokens required to mint an NFT. */\n  amount: SplTokenAmount;\n};\n\n/** @internal */\nexport const tokenBurnGuardManifest: CandyGuardManifest<TokenBurnGuardSettings> =\n  {\n    name: 'tokenBurn',\n    settingsBytes: 40,\n    settingsSerializer: mapSerializer<TokenBurn, TokenBurnGuardSettings>(\n      createSerializerFromBeet(tokenBurnBeet),\n      (settings) => ({ ...settings, amount: token(settings.amount) }),\n      (settings) => ({ ...settings, amount: settings.amount.basisPoints })\n    ),\n    mintSettingsParser: ({ metaplex, settings, payer, programs }) => {\n      const tokenAccount = metaplex.tokens().pdas().associatedTokenAccount({\n        mint: settings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n      return {\n        arguments: Buffer.from([]),\n        remainingAccounts: [\n          {\n            isSigner: false,\n            address: tokenAccount,\n            isWritable: true,\n          },\n          {\n            isSigner: false,\n            address: settings.mint,\n            isWritable: true,\n          },\n        ],\n      };\n    },\n  };\n","import { programGateBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport * as beet from '@metaplex-foundation/beet';\nimport { MaximumOfFiveAdditionalProgramsError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { PublicKey } from '@/types';\n\n/**\n * The programGate guard restricts the programs that can be invoked within\n * the mint transaction. It allows the necessary programs for the mint\n * instruction to work and any other program specified in the configuration.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n */\nexport type ProgramGateGuardSettings = {\n  /**\n   * An array of additional programs that can be invoked in a mint transaction.\n   *\n   * These programs are in addition to the mandatory programs that\n   * are required for the mint instruction to work. Providing an empty\n   * array is equivalent to only authorising the mandatory programs.\n   *\n   * The mandatory programs are:\n   * - Candy Machine\n   * - System Program\n   * - SPL Token\n   * - SPL ASsociated Token Account\n   */\n  additional: PublicKey[];\n};\n\nconst MAXIMUM_SIZE = 5;\nconst SETTINGS_BYTES = 4 + MAXIMUM_SIZE * 32;\n\n/** @internal */\nexport const programGateGuardManifest: CandyGuardManifest<ProgramGateGuardSettings> =\n  {\n    name: 'programGate',\n    settingsBytes: SETTINGS_BYTES,\n    settingsSerializer: {\n      description: programGateBeet.description,\n      serialize: (value: ProgramGateGuardSettings) => {\n        // Maximum of 5 additional programs allowed.\n        if (value.additional.length >= MAXIMUM_SIZE) {\n          throw new MaximumOfFiveAdditionalProgramsError();\n        }\n\n        // Create buffer with beet.\n        const fixedBeet = programGateBeet.toFixedFromValue(value);\n        const writer = new beet.BeetWriter(fixedBeet.byteSize);\n        writer.write(fixedBeet, value);\n\n        // Create 164 byte buffer and fill with previous buffer.\n        // This allows for < 5 additional programs.\n        const bufferFullSize = Buffer.alloc(SETTINGS_BYTES);\n        bufferFullSize.fill(writer.buffer);\n\n        return bufferFullSize;\n      },\n      deserialize: (buffer: Buffer, offset?: number) => {\n        const fixedBeet = programGateBeet.toFixedFromData(buffer, offset ?? 0);\n        const reader = new beet.BeetReader(buffer, offset ?? 0);\n        const value = reader.read(fixedBeet);\n        return [value, reader.offset];\n      },\n    },\n  };\n","import { ProgramClient } from '../programModule';\nimport { CandyMachineClient } from './CandyMachineClient';\nimport {\n  addressGateGuardManifest,\n  allowListGuardManifest,\n  botTaxGuardManifest,\n  endDateGuardManifest,\n  gatekeeperGuardManifest,\n  mintLimitGuardManifest,\n  nftBurnGuardManifest,\n  nftGateGuardManifest,\n  nftPaymentGuardManifest,\n  programGateGuardManifest,\n  redeemedAmountGuardManifest,\n  solPaymentGuardManifest,\n  startDateGuardManifest,\n  thirdPartySignerGuardManifest,\n  tokenBurnGuardManifest,\n  tokenGateGuardManifest,\n  tokenPaymentGuardManifest,\n} from './guards';\nimport {\n  CallCandyGuardRouteOperation,\n  callCandyGuardRouteOperation,\n  callCandyGuardRouteOperationHandler,\n  createCandyGuardOperation,\n  createCandyGuardOperationHandler,\n  createCandyMachineOperation,\n  createCandyMachineOperationHandler,\n  deleteCandyGuardOperation,\n  deleteCandyGuardOperationHandler,\n  deleteCandyMachineOperation,\n  deleteCandyMachineOperationHandler,\n  findCandyGuardByAddressOperation,\n  findCandyGuardByAddressOperationHandler,\n  findCandyGuardsByAuthorityOperation,\n  findCandyGuardsByAuthorityOperationHandler,\n  findCandyMachineByAddressOperation,\n  findCandyMachineByAddressOperationHandler,\n  insertCandyMachineItemsOperation,\n  insertCandyMachineItemsOperationHandler,\n  mintFromCandyMachineOperation,\n  mintFromCandyMachineOperationHandler,\n  unwrapCandyGuardOperation,\n  unwrapCandyGuardOperationHandler,\n  updateCandyGuardOperation,\n  updateCandyGuardOperationHandler,\n  updateCandyMachineOperation,\n  updateCandyMachineOperationHandler,\n  wrapCandyGuardOperation,\n  wrapCandyGuardOperationHandler,\n} from './operations';\nimport {\n  CandyGuardProgram,\n  candyMachineProgram,\n  defaultCandyGuardProgram,\n  gatewayProgram,\n} from './programs';\nimport {\n  updateCandyGuardAuthorityOperation,\n  updateCandyGuardAuthorityOperationHandler,\n} from './operations/updateCandyGuardAuthority';\nimport { freezeSolPaymentGuardManifest } from './guards/freezeSolPayment';\nimport { freezeTokenPaymentGuardManifest } from './guards/freezeTokenPayment';\nimport { MetaplexPlugin, OperationConstructor, Program } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/** @group Plugins */\nexport const candyMachineModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    // Client.\n    const client = new CandyMachineClient(metaplex);\n    metaplex.candyMachines = () => client;\n\n    // Candy Machine Program.\n    metaplex.programs().register(candyMachineProgram);\n    metaplex.programs().getCandyMachine = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(candyMachineProgram.name, programs);\n    };\n\n    // Candy Guard Program.\n    metaplex.programs().register(defaultCandyGuardProgram);\n    metaplex.programs().getCandyGuard = function <T extends CandyGuardProgram>(\n      this: ProgramClient,\n      programs?: Program[]\n    ): T {\n      return this.get(defaultCandyGuardProgram.name, programs);\n    };\n\n    // Gateway Program.\n    metaplex.programs().register(gatewayProgram);\n    metaplex.programs().getGateway = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(gatewayProgram.name, programs);\n    };\n\n    // Default Guards.\n    client.guards().register(botTaxGuardManifest);\n    client.guards().register(solPaymentGuardManifest);\n    client.guards().register(tokenPaymentGuardManifest);\n    client.guards().register(startDateGuardManifest);\n    client.guards().register(thirdPartySignerGuardManifest);\n    client.guards().register(tokenGateGuardManifest);\n    client.guards().register(gatekeeperGuardManifest);\n    client.guards().register(endDateGuardManifest);\n    client.guards().register(allowListGuardManifest);\n    client.guards().register(mintLimitGuardManifest);\n    client.guards().register(nftPaymentGuardManifest);\n    client.guards().register(redeemedAmountGuardManifest);\n    client.guards().register(addressGateGuardManifest);\n    client.guards().register(nftGateGuardManifest);\n    client.guards().register(nftBurnGuardManifest);\n    client.guards().register(tokenBurnGuardManifest);\n    client.guards().register(freezeSolPaymentGuardManifest);\n    client.guards().register(freezeTokenPaymentGuardManifest);\n    client.guards().register(programGateGuardManifest);\n\n    // Operations.\n    const op = metaplex.operations();\n    op.register(\n      callCandyGuardRouteOperation as OperationConstructor<\n        CallCandyGuardRouteOperation<any>\n      >,\n      callCandyGuardRouteOperationHandler\n    );\n    op.register(createCandyGuardOperation, createCandyGuardOperationHandler);\n    op.register(\n      createCandyMachineOperation,\n      createCandyMachineOperationHandler\n    );\n    op.register(deleteCandyGuardOperation, deleteCandyGuardOperationHandler);\n    op.register(\n      deleteCandyMachineOperation,\n      deleteCandyMachineOperationHandler\n    );\n    op.register(\n      findCandyGuardByAddressOperation,\n      findCandyGuardByAddressOperationHandler\n    );\n    op.register(\n      findCandyGuardsByAuthorityOperation,\n      findCandyGuardsByAuthorityOperationHandler\n    );\n    op.register(\n      findCandyMachineByAddressOperation,\n      findCandyMachineByAddressOperationHandler\n    );\n    op.register(\n      insertCandyMachineItemsOperation,\n      insertCandyMachineItemsOperationHandler\n    );\n    op.register(\n      mintFromCandyMachineOperation,\n      mintFromCandyMachineOperationHandler\n    );\n    op.register(unwrapCandyGuardOperation, unwrapCandyGuardOperationHandler);\n    op.register(\n      updateCandyGuardAuthorityOperation,\n      updateCandyGuardAuthorityOperationHandler\n    );\n    op.register(updateCandyGuardOperation, updateCandyGuardOperationHandler);\n    op.register(\n      updateCandyMachineOperation,\n      updateCandyMachineOperationHandler\n    );\n    op.register(wrapCandyGuardOperation, wrapCandyGuardOperationHandler);\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    candyMachines(): CandyMachineClient;\n  }\n}\n\ndeclare module '../programModule/ProgramClient' {\n  interface ProgramClient {\n    getCandyMachine(programs?: Program[]): Program;\n    getCandyGuard<T extends CandyGuardProgram>(programs?: Program[]): T;\n    getGateway(programs?: Program[]): Program;\n  }\n}\n","import type { Metaplex } from '../../Metaplex';\n\n// Low-level modules.\nimport { identityModule } from '../identityModule';\nimport { storageModule } from '../storageModule';\nimport { rpcModule } from '../rpcModule';\nimport { operationModule } from '../operationModule';\nimport { programModule } from '../programModule';\nimport { utilsModule } from '../utilsModule';\n\n// Default drivers.\nimport { guestIdentity } from '../guestIdentity';\nimport { irysStorage } from '../irysStorage';\n\n// Verticals.\nimport { systemModule } from '../systemModule';\nimport { tokenModule } from '../tokenModule';\nimport { nftModule } from '../nftModule';\nimport { candyMachineV2Module } from '../candyMachineV2Module';\nimport { candyMachineModule } from '../candyMachineModule';\nimport { auctionHouseModule } from '../auctionHouseModule';\n\nexport const corePlugins = () => ({\n  install(metaplex: Metaplex) {\n    // Low-level modules.\n    metaplex.use(identityModule());\n    metaplex.use(storageModule());\n    metaplex.use(rpcModule());\n    metaplex.use(operationModule());\n    metaplex.use(programModule());\n    metaplex.use(utilsModule());\n\n    // Default drivers.\n    metaplex.use(guestIdentity());\n    metaplex.use(irysStorage());\n\n    // Verticals.\n    metaplex.use(systemModule());\n    metaplex.use(tokenModule());\n    metaplex.use(nftModule());\n    metaplex.use(candyMachineV2Module());\n    metaplex.use(candyMachineModule());\n    metaplex.use(auctionHouseModule());\n  },\n});\n"],"names":["MAX_NAME_LENGTH","MAX_SYMBOL_LENGTH","MAX_URI_LENGTH","MAX_CREATOR_LIMIT","MAX_CREATOR_LEN","CONFIG_LINE_SIZE","CONFIG_ARRAY_START","countCandyMachineV2Items","rawData","number","slice","toBigNumber","parseCandyMachineV2Items","configLinesStart","lines","count","toNumber","i","line","configLineBeet","deserialize","push","name","removeEmptyChars","uri","getCandyMachineV2AccountSizeFromData","data","hiddenSettings","itemsAvailable","Math","ceil","getCandyMachineV2UuidFromAddress","candyMachineAddress","toBase58","candyMachineV2Discriminator","AUTHORITY","length","WALLET","PublicKey","default","toBytes","byteLength","CandyMachineV2GpaBuilder","GpaBuilder","whereDiscriminator","discrimator","this","where","Buffer","from","candyMachineAccounts","candyMachineAccountsForWallet","wallet","candyMachineAccountsForAuthority","authority","CandyMachineV2Program","publicKey","PROGRAM_ID","accounts","metaplex","findCandyMachineV2CreatorPda","candyMachine","programId","Pda","find","toBuffer","findCandyMachineV2CollectionPda","toCandyMachineV2","account","unparsedAccount","collectionAccount","mint","assert","tokenMint","address","equals","itemsMinted","itemsRedeemed","endSettings","whitelistMintSettings","gatekeeper","itemsLoaded","items","model","programAddress","owner","version","authorityAddress","walletAddress","tokenMintAddress","collectionMintAddress","exists","uuid","price","amount","currency","SOL","symbol","sellerFeeBasisPoints","isMutable","retainAuthority","goLiveDate","toOptionDateTime","maxEditionSupply","maxSupply","itemsRemaining","sub","isFullyLoaded","lte","endSettingType","EndSettingType","Date","date","toDateTime","Amount","discountPrice","lamports","network","gatekeeperNetwork","creators","toCandyMachineV2Configs","toCandyMachineV2InstructionData","configs","basisPoints","Key","createCandyMachineV2Operation","useOperation","createCandyMachineV2OperationHandler","handle","operation","scope","builder","createCandyMachineV2Builder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","candyMachinesV2","findByAddress","candyMachineSigner","async","params","options","programs","payer","rpc","getDefaultFeePayer","Keypair","generate","identity","collection","share","verified","initializeInstruction","createInitializeCandyMachineInstruction","toPublicKey","keys","pubkey","isWritable","isSigner","assertSameCurrencies","TransactionBuilder","make","setFeePayer","setContext","add","system","builders","createAccount","newAccount","space","program","instructionKey","createAccountInstructionKey","instruction","signers","key","initializeCandyMachineInstructionKey","when","ExpectedSignerError","collectionMint","metadata","nfts","pdas","edition","masterEdition","collectionPda","collectionAuthorityRecord","collectionAuthority","createSetCollectionInstruction","tokenMetadataProgram","getTokenMetadata","setCollectionInstructionKey","deleteCandyMachineV2Operation","deleteCandyMachineV2OperationHandler","deleteCandyMachineV2Builder","deleteInstruction","createWithdrawFundsInstruction","CandyMachineV2Error","MetaplexError","constructor","message","cause","super","_defineProperty","CandyMachineV2IsFullError","assetIndex","addn","CandyMachineV2IsEmptyError","CandyMachineV2CannotAddAmountError","index","CandyMachineV2AddItemConstraintsViolatedError","item","CandyMachineV2NotLiveError","formatDateTime","CandyMachineV2EndedError","endSetting","endSettingExplanation","CandyMachineV2BotTaxError","explorerLink","assertName","assertUri","assertNotFull","assertNotEmpty","isZero","assertCanAdd","gt","assertAllConfigLineConstraints","configLines","error","assertCandyMachineV2IsLive","hasWhitelistPresale","presale","liveDate","gte","now","assertCandyMachineV2HasNotEnded","hasEndedByAmount","hasEndedByDate","lt","assertCanMintCandyMachineV2","insertItemsToCandyMachineV2Operation","InsertItemsToCandyMachineV2OperationHandler","insertItemsToCandyMachineV2Builder","createAddConfigLinesInstruction","parseCandyMachineV2Account","getAccountParsingFunction","CandyMachine","toCandyMachineV2Account","getAccountParsingAndAssertingFunction","parseCandyMachineV2CollectionAccount","CollectionPDA","mintCandyMachineV2Operation","mintCandyMachineV2OperationHandler","mintCandyMachineV2Builder","nft","findByMint","mintAddress","mintSigner","tokenAddress","getSolanaExporerUrl","response","signature","newMint","newOwner","newToken","newMetadata","newEdition","candyMachineCreator","candyMachineCollectionAddress","candyMachineCollectionAccount","getAccount","tokenWithMintBuilder","tokens","createTokenWithMint","decimals","initialSupply","token","mintAuthority","freezeAuthority","createMintAccountInstructionKey","initializeMintInstructionKey","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintTokensInstructionKey","getContext","mintNftInstruction","createMintNftInstruction","updateAuthority","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_SLOT_HASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","creatorBump","bump","whitelistToken","associatedTokenAccount","payerToken","mintNftInstructionKey","assertAccountExists","collectionMetadata","collectionMasterEdition","createSetCollectionDuringMintInstruction","instructions","updateCandyMachineV2Operation","updateCandyMachineV2OperationHandler","newAuthority","newCollection","updatableFields","currentConfigs","instructionDataWithoutChanges","instructionData","shouldUpdateData","isEqual","updateCandyMachineV2Builder","newData","undefined","isEmpty","NoInstructionsToSendError","shouldUpdateAuthority","sameCollection","shouldUpdateCollection","shouldRemoveCollection","updateInstruction","createUpdateCandyMachineInstruction","updateInstructionKey","createRemoveCollectionInstruction","removeCollectionInstructionKey","createUpdateAuthorityInstruction","updateAuthorityInstructionKey","CandyMachinesV2BuildersClient","create","delete","insertItems","update","findCandyMachinesV2ByPublicKeyFieldOperation","findCandyMachinesV2ByPublicKeyFieldOperationHandler","commitment","type","mergeConfig","candyMachineQuery","UnreachableCaseError","unparsedAccounts","get","collectionPdas","map","parsedAccounts","Object","fromEntries","toString","tokenMints","Set","values","filter","result","getMultipleAccounts","concat","unparsedMintAccounts","unparsedCollectionAccounts","mints","toMint","toMintAccount","zipMap","unparsedCollectionAccount","parsedAccount","findCandyMachineV2ByAddressOperation","findCandyMachineV2ByAddressOperationHandler","findMintByAddress","findMintedNftsByCandyMachineV2Operation","findMintedNftsByCandyMachineV2OperationHandler","firstCreator","mintedNfts","findAllByCreator","creator","position","CandyMachinesV2Client","operations","execute","findAllBy","findMintedNfts","refresh","candyMachineV2Module","install","op","register","updateCandyGuardAuthorityOperation","updateCandyGuardAuthorityOperationHandler","updateCandyGuardAuthorityBuilder","candyGuard","candyGuardProgram","getCandyGuard","createSetAuthorityInstruction","CandyMachineV3Error","UnregisteredCandyGuardError","CandyMachineCannotAddAmountError","CandyMachineItemTextTooLongError","text","limit","CandyMachineBotTaxError","GuardGroupRequiredError","availableGroups","join","SelectedGuardGroupDoesNotExistError","selectedGroup","GuardMintSettingsMissingError","guardName","GuardRouteNotSupportedError","CandyGuardRequiredOnCandyMachineError","GuardNotEnabledError","guard","group","GuardGroupLabelTooLongError","label","maxLength","UnrecognizePathForRouteInstructionError","path","MintOwnerMustBeMintPayerError","MaximumOfFiveAdditionalProgramsError","callCandyGuardRouteOperation","_callCandyGuardRouteOperation","callCandyGuardRouteOperationHandler","callCandyGuardRouteBuilder","settings","parsedRouteSettings","candyMachines","guards","parseRouteSettings","routeSigners","routeInstruction","createRouteInstruction","args","arguments","accountMetas","availableGuards","forCandyGuardProgram","guardIndex","findIndex","g","beet","u8","write","CANDY_MACHINE_HIDDEN_SECTION","CANDY_GUARD_LABEL_SIZE","CANDY_GUARD_DATA","deserializeCandyMachineHiddenSection","buffer","configLineSettings","offset","u32","read","nameLength","uriLength","configLineSize","configLinesSize","rawConfigLines","itemsLoadedBuffer","itemsLoadedMap","deserializeFeatureFlags","itemsLoadedMapSize","floor","itemsLeftToMint","isMinted","isSequential","includes","forEach","loaded","namePosition","uriPosition","prefixName","replaceCandyMachineItemPattern","prefixUri","minted","value","replace","isCandyMachine","isModel","toCandyMachine","serializer","createSerializerFromSolitaType","candyMachineBeet","description","deserializeAccount","itemSettings","hiddenSection","accountInfo","toAccountInfo","mintAuthorityAddress","percentageShare","featureFlags","features","toArrayLike","reverse","toCandyMachineData","getCandyMachineSize","createCandyMachineOperation","_createCandyMachineOperation","createCandyMachineOperationHandler","createCandyMachineBuilder","withoutCandyGuard","authorityPda","candyMachineProgram","getCandyMachine","candyMachineData","createCandyGuard","base","groups","candyGuardAddress","createInitializeInstruction","collectionUpdateAuthority","wrapCandyGuard","candyMachineAuthority","candyGuardAuthority","wrapCandyGuardInstructionKey","createCandyGuardOperation","_createCandyGuardOperation","createCandyGuardOperationHandler","createCandyGuardBuilder","findCandyGuardByBaseAddress","serializedSettings","serializeSettings","createCandyGuardInstructionKey","deleteCandyMachineOperation","deleteCandyMachineOperationHandler","deleteCandyMachineBuilder","createWithdrawInstruction","deleteCandyMachineInstructionKey","deleteCandyGuard","deleteCandyGuardOperation","deleteCandyGuardOperationHandler","deleteCandyGuardBuilder","deleteCandyGuardInstructionKey","assertAllItemConstraints","insertCandyMachineItemsOperation","insertCandyMachineItemsOperationHandler","insertCandyMachineItemsBuilder","mintFromCandyMachineOperation","_mintFromCandyMachineOperation","mintFromCandyMachineOperationHandler","mintFromCandyMachineBuilder","activeGuards","resolveGroupSettings","token$1","tokenProgram","getToken","systemProgram","getSystem","nftMetadata","nftMasterEdition","sharedMintAccounts","nftMint","nftMintAuthority","recentSlothashes","mintNftSigners","guardClient","parsedMintSettings","parseMintSettings","createMintInstruction","candyMachineAuthorityPda","mintArgs","createMintInstruction$1","mintFromCandyMachineInstructionKey","unwrapCandyGuardOperation","unwrapCandyGuardOperationHandler","unwrapCandyGuardBuilder","createUnwrapInstruction","unwrapCandyGuardInstructionKey","updateCandyMachineOperation","_updateCandyMachineOperation","updateCandyMachineOperationHandler","updateCandyMachineBuilder","updateCandyMachineDataBuilder","updateCandyMachineCollectionBuilder","updateCandyGuardsBuilder","updateCandyMachineMintAuthorityBuilder","updateCandyMachineAuthorityBuilder","dataToUpdate","removeUndefinedAttributes","assertObjectHasDefinedKeys","onMissingInputError","createUpdateInstruction","updateDataInstructionKey","currentCollectionAddress","collectionAddress","currentCollectionMetadata","currentCollectionAuthorityRecord","newCollectionUpdateAuthority","newCollectionMetadata","newCollectionMint","newCollectionMasterEdition","newCollectionAuthorityRecord","guardsToUpdate","updateCandyGuard","updateCandyGuardInstructionKey","newMintAuthority","createSetMintAuthorityInstruction","setAuthorityInstructionKey","newCandyGuardAuthority","updateCandyGuardAuthority","setCandyGuardAuthorityInstructionKey","missingKeys","MissingInputDataError","updateCandyGuardOperation","_updateCandyGuardOperation","updateCandyGuardOperationHandler","updateCandyGuardBuilder","wrapCandyGuardOperation","wrapCandyGuardOperationHandler","wrapCandyGuardBuilder","createWrapInstruction","CandyMachineBuildersClient","callGuardRoute","unwrapCandyGuard","CandyMachineGuardsClient","all","forProgram","assertGuardsAreRegistered","serializeSet","set","reduce","acc","Boolean","serialize","settingsSerializer","serializedfeatures","serializeFeatureFlags","groupCountBuffer","alloc","labelBuffer","padEmptyChars","deserializeSettings","deserializeSet","serializedFeatures","isEnabled","settingsBytes","groupsCount","groupLabel","activeGroup","activeGroupGuardsWithoutNullGuards","entries","v","guardMintSettings","guardSettings","initialAccumulator","mintSettings","mintSettingsParser","parsedSettings","getAccountMetas","remainingAccounts","getSigners","routeSettings","guardManifest","routeSettingsParser","availableGuardNames","guardNames","addGuardSet","guardSet","CandyMachinePdasClient","mintLimitCounter","id","user","merkleProof","merkleRoot","freezeEscrow","destination","toCandyGuard","candyGuardSerializer","CandyGuard","candyGuardBeet","parsedCandyGuard","baseAddress","findCandyGuardsByAuthorityOperation","_findCandyGuardsByAuthorityOperation","findCandyGuardsByAuthorityOperationHandler","query","gpaBuilder","addFilter","config","getAndMap","defaultCandyGuardNames","errorResolver","cusper","errorFromProgramLogs","logs","isCandyGuardProgram","assertCandyGuardProgram","defaultCandyGuardProgram","PROGRAM_ID$1","cusper$1","gatewayProgram","findCandyMachineByAddressOperation","_findCandyMachineByAddressOperation","findCandyMachineByAddressOperationHandler","potentialCandyGuardAddress","candyMachineAccount","potentialCandyGuardAccount","isOnCurve","mintAuthorityAccount","findCandyGuardByAddressOperation","_findCandyGuardByAddressOperation","findCandyGuardByAddressOperationHandler","CandyMachineClient","guardsClient","findAllCandyGuardsByAuthority","findCandyGuardByAddress","refreshedModel","freezeSolPaymentGuardManifest","mapSerializer","createSerializerFromBeet","freezeSolPaymentBeet","nftAta","initializeRouteInstruction","thawRouteInstruction","unlockFundsRouteInstruction","FreezeInstruction","Initialize","u64","period","nftOwner","nftEdition","Thaw","UnlockFunds","freezeTokenPaymentGuardManifest","freezeTokenPaymentBeet","destinationAta","freezeAta","associatedTokenProgram","getAssociatedToken","botTaxGuardManifest","botTaxBeet","solPaymentGuardManifest","solPaymentBeet","tokenPaymentGuardManifest","tokenPaymentBeet","startDateGuardManifest","startDateBeet","thirdPartySignerGuardManifest","thirdPartySignerBeet","signer","tokenGateGuardManifest","tokenGateBeet","tokenAccount","gatekeeperGuardManifest","gatekeeperBeet","getGateway","expireOnUse","expireAccount","endDateGuardManifest","endDateBeet","allowListGuardManifest","allowListBeet","Uint8Array","Array","proof","vectorSize","mintLimitGuardManifest","mintLimitBeet","counterPda","nftPaymentGuardManifest","nftPaymentBeet","nftTokenAccount","redeemedAmountGuardManifest","redeemedAmountBeet","maximum","addressGateGuardManifest","addressGateBeet","nftGateGuardManifest","nftGateBeet","tokenMetadata","nftBurnGuardManifest","nftBurnBeet","tokenEdition","mintCollectionMetadata","requiredCollection","tokenBurnGuardManifest","tokenBurnBeet","MAXIMUM_SIZE","SETTINGS_BYTES","programGateGuardManifest","programGateBeet","additional","fixedBeet","toFixedFromValue","writer","BeetWriter","byteSize","bufferFullSize","fill","toFixedFromData","reader","BeetReader","candyMachineModule","client","corePlugins","use","identityModule","storageModule","rpcModule","operationModule","programModule","utilsModule","guestIdentity","irysStorage","systemModule","tokenModule","nftModule","auctionHouseModule"],"sourceRoot":""}