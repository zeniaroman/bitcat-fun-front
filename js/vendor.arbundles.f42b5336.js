"use strict";(self["webpackChunkapp"]=self["webpackChunkapp"]||[]).push([[899],{9913:function(t,e,r){r.d(e,{en:function(){return x},sO:function(){return Nt},Q9:function(){return ut},Il:function(){return lt},qI:function(){return Tt},dU:function(){return it},Jv:function(){return zt},vd:function(){return qt},T4:function(){return w},G8:function(){return T},Xg:function(){return l.stringToBuffer}});var n={};r.r(n),r.d(n,{AVSCTap:function(){return Dt},AlgorandSigner:function(){return at},AptosSigner:function(){return ft},ArconnectSigner:function(){return Et},Arweave:function(){return p.oD},ArweaveSigner:function(){return x},Bundle:function(){return jt},BundleItem:function(){return Qt},CryptoDriver:function(){return v},Curve25519:function(){return f},DataItem:function(){return Nt},EthereumSigner:function(){return rt},HexInjectedSolanaSigner:function(){return ut},HexSolanaSigner:function(){return gt},InjectedAptosSigner:function(){return lt},InjectedEthereumSigner:function(){return O},InjectedSolanaSigner:function(){return I},InjectedTypedEthereumSigner:function(){return Tt},MAX_TAG_BYTES:function(){return Rt},MIN_BINARY_SIZE:function(){return Ht},MultiSignatureAptosSigner:function(){return wt},NearSigner:function(){return it},PolygonSigner:function(){return nt},Rsa4096:function(){return L},SIG_CONFIG:function(){return h},SignatureConfig:function(){return o},Signer:function(){return a},SolanaSigner:function(){return R},TypedEthereumSigner:function(){return pt},bundleAndSignData:function(){return zt},byteArrayToLong:function(){return Pt},concatBuffers:function(){return l.concatBuffers},createData:function(){return qt},deepHash:function(){return w},deserializeTags:function(){return Ot},exportForTesting:function(){return Q},getCryptoDriver:function(){return T},getSignatureAndId:function(){return Xt},indexToType:function(){return St},keccak256:function(){return j},longTo16ByteArray:function(){return Kt},longTo32ByteArray:function(){return _t},longTo8ByteArray:function(){return kt},longToNByteArray:function(){return xt},secp256k1:function(){return tt},serializeTags:function(){return Ut},shortTo2ByteArray:function(){return It},sign:function(){return Ft},stringToBuffer:function(){return l.stringToBuffer},unbundleData:function(){return Jt}});var i={};r.r(i),r.d(i,{default:function(){return ae},processStream:function(){return re},streamExportForTesting:function(){return oe},streamSigner:function(){return ne}});var s=r(91114);class a{constructor(){(0,s.A)(this,"publicKey",void 0),(0,s.A)(this,"signatureType",void 0),(0,s.A)(this,"signatureLength",void 0),(0,s.A)(this,"ownerLength",void 0),(0,s.A)(this,"pem",void 0)}static verify(t,e,r,n){throw new Error("You must implement verify method on child")}}var o,u=r(92166);(function(t){t[t["ARWEAVE"]=1]="ARWEAVE",t[t["ED25519"]=2]="ED25519",t[t["ETHEREUM"]=3]="ETHEREUM",t[t["SOLANA"]=4]="SOLANA",t[t["INJECTEDAPTOS"]=5]="INJECTEDAPTOS",t[t["MULTIAPTOS"]=6]="MULTIAPTOS",t[t["TYPEDETHEREUM"]=7]="TYPEDETHEREUM"})(o||(o={}));const h={[o.ARWEAVE]:{sigLength:512,pubLength:512,sigName:"arweave"},[o.ED25519]:{sigLength:64,pubLength:32,sigName:"ed25519"},[o.ETHEREUM]:{sigLength:65,pubLength:65,sigName:"ethereum"},[o.SOLANA]:{sigLength:64,pubLength:32,sigName:"solana"},[o.INJECTEDAPTOS]:{sigLength:64,pubLength:32,sigName:"injectedAptos"},[o.MULTIAPTOS]:{sigLength:2052,pubLength:1025,sigName:"multiAptos"},[o.TYPEDETHEREUM]:{sigLength:65,pubLength:42,sigName:"typedEthereum"}};var g=r(76735),c=r(90712)["Buffer"];class f{get publicKey(){return this._publicKey}constructor(t,e){(0,s.A)(this,"_key",void 0),(0,s.A)(this,"pk",void 0),(0,s.A)(this,"ownerLength",h[2].pubLength),(0,s.A)(this,"signatureLength",h[2].sigLength),(0,s.A)(this,"_publicKey",void 0),(0,s.A)(this,"signatureType",2),this._key=t,this.pk=e}get key(){throw new Error("You must implement `key`")}sign(t){return(0,g._S)(c.from(t),c.from(this.key))}static async verify(t,e,r){let n=t;return"string"===typeof t&&(n=u.toBuffer(t)),(0,g.MX)(c.from(r),c.from(e),c.from(n))}}var y=r(92636),l=r(88572),d=r(48713);async function w(t){if("function"===typeof t[Symbol.asyncIterator]){const e=t,r=(0,d.createHash)("sha384");let n=0;for await(const t of e)n+=t.byteLength,r.update(t);const i=(0,l.concatBuffers)([(0,l.stringToBuffer)("blob"),(0,l.stringToBuffer)(n.toString())]),s=(0,l.concatBuffers)([await T().hash(i,"SHA-384"),r.digest()]);return await T().hash(s,"SHA-384")}if(Array.isArray(t)){const e=(0,l.concatBuffers)([(0,l.stringToBuffer)("list"),(0,l.stringToBuffer)(t.length.toString())]);return await b(t,await T().hash(e,"SHA-384"))}const e=t,r=(0,l.concatBuffers)([(0,l.stringToBuffer)("blob"),(0,l.stringToBuffer)(e.byteLength.toString())]),n=(0,l.concatBuffers)([await T().hash(r,"SHA-384"),await T().hash(e,"SHA-384")]);return await T().hash(n,"SHA-384")}async function b(t,e){if(t.length<1)return e;const r=(0,l.concatBuffers)([e,await w(t[0])]),n=await T().hash(r,"SHA-384");return await b(t.slice(1),n)}var p=r(86552);const A=y.A["default"]?y.A["default"]:y.A;class v extends A{getPublicKey(t){throw new Error("Unimplemented")}}let m;function T(){return m??=new v}var E=r(26212),S=r(90712)["Buffer"];class L{get publicKey(){return this._publicKey}constructor(t,e){(0,s.A)(this,"_key",void 0),(0,s.A)(this,"pk",void 0),(0,s.A)(this,"signatureType",1),(0,s.A)(this,"ownerLength",h[1].pubLength),(0,s.A)(this,"signatureLength",h[1].sigLength),(0,s.A)(this,"_publicKey",void 0),this._key=t,this.pk=e,e||(this.pk=T().getPublicKey(JSON.parse(t)))}sign(t){return(0,E.createSign)("sha256").update(t).sign({key:this._key,padding:E.constants.RSA_PKCS1_PSS_PADDING})}static async verify(t,e,r){return await T().verify(S.isBuffer(t)?u.encode(t):t,e,r)}}var B=r(9401);class x extends L{constructor(t){super((0,B.ig)(t),t.n),(0,s.A)(this,"jwk",void 0),this.jwk=t}get publicKey(){if(!this.pk)throw new Error("ArweaveSigner - pk is undefined");return u.toBuffer(this.pk)}sign(t){return T().sign(this.jwk,t)}static async verify(t,e,r){const n=T();return await n.verify(t,e,r)}}var k=r(90712)["Buffer"];class I{constructor(t){if((0,s.A)(this,"_publicKey",void 0),(0,s.A)(this,"ownerLength",h[2].pubLength),(0,s.A)(this,"signatureLength",h[2].sigLength),(0,s.A)(this,"signatureType",2),(0,s.A)(this,"pem",void 0),(0,s.A)(this,"provider",void 0),this.provider=t,!this.provider.publicKey)throw new Error("InjectedSolanaSigner - provider.publicKey is undefined");this._publicKey=this.provider.publicKey.toBuffer()}get publicKey(){return this._publicKey}async sign(t){if(!this.provider.signMessage)throw new Error("Selected Wallet does not support message signing");return await this.provider.signMessage(t)}static async verify(t,e,r){let n=t;return"string"===typeof t&&(n=u.toBuffer(t)),(0,g.MX)(k.from(r),k.from(e),k.from(n))}}var K=r(55071),_=r(55580),P=r(93812),M=r(13704),D=r(59020),U=r(90712)["Buffer"];class O{constructor(t){(0,s.A)(this,"signer",void 0),(0,s.A)(this,"publicKey",void 0),(0,s.A)(this,"ownerLength",h[o.ETHEREUM].pubLength),(0,s.A)(this,"signatureLength",h[o.ETHEREUM].sigLength),(0,s.A)(this,"signatureType",o.ETHEREUM),this.signer=t.getSigner()}async setPublicKey(){const t="sign this message to connect to Bundlr.Network",e=await this.signer.signMessage(t),r=await(0,K.A)(t),n=(0,_.jL)((0,P.k9)(r),e);this.publicKey=U.from((0,P.k9)(n))}async sign(t){this.publicKey||await this.setPublicKey();const e=await this.signer.signMessage(t);return U.from(e.slice(2),"hex")}static verify(t,e,r){const n=(0,M.Kt)(t);return(0,D.lT)(e,r)===n}}var H=r(49456);class R extends f{get publicKey(){return H.decode(this.pk)}get key(){return H.decode(this._key)}constructor(t){const e=H.decode(t);super(H.encode(e.subarray(0,32)),H.encode(e.subarray(32,64)))}}var N=r(51878),C=(r(98992),r(41795),r(72487)),$=r(90712),Y=r(3569);function j(t){return t=V(t),Y("keccak256").update(t).digest()}function V(t){if(!$.Buffer.isBuffer(t))if(Array.isArray(t))t=$.Buffer.from(t);else if("string"===typeof t)t=W(t)?$.Buffer.from(J(z(t)),"hex"):$.Buffer.from(t);else if("number"===typeof t)t=F(t);else if(null===t||void 0===t)t=$.Buffer.allocUnsafe(0);else if(C.isBN(t))t=t.toArrayLike($.Buffer);else{if(!t.toArray)throw new Error("invalid type");t=$.Buffer.from(t.toArray())}return t}function W(t,e){return!("string"!==typeof t||!t.match(/^0x[0-9A-Fa-f]*$/))&&(!e||t.length===2+2*e)}function J(t){if("string"!==typeof t)throw new Error(`while padding to even, value must be string, is currently ${typeof t}, while padToEven.`);return t.length%2&&(t=`0${t}`),t}function z(t){return"string"!==typeof t?t:X(t)?t.slice(2):t}function X(t){if("string"!==typeof t)throw new Error("value must be type 'string', is currently type "+typeof t+", while checking isHexPrefixed.");return t.startsWith("0x")}function F(t){const e=G(t);return $.Buffer.from(J(e.slice(2)),"hex")}function G(t){const e=t.toString(16);return`0x${e}`}"undefined"!==typeof window&&(window.keccak256=j);var q=j;const Q={intToBuffer:F,intToHex:G,isHexPrefixed:X,stripHexPrefix:z,padToEven:J,isHexString:W,toBuffer:V};var Z=r(90712)["Buffer"];class tt{constructor(t,e){(0,s.A)(this,"_key",void 0),(0,s.A)(this,"ownerLength",h[o.ETHEREUM].pubLength),(0,s.A)(this,"signatureLength",h[o.ETHEREUM].sigLength),(0,s.A)(this,"signatureType",o.ETHEREUM),(0,s.A)(this,"pk",void 0),this._key=t,this.pk=e.toString("hex")}get publicKey(){throw new Error("You must implement `publicKey`")}get key(){return Z.from(this._key,"hex")}static async verify(t,e,r){let n=t;"string"===typeof t&&(n=u.toBuffer(t));let i=!1;try{i=N.ecdsaVerify(r,q(Z.from(e)),n)}catch(s){}return i}async sign(t){return N.ecdsaSign(q(Z.from(t)),Z.from(this.key)).signature}}var et=r(90712)["Buffer"];class rt extends tt{get publicKey(){return et.from(this.pk,"hex")}constructor(t){t.startsWith("0x")&&(t=t.slice(2));const e=et.from(t,"hex"),r=N.publicKeyCreate(e,!1);super(t,et.from(r))}async sign(t){const e=new D.uW(this._key);return e.signMessage(t).then((t=>et.from(t.slice(2),"hex")))}static async verify(t,e,r){return N.ecdsaVerify(65===r.length?r.slice(0,-1):r,(0,P.k9)((0,K.A)(e)),"string"===typeof t?u.toBuffer(t):t)}}class nt extends rt{}class it extends R{constructor(t){super(t.replace("ed25519:",""))}}var st=r(90712)["Buffer"];class at extends f{get publicKey(){return st.from(this.pk)}get key(){return st.from(this._key)}constructor(t,e){super(t.subarray(0,32),e)}}var ot=r(90712)["Buffer"];class ut extends I{constructor(t){super(t),(0,s.A)(this,"signatureType",4)}async sign(t){return super.sign(ot.from(ot.from(t).toString("hex")))}static async verify(t,e,r){return super.verify(t,ot.from(ot.from(e).toString("hex")),r)}}var ht=r(90712)["Buffer"];class gt extends R{constructor(t){super(t),(0,s.A)(this,"signatureType",4)}async sign(t){return super.sign(ht.from(ht.from(t).toString("hex")))}static async verify(t,e,r){return super.verify(t,ht.from(ht.from(e).toString("hex")),r)}}var ct=r(90712)["Buffer"];class ft extends f{constructor(t,e){super(t,e)}get publicKey(){return ct.from(this.pk.slice(2),"hex")}get key(){return ct.from(this._key.slice(2),"hex")}}var yt=r(90712)["Buffer"];class lt{constructor(t,e){(0,s.A)(this,"_publicKey",void 0),(0,s.A)(this,"ownerLength",h[o.INJECTEDAPTOS].pubLength),(0,s.A)(this,"signatureLength",h[o.INJECTEDAPTOS].sigLength),(0,s.A)(this,"signatureType",o.INJECTEDAPTOS),(0,s.A)(this,"pem",void 0),(0,s.A)(this,"provider",void 0),this.provider=t,this._publicKey=e}get publicKey(){return this._publicKey}async sign(t){if(!this.provider.signMessage)throw new Error("Selected Wallet does not support message signing");const e=await this.provider.signMessage({message:yt.from(t).toString("hex"),nonce:"bundlr"});return yt.from(e.signature,"hex")}static async verify(t,e,r){const n=t;return(0,g.MX)(yt.from(r),yt.from(`APTOS\nmessage: ${yt.from(e).toString("hex")}\nnonce: bundlr`),yt.from(n))}}r(16573),r(78100),r(77936),r(17642),r(58004),r(33853),r(45876),r(32475),r(15024),r(31698),r(37467),r(44732),r(79577),r(3949);var dt=r(90712)["Buffer"];class wt{constructor(t,e){(0,s.A)(this,"_publicKey",void 0),(0,s.A)(this,"ownerLength",h[o.MULTIAPTOS].pubLength),(0,s.A)(this,"signatureLength",h[o.MULTIAPTOS].sigLength),(0,s.A)(this,"signatureType",o.MULTIAPTOS),(0,s.A)(this,"collectSignatures",void 0),(0,s.A)(this,"provider",void 0),this._publicKey=t,this.collectSignatures=e}get publicKey(){return this._publicKey}async sign(t){const{signatures:e,bitmap:r}=await this.collectSignatures(t),n=128,i=new Uint8Array([0,0,0,0]),s=new Set;r.forEach((t=>{if(t>=32)throw new Error(`Invalid bit value ${t}.`);if(s.has(t))throw new Error("Duplicated bits detected.");s.add(t);const e=Math.floor(t/8);let r=i[e];r|=n>>t%8,i[e]=r}));const a=dt.alloc(this.signatureLength);let o=0;for(let u=0;u<32;u++)r.includes(u)&&a.set(e[o++],64*u);return a.set(i,this.signatureLength-4),a}static async verify(t,e,r){const n=h[o.MULTIAPTOS].sigLength,i=n-4,s=r.slice(0,i),a=r.slice(i);let u=!1;for(let o=0;o<32;o++){const r=Math.floor(o/8),n=o-8*r,i=0!==(a[r]&128>>n);if(i){const r=s.slice(64*o,64*(o+1)),n=t.slice(32*o,32*(o+1));await(0,g.MX)(dt.from(r),dt.from(e),dt.from(n))||(u=!0)}}return!u}}var bt=r(90712)["Buffer"];class pt extends rt{constructor(t){super(t),(0,s.A)(this,"ownerLength",h[o.TYPEDETHEREUM].pubLength),(0,s.A)(this,"signatureLength",h[o.TYPEDETHEREUM].sigLength),(0,s.A)(this,"signatureType",o.TYPEDETHEREUM),(0,s.A)(this,"address",void 0),(0,s.A)(this,"signer",void 0),this.address="0x"+q(super.publicKey.slice(1)).slice(-20).toString("hex"),this.signer=new D.uW(t)}get publicKey(){return bt.from(this.address)}async sign(t){const e=await this.signer._signTypedData(At,vt,{address:this.address,"Transaction hash":t});return bt.from(e.slice(2),"hex")}static async verify(t,e,r){const n=t.toString(),i=(0,D.wh)(At,vt,{address:n,"Transaction hash":e},r);return n.toLowerCase()===i.toLowerCase()}}const At={name:"Bundlr",version:"1"},vt={Bundlr:[{name:"Transaction hash",type:"bytes"},{name:"address",type:"address"}]};var mt=r(90712)["Buffer"];class Tt{constructor(t){(0,s.A)(this,"ownerLength",h[o.TYPEDETHEREUM].pubLength),(0,s.A)(this,"signatureLength",h[o.TYPEDETHEREUM].sigLength),(0,s.A)(this,"signatureType",o.TYPEDETHEREUM),(0,s.A)(this,"address",void 0),(0,s.A)(this,"signer",void 0),(0,s.A)(this,"publicKey",void 0),this.signer=t.getSigner()}async ready(){this.address=(await this.signer.getAddress()).toString().toLowerCase(),this.publicKey=mt.from(this.address)}async sign(t){const e=await this.signer._signTypedData(At,vt,{address:this.address,"Transaction hash":t});return mt.from(e.slice(2),"hex")}static verify(t,e,r){const n=t.toString(),i=(0,D.wh)(At,vt,{address:n,"Transaction hash":e},r);return n.toLowerCase()===i.toLowerCase()}}r(81454);class Et{constructor(t,e){(0,s.A)(this,"signer",void 0),(0,s.A)(this,"publicKey",void 0),(0,s.A)(this,"ownerLength",h[o.ARWEAVE].pubLength),(0,s.A)(this,"signatureLength",h[o.ARWEAVE].sigLength),(0,s.A)(this,"signatureType",o.ARWEAVE),(0,s.A)(this,"arweave",void 0),this.signer=t,this.arweave=e}async setPublicKey(){const t=await this.signer.getActivePublicKey();this.publicKey=u.toBuffer(t)}async sign(t){this.publicKey||await this.setPublicKey();const e={name:"RSA-PSS",saltLength:32},r=await this.signer.signature(t,e),n=new Uint8Array(Object.values(r).map((t=>+t)));return n}static async verify(t,e,r){return await T().verify(t,e,r)}}const St={1:x,2:f,3:rt,4:ut,5:lt,6:wt,7:pt};async function Lt(t){return w([(0,l.stringToBuffer)("dataitem"),(0,l.stringToBuffer)("1"),(0,l.stringToBuffer)(t.signatureType.toString()),t.rawOwner,t.rawTarget,t.rawAnchor,t.rawTags,t.rawData])}var Bt=Lt;function xt(t,e){const r=new Uint8Array(t);if(e<0)throw new Error("Array is unsigned, cannot represent -ve numbers");if(e>2**(8*t)-1)throw new Error(`Number ${e} is too large for an array of ${t} bytes`);for(let n=0;n<r.length;n++){const t=255&e;r[n]=t,e=(e-t)/256}return r}function kt(t){return xt(8,t)}function It(t){return xt(2,t)}function Kt(t){return xt(16,t)}function _t(t){return xt(32,t)}function Pt(t){let e=0;for(let r=t.length-1;r>=0;r--)e=256*e+t[r];return e}r(44114);var Mt=r(90712)["Buffer"];class Dt{constructor(t=Mt.alloc(Rt),e=0){(0,s.A)(this,"buf",void 0),(0,s.A)(this,"pos",void 0),this.buf=t,this.pos=e}writeTags(t){if(!Array.isArray(t))throw new Error("input must be array");const e=t.length;let r;if(e)for(this.writeLong(e),r=0;r<e;r++){const e=t[r];if("string"!==typeof e?.name||"string"!==typeof e?.value)throw new Error(`Invalid tag format for ${e}, expected {name:string, value: string}`);this.writeString(e.name),this.writeString(e.value)}this.writeLong(0)}toBuffer(){const t=Mt.alloc(this.pos);if(this.pos>this.buf.length)throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);return this.buf.copy(t,0,0,this.pos),t}writeLong(t){const e=this.buf;let r,n;if(t>=-1073741824&&t<1073741824){n=t>=0?t<<1:~t<<1|1;do{e[this.pos]=127&n,n>>=7}while(n&&(e[this.pos++]|=128))}else{r=t>=0?2*t:2*-t-1;do{e[this.pos]=127&r,r/=128}while(r>=1&&(e[this.pos++]|=128))}this.pos++,this.buf=e}writeString(t){const e=Mt.byteLength(t),r=this.buf;this.writeLong(e);let n=this.pos;if(this.pos+=e,!(this.pos>r.length)){if(e>64)this.buf.write(t,this.pos-e,e,"utf8");else{let i,s,a,o;for(i=0,s=e;i<s;i++)a=t.charCodeAt(i),a<128?r[n++]=a:a<2048?(r[n++]=a>>6|192,r[n++]=63&a|128):55296===(64512&a)&&56320===(64512&(o=t.charCodeAt(i+1)))?(a=65536+((1023&a)<<10)+(1023&o),i++,r[n++]=a>>18|240,r[n++]=a>>12&63|128,r[n++]=a>>6&63|128,r[n++]=63&a|128):(r[n++]=a>>12|224,r[n++]=a>>6&63|128,r[n++]=63&a|128)}this.buf=r}}readLong(){let t=0,e=0;const r=this.buf;let n,i,s,a;do{n=r[this.pos++],i=128&n,t|=(127&n)<<e,e+=7}while(i&&e<28);if(i){s=t,a=268435456;do{n=r[this.pos++],s+=(127&n)*a,a*=128}while(128&n);return(s%2?-(s+1):s)/2}return t>>1^-(1&t)}skipLong(){const t=this.buf;while(128&t[this.pos++]);}readTags(){const t=[];let e;while(e=this.readLong()){e<0&&(e=-e,this.skipLong());while(e--){const e=this.readString(),r=this.readString();t.push({name:e,value:r})}}return t}readString(){const t=this.readLong(),e=this.pos,r=this.buf;if(this.pos+=t,this.pos>r.length)throw new Error("TAP Position out of range");return this.buf.slice(e,e+t).toString()}}function Ut(t){if(0===t?.length)return Mt.allocUnsafe(0);const e=new Dt;return e.writeTags(t),e.toBuffer()}function Ot(t){const e=new Dt(t);return e.readTags()}const Ht=80,Rt=4096;class Nt{constructor(t){(0,s.A)(this,"binary",void 0),(0,s.A)(this,"_id",void 0),this.binary=t}static isDataItem(t){return void 0!==t.binary}get signatureType(){const t=Pt(this.binary.subarray(0,2));if(void 0!==o?.[t])return t;throw new Error("Unknown signature type: "+t)}async isValid(){return Nt.verify(this.binary)}get id(){return u.encode(this.rawId)}set id(t){this._id=u.toBuffer(t)}get rawId(){return(0,d.createHash)("sha256").update(this.rawSignature).digest()}set rawId(t){this._id=t}get rawSignature(){return this.binary.subarray(2,2+this.signatureLength)}get signature(){return u.encode(this.rawSignature)}set rawOwner(t){if(t.byteLength!=this.ownerLength)throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t.byteLength} bytes.`);this.binary.set(t,2+this.signatureLength)}get rawOwner(){return this.binary.subarray(2+this.signatureLength,2+this.signatureLength+this.ownerLength)}get signatureLength(){return h[this.signatureType].sigLength}get owner(){return u.encode(this.rawOwner)}get ownerLength(){return h[this.signatureType].pubLength}get rawTarget(){const t=this.getTargetStart(),e=1==this.binary[t];return e?this.binary.subarray(t+1,t+33):$.Buffer.alloc(0)}get target(){return u.encode(this.rawTarget)}get rawAnchor(){const t=this.getAnchorStart(),e=1==this.binary[t];return e?this.binary.subarray(t+1,t+33):$.Buffer.alloc(0)}get anchor(){return this.rawAnchor.toString()}get rawTags(){const t=this.getTagsStart(),e=Pt(this.binary.subarray(t+8,t+16));return this.binary.subarray(t+16,t+16+e)}get tags(){const t=this.getTagsStart(),e=Pt(this.binary.subarray(t,t+8));if(0==e)return[];const r=Pt(this.binary.subarray(t+8,t+16));return Ot($.Buffer.from(this.binary.subarray(t+16,t+16+r)))}get tagsB64Url(){const t=this.tags;return t.map((t=>({name:u.encode(t.name),value:u.encode(t.value)})))}getStartOfData(){const t=this.getTagsStart(),e=this.binary.subarray(t+8,t+16),r=Pt(e);return t+16+r}get rawData(){const t=this.getTagsStart(),e=this.binary.subarray(t+8,t+16),r=Pt(e),n=t+16+r;return this.binary.subarray(n,this.binary.length)}get data(){return u.encode(this.rawData)}getRaw(){return this.binary}async sign(t){return this._id=await Ft(this,t),this.rawId}async setSignature(t){this.binary.set(t,2),this._id=$.Buffer.from(await T().hash(t))}isSigned(){return(this._id?.length??0)>0}toJSON(){return{signature:this.signature,owner:this.owner,target:this.target,tags:this.tags.map((t=>({name:u.encode(t.name),value:u.encode(t.value)}))),data:this.data}}static async verify(t){if(t.byteLength<Ht)return!1;const e=new Nt(t),r=e.signatureType,n=e.getTagsStart(),i=Pt(t.subarray(n,n+8)),s=t.subarray(n+8,n+16),a=Pt(s);if(a>Rt)return!1;if(i>0)try{const e=Ot($.Buffer.from(t.subarray(n+16,n+16+a)));if(e.length!==i)return!1}catch(h){return!1}const o=St[r],u=await Bt(e);return await o.verify(e.rawOwner,u,e.rawSignature)}async getSignatureData(){return Bt(this)}getTagsStart(){const t=this.getTargetStart(),e=1==this.binary[t];let r=t+(e?33:1);const n=1==this.binary[r];return r+=n?33:1,r}getTargetStart(){return 2+this.signatureLength+this.ownerLength}getAnchorStart(){let t=this.getTargetStart()+1;const e=1==this.binary[this.getTargetStart()];return t+=e?32:0,t}}var Ct=Nt,$t=r(90712)["Buffer"];const Yt=32;class jt{constructor(t){(0,s.A)(this,"length",void 0),(0,s.A)(this,"items",void 0),(0,s.A)(this,"binary",void 0),this.binary=t,this.length=this.getDataItemCount(),this.items=this.getItems()}getRaw(){return this.binary}get(t){if("number"===typeof t){if(t>=this.length)throw new RangeError("Index out of range");return this.getByIndex(t)}return this.getById(t)}getSizes(){const t=[];for(let e=Yt;e<Yt+64*this.length;e+=64)t.push(Pt(this.binary.subarray(e,e+32)));return t}getIds(){const t=[];for(let e=Yt;e<Yt+64*this.length;e+=64){const r=this.binary.subarray(e+32,e+64);if(0===r.length)throw new Error("Invalid bundle, id specified in headers doesn't exist");t.push(u.encode(r))}return t}getIdBy(t){if(t>this.length-1)throw new RangeError("Index of bundle out of range");const e=64+64*t;return u.encode(this.binary.subarray(e,e+32))}async toTransaction(t,e,r){const n=await e.createTransaction({data:this.binary,...t},r);return n.addTag("Bundle-Format","binary"),n.addTag("Bundle-Version","2.0.0"),n}async verify(){for(const t of this.items){const e=await t.isValid(),r=u((0,d.createHash)("sha256").update(t.rawSignature).digest());if(!e||t.id!==r)return!1}return!0}getOffset(t){let e=0;for(let r=Yt;r<Yt+64*this.length;r+=64){const n=Pt(this.binary.subarray(r,r+32));e+=n;const i=this.binary.subarray(r+32,r+64);if(0===$t.compare(i,t))return{startOffset:e,size:n}}return{startOffset:-1,size:-1}}getByIndex(t){let e=0;const r=this.getBundleStart();let n,i,s=0;for(let h=Yt;h<Yt+64*this.length;h+=64){if(n=Pt(this.binary.subarray(h,h+32)),s++===t){i=this.binary.subarray(h+32,h+64);break}e+=n}const a=r+e,o=this.binary.subarray(a,a+n),u=new Ct(o);return u.rawId=i,u}getById(t){const e=u.toBuffer(t),r=this.getOffset(e);if(-1===r.startOffset)throw new Error("Transaction not found");const n=this.getBundleStart(),i=n+r.startOffset;return new Ct(this.binary.subarray(i,i+r.size))}getDataItemCount(){return Pt(this.binary.subarray(0,32))}getBundleStart(){return 32+64*this.length}getItems(){const t=new Array(this.length);let e=0;const r=this.getBundleStart();let n=0;for(let i=Yt;i<Yt+64*this.length;i+=64){const s=Pt(this.binary.subarray(i,i+32)),a=this.binary.subarray(i+32,i+64);if(0===a.length)throw new Error("Invalid bundle, id specified in headers doesn't exist");const o=r+e,u=this.binary.subarray(o,o+s);e+=s;const h=new Ct(u);h.rawId=a,t[n]=h,n++}return t}}var Vt=jt,Wt=r(90712)["Buffer"];function Jt(t){return new Vt(t)}async function zt(t,e){const r=new Uint8Array(64*t.length),n=await Promise.all(t.map((async(t,n)=>{const i=t.isSigned()?t.rawId:await Ft(t,e),s=new Uint8Array(64);return s.set(_t(t.getRaw().byteLength),0),s.set(i,32),r.set(s,64*n),t.getRaw()}))).then((t=>Wt.concat(t))),i=Wt.concat([Wt.from(_t(t.length)),Wt.from(r),n]);return new Vt(i)}async function Xt(t,e){const r=await Bt(t),n=await e.sign(r),i=await T().hash(n);return{signature:Wt.from(n),id:Wt.from(i)}}async function Ft(t,e){const{signature:r,id:n}=await Xt(t,e);return t.getRaw().set(r,2),n}var Gt=r(90712)["Buffer"];function qt(t,e,r){const n=e.publicKey,i=r?.target?u.toBuffer(r.target):null,s=1+(i?.byteLength??0),a=r?.anchor?Gt.from(r.anchor):null,o=1+(a?.byteLength??0),h=(r?.tags?.length??0)>0?Ut(r?.tags):null,g=16+(h?h.byteLength:0),c=Gt.from(t),f=c.byteLength,y=2+e.signatureLength+e.ownerLength+s+o+g+f,l=Gt.alloc(y);if(l.set(It(e.signatureType),0),l.set(new Uint8Array(e.signatureLength).fill(0),2),n.byteLength!==e.ownerLength)throw new Error(`Owner must be ${e.ownerLength} bytes, but was incorrectly ${n.byteLength}`);l.set(n,2+e.signatureLength);const d=2+e.signatureLength+e.ownerLength;if(l[d]=i?1:0,i){if(32!==i.byteLength)throw new Error(`Target must be 32 bytes but was incorrectly ${i.byteLength}`);l.set(i,d+1)}const w=d+s;let b=w+1;if(l[w]=a?1:0,a){if(b+=a.byteLength,32!==a.byteLength)throw new Error("Anchor must be 32 bytes");l.set(a,w+1)}l.set(kt(r?.tags?.length??0),b);const p=kt(h?.byteLength??0);l.set(p,b+8),h&&l.set(h,b+16);const A=b+g;return l.set(c,A),new Ct(l)}class Qt{constructor(){(0,s.A)(this,"signatureType",void 0),(0,s.A)(this,"rawSignature",void 0),(0,s.A)(this,"signature",void 0),(0,s.A)(this,"signatureLength",void 0),(0,s.A)(this,"rawOwner",void 0),(0,s.A)(this,"owner",void 0),(0,s.A)(this,"ownerLength",void 0),(0,s.A)(this,"rawTarget",void 0),(0,s.A)(this,"target",void 0),(0,s.A)(this,"rawAnchor",void 0),(0,s.A)(this,"anchor",void 0),(0,s.A)(this,"rawTags",void 0),(0,s.A)(this,"tags",void 0),(0,s.A)(this,"rawData",void 0),(0,s.A)(this,"data",void 0)}static async verify(...t){throw new Error("You must implement `verify`")}}Error;var Zt=r(28047),te=r(45120),ee=r(90712)["Buffer"];async function re(t){const e=se(t);let r=(await e.next()).value;r=await ie(e,r,32);const n=Pt(r.subarray(0,32));r=r.subarray(32);const i=64*n;r=await ie(e,r,i);const s=new Array(n);for(let h=0;h<i;h+=64)s[h/64]=[Pt(r.subarray(h,h+32)),u(ee.from(r.subarray(h+32,h+64)))];r=r.subarray(i);let a=32+i;const o=[];for(const[g,c]of s){r=await ie(e,r,Ht),r=await ie(e,r,2);const t=Pt(r.subarray(0,2));r=r.subarray(2);const{sigLength:n,pubLength:i,sigName:s}=h[t];r=await ie(e,r,n);const f=r.subarray(0,n);r=r.subarray(n),r=await ie(e,r,i);const y=r.subarray(0,i);r=r.subarray(i),r=await ie(e,r,1);const d=1===r[0];d&&(r=await ie(e,r,33));const b=d?r.subarray(1,33):ee.allocUnsafe(0);r=r.subarray(d?33:1),r=await ie(e,r,1);const p=1===r[0];p&&(r=await ie(e,r,33));const A=p?r.subarray(1,33):ee.allocUnsafe(0);r=r.subarray(p?33:1),r=await ie(e,r,8);const v=Pt(r.subarray(0,8));r=r.subarray(8),r=await ie(e,r,8);const m=Pt(r.subarray(0,8));r=r.subarray(8),r=await ie(e,r,m);const T=r.subarray(0,m),E=0!==v&&0!==m?Ot(ee.from(T)):[];if(E.length!==v)throw new Error("Tags lengths don't match");r=r.subarray(m);const S=new Zt.Transform;S._transform=function(t,e,r){this.push(t),r()};const L=w([(0,l.stringToBuffer)("dataitem"),(0,l.stringToBuffer)("1"),(0,l.stringToBuffer)(t.toString()),y,b,A,T,S]),B=2+n+i+(d?33:1)+(p?33:1)+16+m,x=g-B;if(r.byteLength>x)S.write(r.subarray(0,x)),r=r.subarray(x);else{let t=r.byteLength;S.write(r);while(x>t){if(r=(await e.next()).value,!r)throw new Error(`Not enough data bytes  expected: ${x} received: ${t}`);t+=r.byteLength,t>x?S.write(r.subarray(0,r.byteLength-(t-x))):S.write(r)}r=r.subarray(r.byteLength-(t-x))}if(S.end(),c!==u((0,te.createHash)("sha256").update(f).digest()))throw new Error("ID doesn't match signature");const k=St[t];if(!await k.verify(y,await L,f))throw new Error("Invalid signature");o.push({id:c,sigName:s,signature:u(ee.from(f)),target:u(ee.from(b)),anchor:u(ee.from(A)),owner:u(ee.from(y)),tags:E,dataOffset:a+B,dataSize:x}),a+=B+x}return o}async function ne(t,e,r,n){const i=qt("",r,n),s=new Zt.PassThrough,a=[(0,l.stringToBuffer)("dataitem"),(0,l.stringToBuffer)("1"),(0,l.stringToBuffer)(i.signatureType.toString()),i.rawOwner,i.rawTarget,i.rawAnchor,i.rawTags,t],o=await w(a),u=ee.from(await r.sign(o));return i.setSignature(u),s.write(i.getRaw()),e.pipe(s)}async function ie(t,e,r){if(e.byteLength>=r)return e;const{done:n,value:i}=await t.next();if(n&&!i)throw new Error("Invalid buffer");return ie(t,ee.concat([ee.from(e),ee.from(i)]),r)}async function*se(t){for await(const e of t)yield e}var ae=re;const oe={readBytes:ie,getReader:se},ue={...n,stream:i};globalThis.arbundles??=ue}}]);
//# sourceMappingURL=vendor.arbundles.f42b5336.js.map