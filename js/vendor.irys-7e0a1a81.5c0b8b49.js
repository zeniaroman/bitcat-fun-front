(self["webpackChunkapp"]=self["webpackChunkapp"]||[]).push([[9823],{68303:function(t,e,r){"use strict";function n(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var n=0;n<t.length;n++){var i=t.charAt(n),a=i.charCodeAt(0);if(255!==e[a])throw new TypeError(i+" is ambiguous");e[a]=n}var s=t.length,o=t.charAt(0),c=Math.log(s)/Math.log(256),d=Math.log(256)/Math.log(s);function h(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";var r=0,n=0,i=0,a=e.length;while(i!==a&&0===e[i])i++,r++;var c=(a-i)*d+1>>>0,h=new Uint8Array(c);while(i!==a){for(var u=e[i],l=0,g=c-1;(0!==u||l<n)&&-1!==g;g--,l++)u+=256*h[g]>>>0,h[g]=u%s>>>0,u=u/s>>>0;if(0!==u)throw new Error("Non-zero carry");n=l,i++}var w=c-n;while(w!==c&&0===h[w])w++;for(var p=o.repeat(r);w<c;++w)p+=t.charAt(h[w]);return p}function u(t){if("string"!==typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var r=0,n=0,i=0;while(t[r]===o)n++,r++;var a=(t.length-r)*c+1>>>0,d=new Uint8Array(a);while(t[r]){var h=t.charCodeAt(r);if(h>255)return;var u=e[h];if(255===u)return;for(var l=0,g=a-1;(0!==u||l<i)&&-1!==g;g--,l++)u+=s*d[g]>>>0,d[g]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=l,r++}var w=a-i;while(w!==a&&0===d[w])w++;var p=new Uint8Array(n+(a-w)),y=n;while(w!==a)p[y++]=d[w++];return p}function l(t){var e=u(t);if(e)return e;throw new Error("Non-base"+s+" character")}return{encode:h,decodeUnsafe:u,decode:l}}r(16573),r(78100),r(77936),r(37467),r(44732),r(79577),t.exports=n},91652:function(t,e,r){const n=r(68303),i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";t.exports=n(i)},40292:function(t,e,r){"use strict";r.r(e),r.d(e,{WebIrys:function(){return vt},default:function(){return vt}});var n={};r.r(n),r.d(n,{DataItem:function(){return x.sO},bundleAndSignData:function(){return x.Jv},createData:function(){return x.vd},deepHash:function(){return x.T4},getCryptoDriver:function(){return x.G8},stringToBuffer:function(){return x.Xg}});var i=r(91114);r(14603),r(47566),r(98721);const a=()=>{throw new Error("Unimplemented")};globalThis.crypto??={},globalThis.crypto.subtle??={},globalThis.crypto.subtle.generateKey??=a,globalThis.crypto.subtle.importKey??=a,globalThis.crypto.subtle.exportKey??=a,globalThis.crypto.subtle.digest??=a,globalThis.crypto.subtle.sign??=a;var s=r(94373),o=r(20737),c=r(24005),d=r(90712)["Buffer"];function h(t){class e extends t.arbundles.DataItem{constructor(t,e,r){super(!0===r?.dataIsRawTransaction?d.from(t):e.arbundles.createData(t,e.tokenConfig.getSigner(),{...r,anchor:r?.anchor??c.randomBytes(32).toString("base64").slice(0,32)}).getRaw()),(0,i.A)(this,"Irys",void 0),(0,i.A)(this,"signer",void 0),this.Irys=e,this.signer=e.tokenConfig.getSigner()}sign(){return super.sign(this.signer)}get size(){return this.getRaw().length}async uploadWithReceipt(t){return(await this.Irys.uploader.uploadTransaction(this,{...t,getReceiptSignature:!0})).data}async upload(t){return(await this.Irys.uploader.uploadTransaction(this,t)).data}async getPrice(){return this.Irys.utils.getPrice(this.Irys.tokenConfig.name,this.size)}async isValid(){return t.arbundles.DataItem.verify(this.getRaw())}}return e}r(98992),r(8872);var u=r(92166),l=r(74013),g=r(94348);l.A.set({DECIMAL_PLACES:50});const w=t=>new Promise((e=>setTimeout(e,t)));class p{constructor(t,e,r){(0,i.A)(this,"api",void 0),(0,i.A)(this,"token",void 0),(0,i.A)(this,"tokenConfig",void 0),(0,i.A)(this,"arbundles",void 0),this.api=t,this.token=e,this.tokenConfig=r,this.arbundles=this.tokenConfig.irys.arbundles}static checkAndThrow(t,e,r){if(t?.status&&!(r??[]).includes(t.status)&&200!=t.status)throw new Error(`HTTP Error: ${e}: ${t.status} ${"string"!==typeof t.data?t.statusText:t.data}`)}async getNonce(){const t=await this.api.get(`/account/withdrawals/${this.tokenConfig.name}?address=${this.tokenConfig.address}`);return p.checkAndThrow(t,"Getting withdrawal nonce"),t.data}async getBalance(t){const e=await this.api.get(`/account/balance/${this.tokenConfig.name}?address=${t}`);return p.checkAndThrow(e,"Getting balance"),new l.A(e.data.balance)}async getBundlerAddress(t){const e=await this.api.get("/info");p.checkAndThrow(e,"Getting Bundler address");const r=e.data.addresses[t];if(!r)throw new Error(`Specified bundler does not support token ${t}`);return r}async getPrice(t,e){const r=await this.api.get(`/price/${t}/${e}`);return p.checkAndThrow(r,"Getting storage cost"),new l.A(r.data)}async estimateFolderPrice(t){Array.isArray(t)&&(t={fileCount:t.length,totalBytes:t.reduce(((t,e)=>t+e),0)});const e=t.headerSizeAvg??this.arbundles.createData("",this.tokenConfig.getSigner()).getRaw().length,r=await this.getPrice(this.tokenConfig.name,e),n=r.multipliedBy(t.fileCount),i=(await this.getPrice(this.tokenConfig.name,t.totalBytes)).plus(n).decimalPlaces(0);return i}toAtomic(t){return new l.A(t).multipliedBy(this.tokenConfig.base[1])}fromAtomic(t){return new l.A(t).dividedBy(this.tokenConfig.base[1])}async confirmationPoll(t,e=30){if(this.tokenConfig.isSlow)return;let r,n;e<0&&(e=0);const i=async()=>{while(!n){const e=await this.tokenConfig.getTx(t).then((t=>t?.confirmed)).catch((t=>(r=t,!1)));if(e)return!0;await w(1e3)}return!1},a=async()=>(await w(1e3*e),n=!0,"RACE"),s=await Promise.race([a(),i()]);return"RACE"===s?(g.warn(`Tx ${t} didn't finalize after ${e} seconds ${r?` - ${r}`:""}`),r):s}unitConverter(t){return new l.A(t).dividedBy(this.tokenConfig.base[1])}async verifyReceipt(t){return p.verifyReceipt(this.arbundles,t)}static async verifyReceipt(t,e){const{id:r,deadlineHeight:n,timestamp:i,public:a,signature:s,version:o}=e,c=await t.deepHash([t.stringToBuffer("Bundlr"),t.stringToBuffer(o),t.stringToBuffer(r),t.stringToBuffer(n.toString()),t.stringToBuffer(i.toString())]);return await t.getCryptoDriver().verify(a,c,u.toBuffer(s))}async getReceipt(t){const e=`query {\n      transactions(ids: ["${t}"]) {\n        edges {\n          node {\n            receipt {\n              signature\n              timestamp\n              version\n              deadlineHeight\n            }\n          }\n        }\n      }\n    }`,r=await o((async()=>await this.api.post("/graphql",{query:e},{headers:{"content-type":"application/json"},validateStatus:t=>200===t}))),n=r?.data?.data?.transactions?.edges?.at(0)?.node?.receipt;if(!n)throw new Error(`Missing required receipt data from node for tx: ${t}`);const i=(await this.api.get("/public")).data,a={public:i,version:n.version,id:t,timestamp:n.timestamp,validatorSignatures:[],signature:n.signature,deadlineHeight:n.deadlineHeight,verify:async()=>!1};return a.verify=async()=>this.verifyReceipt(a),a}}var y=r(90712)["Buffer"];async function f(t,e,r){const n=t.tokenConfig,{deepHash:i,stringToBuffer:a}=n.irys.arbundles,s=await n.getPublicKey(),o={publicKey:s,currency:t.token,amount:new l.A(r).toString(),nonce:await t.getNonce(),signature:"",sigType:n.getSigner().signatureType},c=await i([a(o.currency),a(o.amount.toString()),a(o.nonce.toString())]);y.isBuffer(o.publicKey)||(o.publicKey=y.from(o.publicKey));const d=await n.sign(c),h=await n.verify(o.publicKey,c,d);o.publicKey=u.encode(o.publicKey),o.signature=u.encode(y.from(d));const g=u.toBuffer(o.publicKey),w=u.toBuffer(o.signature),f=await i([a(o.currency),a(o.amount.toString()),a(o.nonce.toString())]),m=await n.verify(g,f,w),v=n.ownerToAddress("arweave"==n.name?u.decode(o.publicKey):u.toBuffer(o.publicKey))===n.address;if(!(h||m||v))throw new Error(`Internal withdrawal validation failed - please report this!\nDebug Info:${JSON.stringify(o)}`);const b=await e.post("/account/withdraw",o);if(202===b.status){const e=b.data.tx_id,r=await t.confirmationPoll(e);if(!0!==r)throw new Error(`Unable to confirm withdrawal tx ${e} ${r?r?.toString():""}`)}else p.checkAndThrow(b,"Withdrawing balance");return b.data}var m=r(13449);class v{constructor({url:t,arbundles:e}){(0,i.A)(this,"api",void 0),(0,i.A)(this,"utils",void 0),(0,i.A)(this,"uploader",void 0),(0,i.A)(this,"funder",void 0),(0,i.A)(this,"address",void 0),(0,i.A)(this,"token",void 0),(0,i.A)(this,"tokenConfig",void 0),(0,i.A)(this,"provenance",void 0),(0,i.A)(this,"transactions",void 0),(0,i.A)(this,"_readyPromise",void 0),(0,i.A)(this,"url",void 0),(0,i.A)(this,"arbundles",void 0),(0,i.A)(this,"IrysTransaction",void 0),this.url=t,this.arbundles=e,this.IrysTransaction=h(this)}get signer(){return this.tokenConfig.getSigner()}get search(){const t=new m.A({url:new URL("/graphql",this.url)});return t.search.bind(t)}query(t){return new m.A(t??{url:this.url})}async withdrawBalance(t){return f(this.utils,this.api,t)}async getLoadedBalance(){if(!this.address)throw new Error("address is undefined");return this.utils.getBalance(this.address)}async getBalance(t){return this.utils.getBalance(t)}async fund(t,e){return this.funder.fund(t,e)}async getPrice(t){return this.utils.getPrice(this.token,t)}async verifyReceipt(t){return p.verifyReceipt(this.arbundles,t)}createTransaction(t,e){return new this.IrysTransaction(t,this,e)}getSigner(){return this.tokenConfig.getSigner()}async upload(t,e){return this.uploader.uploadData(t,e)}async uploadWithReceipt(t,e){return this.uploader.uploadData(t,{...e,upload:{getReceiptSignature:!0}})}async ready(){return!this.tokenConfig.ready||await this.tokenConfig.ready(),this.address=this.tokenConfig.address,this}get transaction(){const t=this;return{fromRaw(e){return new t.IrysTransaction(e,t,{dataIsRawTransaction:!0})}}}}(0,i.A)(v,"VERSION","0.0.2");var b=r(94348);class A{constructor(t){(0,i.A)(this,"_instance",void 0),(0,i.A)(this,"cookieMap",new Map),(0,i.A)(this,"config",void 0),t&&this.applyConfig(t)}applyConfig(t){this.config=this.mergeDefaults(t),this._instance=void 0}getConfig(){return this.config}async requestInterceptor(t){const e=this.cookieMap.get(new URL(t.baseURL??"").host);return e&&(t.headers.cookie=e),t}async responseInterceptor(t){const e=t.headers?.["set-cookie"];return e&&this.cookieMap.set(t.request.host,e),t}mergeDefaults(t){return{url:t.url,timeout:t.timeout??2e4,logging:t.logging??!1,logger:t.logger??b.log,headers:{...t.headers,"x-irys-js-sdk-version":v.VERSION},withCredentials:t.withCredentials??!1,retry:{retries:3,maxTimeout:5e3}}}async get(t,e){try{return await this.request(t,{...e,method:"GET"})}catch(r){if(r.response?.status)return r.response;throw r}}async post(t,e,r){try{return await this.request(t,{data:e,...r,method:"POST"})}catch(n){if(n.response?.status)return n.response;throw n}}get instance(){if(this._instance)return this._instance;const t=s.A.create({baseURL:this.config.url.toString(),timeout:this.config.timeout,maxContentLength:536870912,headers:this.config.headers,withCredentials:this.config.withCredentials});return this.config.withCredentials&&(t.interceptors.request.use(this.requestInterceptor.bind(this)),t.interceptors.response.use(this.responseInterceptor.bind(this))),this.config.logging&&(t.interceptors.request.use((t=>(this.config.logger(`Requesting: ${t.baseURL}/${t.url}`),t))),t.interceptors.response.use((t=>(this.config.logger(`Response: ${t.config.url} - ${t.status}`),t)))),this._instance=t}async request(t,e){const r=this.instance,n=e?.url??new URL(t,this.config.url).toString();return o((t=>r({...e,url:n})),{...this.config.retry,...e?.retry})}}class k{constructor(t){(0,i.A)(this,"utils",void 0),this.utils=t}async fund(t,e=1){const r=new l.A(t);if(!r.isInteger())throw new Error("must use an integer for funding amount");const n=this.utils.tokenConfig,i=await this.utils.getBundlerAddress(this.utils.token);let a;if(n.needsFee){const t=await n.getFee("winston"===n.base[0]?0:r,i);a=l.A.isBigNumber(t)?t.multipliedBy(e).integerValue(l.A.ROUND_CEIL):t}const s=await n.createTx(r,i,a);let o;try{o=await n.sendTx(s.tx)}catch(h){throw h}if(s.txId??=o,!s.txId)throw new Error("Undefined transaction ID");p.checkAndThrow(o,`Sending transaction to the ${this.utils.token} network`);let c=await this.utils.confirmationPoll(s.txId);const d=await this.submitTransaction(s.txId).catch((t=>{c=t}));if(!d)throw new Error(`failed to post funding tx - ${s.txId} - keep this id! \n ${c?` - ${c?.message??c}`:""}`);return{reward:l.A.isBigNumber(a)?a.toString():JSON.stringify(a),target:i,quantity:r.toString(),id:s.txId}}async submitTransaction(t){return await o((async()=>{const e=await this.utils.api.post(`/account/balance/${this.utils.token}`,{tx_id:t});return p.checkAndThrow(e,`Posting transaction ${t} information to the bundler`,[202]),e}),{retries:5,maxTimeout:1e3,minTimeout:100,randomize:!0})}async submitFundTransaction(t){return this.submitTransaction(t)}}var T=r(87394),x=r(9913),S=r(90712)["Buffer"];class C{constructor(t){(0,i.A)(this,"base",void 0),(0,i.A)(this,"wallet",void 0),(0,i.A)(this,"_address",void 0),(0,i.A)(this,"providerUrl",void 0),(0,i.A)(this,"providerInstance",void 0),(0,i.A)(this,"ticker",void 0),(0,i.A)(this,"name",void 0),(0,i.A)(this,"irys",void 0),(0,i.A)(this,"minConfirm",5),(0,i.A)(this,"isSlow",!1),(0,i.A)(this,"needsFee",!0),(0,i.A)(this,"inheritsRPC",!1),Object.assign(this,t)}get address(){return this._address}async ready(){this._address=this.wallet?this.ownerToAddress(await this.getPublicKey()):void 0}async getId(t){return u.encode(S.from(await(0,x.G8)().hash(await t.rawSignature())))}async price(){return _(this.ticker)}}async function _(t){const e=await s.A.get(`https://api.redstone.finance/prices?symbol=${t}&provider=redstone&limit=1`);return await p.checkAndThrow(e,"Getting price data"),e.data[0].value}const I=x.qI;class P extends C{constructor(t){super(t),(0,i.A)(this,"signer",void 0),(0,i.A)(this,"w3signer",void 0),(0,i.A)(this,"inheritsRPC",!0),this.base=["wei",1e18]}async getTx(t){const e=this.providerInstance,r=await e.getTransaction(t);if(!r)throw new Error("Tx doesn't exist");if(!r.to)throw new Error(`Unable to resolve transactions ${t} receiver`);return{from:r.from,to:r.to,blockHeight:r.blockNumber?new l.A(r.blockNumber):void 0,amount:new l.A(r.value.toHexString(),16),pending:!r.blockNumber,confirmed:r.confirmations>=this.minConfirm}}ownerToAddress(t){return t.toString().toLowerCase()}async sign(t){const e=await this.getSigner();return e.sign(t)}getSigner(){return this.signer||(this.signer=new x.qI(this.wallet)),this.signer}async verify(t,e,r){return I.verify(t,e,r)}async getCurrentHeight(){const t=this.providerInstance,e=await t.send("eth_blockNumber",[]);return new l.A(e,16)}async getFee(t,e){const r=this.providerInstance,n={to:e,from:this.address,value:"0x"+new l.A(t).toString(16)},i=await r.estimateGas(n),a=await r.getGasPrice();return new l.A(i.mul(a).toString())}async sendTx(t){const e=this.w3signer,r=await e.sendTransaction(t);return r?r.hash:void 0}async createTx(t,e,r){const n=T.gH.from(new l.A(t).toFixed()),i=this.w3signer,a=await i.estimateGas({to:e,from:this.address,value:n.toHexString()});let s=await i.getGasPrice();"matic"===this.name&&(s=T.gH.from(new l.A(s.toString()).multipliedBy(10).decimalPlaces(0).toString()));const o=await i.populateTransaction({to:e,from:this.address,value:n.toHexString(),gasPrice:s,gasLimit:a});return{txId:void 0,tx:o}}async getPublicKey(){return this.address}async ready(){this.w3signer=await this.wallet.getSigner(),this._address=(await this.w3signer.getAddress()).toString().toLowerCase(),await this.getSigner().ready(),this.providerInstance=this.wallet,await(this.providerInstance?._ready?.())}}r(16573),r(78100),r(77936),r(37467),r(44732),r(79577);var E=r(40876),U=r(56083),$=r(91636),B=r(91652),R=r(59930),D=r(72487),K=r(92587),N=r(90712)["Buffer"];class z extends C{constructor(t){super(t),(0,i.A)(this,"keyPair",void 0),(0,i.A)(this,"near",void 0),this.near=this.wallet._near,this.base=["yoctoNEAR",1e25]}async ready(){if(!this.wallet.isSignedIn())throw new Error("Wallet has not been signed in!");const t=new U.R,e=this.wallet.account();if(this.keyPair=await t.getKey(this.wallet._networkId,e.accountId),!this.keyPair){this.keyPair=E.KeyPair.fromRandom("ed25519");const r=this.keyPair.getPublicKey().toString();await t.setKey(this.wallet._networkId,e.accountId,this.keyPair),await e.addKey(r)}this._address=await this.wallet.getAccountId(),this.providerInstance=this.wallet._near.connection.provider}async getTx(t){const e=await this.providerInstance,[r,n]=t.split(":"),i=await e.txStatusReceipts(B.decode(n),r),a=await e.block(i.transaction_outcome.block_hash),s=(await e.block({finality:"final"})).header.height;if(""!==i.receipts_outcome[0].outcome.status.SuccessValue)throw new Error("Transaction failed!");const o=i.receipts[0].receipt.Action.actions[0].Transfer.deposit??0;return{from:r,to:i.transaction.receiver_id,amount:new l.A(o),blockHeight:new l.A(a.header.height),pending:!1,confirmed:s-a.header.height>=this.minConfirm}}ownerToAddress(t){const e="string"===typeof t?t:B.encode(t);return N.from(B.decode(e.replace("ed25519:",""))).toString("hex")}async sign(t){return this.getSigner().sign(t)}getSigner(){return new x.dU(this.keyPair.secretKey)}async verify(t,e,r){return x.dU.verify(t,e,r)}async getCurrentHeight(){const t=await this.providerInstance.status();return new l.A(t.sync_info.latest_block_height)}async getFee(t,e){const r=(await this.providerInstance.block({finality:"final"})).header.height,n=await this.providerInstance.gasPrice(r);return new l.A(n.gas_price).multipliedBy(45e10)}async sendTx(t){const e=await this.providerInstance.sendTransaction(t);return`${this.address}:${e.transaction.hash}`}async createTx(t,e,r){if(!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");const n=await this.providerInstance.query({request_type:"view_access_key",finality:"final",account_id:this.address,public_key:this.keyPair.getPublicKey().toString()}),i=++n.nonce,a=N.from(B.decode(n.block_hash)),s=[$.actionCreators.transfer(new D(new l.A(t).toString()))],o=(0,$.createTransaction)(this.address,this.keyPair.getPublicKey(),e,i,s,a),c=(0,R.serialize)($.SCHEMA,o),d=new Uint8Array(K.sha256.array(c)),h=this.keyPair.sign(d),u=new $.SignedTransaction({transaction:o,signature:new $.Signature({keyType:o.publicKey.keyType,data:h.signature})});return{tx:u,txId:void 0}}async getPublicKey(){return N.from(this.keyPair.getPublicKey().data)}}var q=r(75290),H=r(90712)["Buffer"];class F extends C{constructor(t){super(t),(0,i.A)(this,"signer",void 0),(0,i.A)(this,"minConfirm",1),this.base=["lamports",1e9]}async getProvider(){return this.providerInstance||(this.providerInstance=new q.Connection(this.providerUrl,{confirmTransactionInitialTimeout:6e4,commitment:"confirmed"})),this.providerInstance}async getTx(t){const e=await this.getProvider(),r=await e.getTransaction(t,{commitment:"confirmed"});if(!r)throw new Error("Confirmed tx not found");const n=await e.getSlot("confirmed");if(!r.meta)throw new Error(`Unable to resolve transaction ${t}`);const i=new l.A(r.meta.postBalances[1]).minus(new l.A(r.meta.preBalances[1])),a={from:r.transaction.message.accountKeys[0].toBase58(),to:r.transaction.message.accountKeys[1].toBase58(),amount:i,blockHeight:new l.A(r.slot),pending:!1,confirmed:n-r.slot>=1};return a}ownerToAddress(t){return"string"===typeof t&&(t=H.from(t)),B.encode(t)}async sign(t){return await(await this.getSigner()).sign(t)}getSigner(){return this.signer||(this.signer=new x.Q9(this.wallet)),this.signer}verify(t,e,r){return x.Q9.verify(t,e,r)}async getCurrentHeight(){return new l.A((await(await this.getProvider()).getEpochInfo()).blockHeight??0)}async getFee(t,e){return new l.A(5e3)}async sendTx(t){return await this.wallet.sendTransaction(t,await this.getProvider(),{skipPreflight:!0})}async createTx(t,e,r){const n=new q.PublicKey(await this.getPublicKey()),i=await o((async t=>{try{return await(await this.getProvider()).getRecentBlockhash()}catch(e){if(e.message?.includes("blockhash"))throw e;throw t(e),new Error("Unreachable")}}),{retries:3,minTimeout:1e3}),a=new q.Transaction({recentBlockhash:i.blockhash,feePayer:n});return a.add(q.SystemProgram.transfer({fromPubkey:n,toPubkey:new q.PublicKey(e),lamports:+new l.A(t).toNumber()})),{tx:a,txId:void 0}}async getPublicKey(){if(!this.wallet.publicKey)throw new Error("Wallet.publicKey is undefined");return this.wallet.publicKey.toBuffer()}}var L=r(12251);class M extends P{constructor(t){super(t),(0,i.A)(this,"contractInstance",void 0),(0,i.A)(this,"contractAddress",void 0),this.contractAddress=t.contractAddress}async getContract(){return this.contractInstance||(this.contractInstance=new L.NZ(this.contractAddress,O,this.w3signer),this.base=["wei",Math.pow(10,await this.contractInstance.decimals())]),this.contractInstance}async getTx(t){const e=await this.providerInstance.getTransaction(t);if(!e)throw new Error("Tx doesn't exist");if(138!==e.data.length||"a9059cbb"!==e.data.slice(2,10))throw new Error("Tx isn't a ERC20 transfer");const r=`0x${e.data.slice(34,74)}`,n=new l.A(e.data.slice(74),16);return{from:e.from,to:r,blockHeight:e.blockNumber?new l.A(e.blockNumber):void 0,amount:n,pending:!e.blockNumber,confirmed:e.confirmations>=this.minConfirm}}async getFee(t,e){const r="0x"+new l.A(t).toString(16),n=await this.getContract(),i=await this.providerInstance.getGasPrice(),a=await n.estimateGas.transfer(e,r),s=new l.A(i.mul(a).toString()),[o]=await this.getGas(),c=o.multipliedBy(s),d=new l.A(await this.price()),h=new l.A(c).dividedToIntegerBy(d);return h}async createTx(t,e,r){const n=await this.getContract(),i="0x"+new l.A(t).toString(16),a=await n.populateTransaction.transfer(e,i);if(a.gasPrice=await this.providerInstance.getGasPrice(),a.gasLimit=await n.estimateGas.transfer(e,i),a.chainId=(await this.providerInstance.getNetwork()).chainId,!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");return a.nonce=await this.providerInstance.getTransactionCount(this.address),{txId:void 0,tx:a}}async getGas(){return[new l.A(await _("ETH")),1e18]}}const O=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];var G=r(48882),j=r(9135),W=r(90712)["Buffer"];class J extends C{constructor(t){super(t),(0,i.A)(this,"signerInstance",void 0),(0,i.A)(this,"_publicKey",void 0),this.base=["aptom",1e8]}async getProvider(){return this.providerInstance??=new G.HN(this.providerUrl)}async getTx(t){const e=await this.getProvider(),r=await e.waitForTransactionWithResult(t,{timeoutSecs:1,checkSuccess:!0}),n=r?.payload;if(!r.success)throw new Error(r?.vm_status??"Unknown Aptos error");if("0x1::coin::transfer"!==n?.function||"0x1::aptos_coin::AptosCoin"!==n?.type_arguments[0]||"Executed successfully"!==r?.vm_status)throw new Error(`Aptos tx ${t} failed validation`);const i="pending_transaction"===r.type;return{to:n.arguments[0],from:r.sender,amount:new l.A(n.arguments[1]),pending:i,confirmed:!i}}ownerToAddress(t){const e=j.sha3_256.create();return e.update(W.from(t)),e.update("\0"),`0x${e.hex()}`}async sign(t){return await this.getSigner().sign(t)}getSigner(){return this.signerInstance??=new x.Il(this.wallet,this._publicKey)}async verify(t,e,r){return await x.Il.verify(t,e,r)}async getCurrentHeight(){return new l.A((await(await this.getProvider()).client.blocks.httpRequest.request({method:"GET",url:"/"})).block_height)}async getFee(t,e){const r=await this.getProvider();if(!this.address)throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");const n=new G.Iy(r,{sender:this.address}),i=await n.build("0x1::coin::transfer",["0x1::aptos_coin::AptosCoin"],[e??"0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9",new l.A(t).toNumber()]),a=new G.$8((t=>{const e=new Uint8Array(64);return new G.DT.Ed25519Signature(e)}),await this.getPublicKey()),s=a.sign(i),o={estimate_gas_unit_price:!0,estimate_max_gas_amount:!0},c=await r.client.request.request({url:"/transactions/simulate",query:o,method:"POST",body:s,mediaType:"application/x.aptos.signed_transaction+bcs"});return{gasUnitPrice:+c[0].gas_unit_price,maxGasAmount:+c[0].max_gas_amount}}async sendTx(t){return(await this.wallet.signAndSubmitTransaction(t)).hash}async createTx(t,e,r){const n={arguments:[e,new l.A(t).toNumber()],function:"0x1::coin::transfer",type:"entry_function_payload",type_arguments:["0x1::aptos_coin::AptosCoin"]};return{txId:void 0,tx:n}}async getPublicKey(){return this._publicKey??=W.from((await this.wallet.account()).publicKey.toString().slice(2),"hex")}async ready(){this._publicKey=await this.getPublicKey(),this._address=this.ownerToAddress(this._publicKey);const t=await this.getProvider();this._address=await t.lookupOriginalAddress(this.address??"").then((t=>t.toString())).catch((t=>this._address)),66==this._address?.length&&"0"===this._address.charAt(2)&&(this._address=this._address.slice(0,2)+this._address.slice(3))}}class V extends P{}class Q extends P{async createTx(t,e,r){const n=this.w3signer,i={to:e,from:this.address,value:t.toString(),gasLimit:BigInt(0)},a=await this.provider.estimateGas(i);i.gasLimit=a;const s=await n.populateTransaction(i);return{tx:s,txId:void 0}}async getTx(t){const e=this.provider,r=await e.getTransaction(t);if(!r)throw new Error("Tx doesn't exist");if(!r.to)throw new Error(`Unable to resolve transactions ${t} receiver`);return{from:r.from,to:r.to,blockHeight:r.blockNumber?new l.A(r.blockNumber):void 0,amount:new l.A(r.value.toString()),pending:!r.blockNumber,confirmed:await r.confirmations()>=this.minConfirm}}async ready(){const t=this.wallet;this.provider=t;const e=await t.getSigner();e._signTypedData=async(t,r,n)=>e.signTypedData(t,r,n),t.getSigner=()=>e,this.wallet=t,await super.ready()}}function X(t){switch(t.token){case"ethereum":return Z("ethereum",t.providerName,{irys:t.irys,name:"ethereum",ticker:"ETH",providerUrl:t.providerUrl??"https://cloudflare-eth.com/",wallet:t.wallet});case"matic":return Z("ethereum",t.providerName,{irys:t.irys,name:"matic",ticker:"MATIC",providerUrl:t.providerUrl??"https://polygon-rpc.com",wallet:t.wallet,minConfirm:1});case"arbitrum":return Z("ethereum",t.providerName,{irys:t.irys,name:"arbitrum",ticker:"ETH",providerUrl:t.providerUrl??"https://arb1.arbitrum.io/rpc",wallet:t.wallet});case"bnb":return Z("ethereum",t.providerName,{irys:t.irys,name:"bnb",ticker:"BNB",providerUrl:t.providerUrl??"https://bsc-dataseed.binance.org",wallet:t.wallet});case"avalanche":return Z("ethereum",t.providerName,{irys:t.irys,name:"avalanche",ticker:"AVAX",providerUrl:t.providerUrl??"https://api.avax.network/ext/bc/C/rpc",wallet:t.wallet});case"boba-eth":return Z("ethereum",t.providerName,{irys:t.irys,name:"boba-eth",ticker:"ETH",providerUrl:t.providerUrl??"https://mainnet.boba.network/",minConfirm:1,wallet:t.wallet});case"boba":{const e=new M({irys:t.irys,name:"boba",ticker:"BOBA",providerUrl:t.providerUrl??"https://mainnet.boba.network/",contractAddress:t.contractAddress??"0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7",minConfirm:1,wallet:t.wallet});return e.price=async()=>{const t=await s.A.post("https://api.livecoinwatch.com/coins/single",JSON.stringify({currency:"USD",code:`${e.ticker}`}),{headers:{"x-api-key":"75a7a824-6577-45e6-ad86-511d590c7cc8","content-type":"application/json"}});if(await p.checkAndThrow(t,"Getting price data"),!t?.data?.rate)throw new Error(`unable to get price for ${e.name}`);return+t.data.rate},e}case"solana":return new F({irys:t.irys,name:"solana",ticker:"SOL",providerUrl:t.providerUrl??"https://api.mainnet-beta.solana.com/",wallet:t.wallet});case"near":return new z({irys:t.irys,name:"near",ticker:"NEAR",providerUrl:t.providerUrl??"https://rpc.mainnet.near.org",wallet:t.wallet});case"aptos":return new J({irys:t.irys,name:"aptos",ticker:"APTOS",providerUrl:t.providerUrl??"https://fullnode.mainnet.aptoslabs.com/v1",wallet:t.wallet});default:throw new Error(`Unknown/Unsupported token ${t.token}`)}}function Z(t,e,r){switch(t){case"ethereum":switch(e){case"ethersv5":return new V(r);case"ethersv6":return new Q(r);default:return new P(r)}}}r(44114),r(81454);class Y{constructor(t){(0,i.A)(this,"irys",void 0),this.irys=t}async upload(t,e){return this.irys.uploadWithReceipt(t,e)}async uploadProof(t){return await this.irys.uploadWithReceipt("",{tags:Object.entries({dataProtocol:"Provenance-Confirmation",...t}).map((([t,e])=>({name:tt[t],value:e})))})}async getAllProofs(t,e){const r=Object.entries(t).map((([t,e])=>({name:tt[t],values:[e]})));if(0===r.length)throw new Error("Getting a provenance proof requires at least one query element");const n="\n    query ($tags: [TagFilter!]) {\n      transactions(tags: $tags) {\n        edges {\n          node {\n            id\n            receipt {\n              deadlineHeight\n              signature\n              timestamp\n              version\n            }\n            tags {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n    ",i=[];let a=null;do{const t=await this.irys.api.post("/graphql",{query:n,variables:{tags:r,limit:e?.limit??null,after:a}},void 0);a=t.data.data.transactions?.pageInfo?.hasNextPage?t.data.data.transactions.pageInfo.endCursor:null,i.push(...t.data.data.transactions.edges.map((t=>t.node)))}while(a);return i}async getProof(t){const e=(await this.getAllProofs(t,{limit:1})).at(0);if(!e)throw new Error(`Unable to locate proof with fields ${JSON.stringify(t)}`);return e}}const tt={dataProtocol:"Data-Protocol",hashingAlgo:"Hashing-Algo",dataHash:"Data-Hash",uploadedFor:"Uploaded-For",prompt:"Prompt",promptHash:"Prompt-Hash",model:"Model"};class et{constructor(t){(0,i.A)(this,"irys",void 0),this.irys=t}async getById(t){const e=(await this.query({ids:[t],limit:1})).at(0);if(!e)throw new Error(`Unable to locate tx with id ${t}`);return e}async getByOwner(t){const e=(await this.query({owners:[t],limit:1})).at(0);if(!e)throw new Error(`Unable to locate tx with owner ${t}`);return e}async getByTag(t,e){const r=(await this.query({tags:[{name:t,values:[e]}],limit:1})).at(0);if(!r)throw new Error(`Unable to locate tx with tag ${t}:${e}`);return r}async query(t){const e="\n    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {\n      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {\n        edges {\n          cursor\n          node {\n            address\n            currency\n            id\n            receipt {\n              deadlineHeight\n              signature\n              timestamp\n              version\n            }\n            signature\n            tags {\n              name\n              value\n            }\n            timestamp\n          }\n        }\n        pageInfo {\n          endCursor\n          hasNextPage\n        }\n      }\n    }\n    ",r=[];let n=null;do{const i=await this.irys.api.post("/graphql",{query:e,variables:{...t,after:n??t.after}},void 0);n=i.data.data.transactions?.pageInfo?.hasNextPage?i.data.data.transactions.pageInfo.endCursor:null,r.push(...i.data.data.transactions.edges.map((t=>t.node)))}while(n);return r}}r(37550);var rt=r(98221),nt=(r(17642),r(58004),r(33853),r(45876),r(32475),r(15024),r(31698),r(40294)),it=r(99774);const at=Symbol("not readable"),st=Symbol("readable"),ot=Symbol("ended"),ct=Symbol("errored"),dt={notReadable:at,readable:st,ended:ot,errored:ct};class ht{get closed(){return this._state===dt.ended}constructor(t,{size:e}={}){(0,i.A)(this,"_stream",void 0),(0,i.A)(this,"_error",void 0),(0,i.A)(this,"_state",dt.notReadable),(0,i.A)(this,"_size",void 0),(0,i.A)(this,"_rejections",new Set),this._stream=t,this._size=e;const r=["_handleStreamEnd","_handleStreamError"];for(const n of r)Object.defineProperty(this,n,{configurable:!0,writable:!0,value:this[n].bind(this)});t.once("error",this._handleStreamError),t.once("end",this._handleStreamEnd),t.on("readable",(()=>{this._state=dt.readable}))}[Symbol.asyncIterator](){return this}async next(){switch(this._state){case dt.notReadable:{let t,e;try{t=this._untilReadable(),e=this._untilEnd(),await Promise.race([t.promise,e.promise])}finally{null!=t&&t.close(),null!=e&&e.close()}return this.next()}case dt.ended:return this.close(),{done:!0,value:void 0};case dt.errored:throw this.close(),this._error;case dt.readable:{const t=this._size?this._stream.read(this._size):this._stream.read();return null!==t?{done:!1,value:t}:(this._state=dt.notReadable,await new Promise((t=>setTimeout((t=>t(!0)),0,t))),this.next())}}}_untilReadable(){let t;const e=new Promise(((e,r)=>{t=()=>{this._state=dt.readable,this._rejections.delete(r),e()},this._state,dt.readable,this._stream.once("readable",t),this._rejections.add(r)})),r=()=>{null!=t&&this._stream.removeListener("readable",t)};return{close:r,promise:e}}_untilEnd(){let t;const e=new Promise(((e,r)=>{t=()=>{this._state=dt.ended,this._rejections.delete(r),e()},this._stream.once("end",t),this._rejections.add(r)})),r=()=>{null!=t&&this._stream.removeListener("end",t)};return{close:r,promise:e}}return(){return this._state=dt.ended,this.next()}throw(t){return this._error=t,this._state=dt.errored,this.next()}close(t){this._stream.removeListener("end",this._handleStreamEnd),this._stream.removeListener("error",this._handleStreamError),this._state=dt.ended,this._stream.destroy(t)}_handleStreamError(t){this._error=t,this._state=dt.errored;for(const e of this._rejections)e(t)}_handleStreamEnd(){this._state=dt.ended}get state(){return this._state}}var ut=r(90712)["Buffer"];class lt extends it.EventEmitter{constructor(t,e){super({captureRejections:!0}),(0,i.A)(this,"tokenConfig",void 0),(0,i.A)(this,"api",void 0),(0,i.A)(this,"uploadID",void 0),(0,i.A)(this,"token",void 0),(0,i.A)(this,"chunkSize",void 0),(0,i.A)(this,"batchSize",void 0),(0,i.A)(this,"paused",!1),(0,i.A)(this,"isResume",!1),(0,i.A)(this,"uploadOptions",void 0),(0,i.A)(this,"arbundles",void 0),this.tokenConfig=t,this.arbundles=this.tokenConfig.irys.arbundles,this.api=e,this.token=this.tokenConfig.name,this.chunkSize=25e6,this.batchSize=5,this.uploadID=""}setResumeData(t){return t&&(this.uploadID=t,this.isResume=!0),this}getResumeData(){return this.uploadID}setChunkSize(t){if(t<1)throw new Error("Invalid chunk size (must be >=1)");return this.chunkSize=t,this}setBatchSize(t){if(t<1)throw new Error("Invalid batch size (must be >=1)");return this.batchSize=t,this}pause(){this.emit("pause"),this.paused=!0}resume(){this.paused=!1,this.emit("resume")}async uploadTransaction(t,e){return this.uploadOptions=e,this.arbundles.DataItem.isDataItem(t)?this.runUpload(t.getRaw()):this.runUpload(t)}async uploadData(t,e){return this.uploadOptions=e?.upload,this.runUpload(t,{...e})}async runUpload(t,e){let r=this.uploadID;const n=void 0===e,i={"x-chunking-version":"2"};let a;if(r){if(a=await this.api.get(`/chunks/${this.token}/${r}/-1`,{headers:i}),404===a.status)throw new Error("Upload ID not found - your upload has probably expired.");if(p.checkAndThrow(a,"Getting upload info"),this.chunkSize!=+a.data.size)throw new Error(`Chunk size not equal to that of a previous upload (${+a.data.size}).`)}else a=await this.api.get(`/chunks/${this.token}/-1/-1`,{headers:i}),p.checkAndThrow(a,"Getting upload token"),this.uploadID=r=a.data.id;const{max:s,min:d}=a.data;if(this.chunkSize<+d||this.chunkSize>+s)throw new Error(`Chunk size out of allowed range: ${d} - ${s}`);let h=0;const u=(t,e,n)=>new Promise((a=>{o((async s=>{await this.api.post(`/chunks/${this.token}/${r}/${e}`,t,{headers:{"Content-Type":"application/octet-stream",...i},maxBodyLength:1/0,maxContentLength:1/0}).then((r=>{if(r?.status>=300){const i={res:r,id:n,offset:e,size:t.length};throw this.emit("chunkError",i),402===r?.status&&s(new Error("Not enough funds to send data")),i}this.emit("chunkUpload",{id:n,offset:e,size:t.length,totalUploaded:h+=t.length}),a({o:e,d:r})}))}))})),l=a.data.chunks??[],g=new nt.PassThrough;let w=ut.alloc(0),y=!1,f=!0;g.on("end",(()=>y=!0)),g.on("error",(t=>{throw new Error(`Error processing readable: ${t}`)}));const m=async t=>{while(!y){if(w.length>=t)return e=ut.from(w.slice(0,t)),w=w.slice(t),e;var e=g.read(t);if(null!==e){if(e.length===t)return e;w=ut.concat([w,e])}else await new Promise((t=>setTimeout((t=>t(!0)),0,t)))}while(w.length>=t)return e=ut.from(w.slice(0,t)),w=w.slice(t),e;return f=!1,w};let v,b;if(!n){v=this.arbundles.createData("",this.tokenConfig.getSigner(),{...e,anchor:e?.anchor??c.randomBytes(32).toString("base64").slice(0,32)});const t=v.getRaw();b=t.length,g.write(t),h-=t.length}if(ut.isBuffer(t))g.write(t),g.end();else{if(!("pipe"in t))throw new Error("Input data is not a buffer or a compatible stream (no .pipe method)");t.pipe(g)}let A=0;const k=new Set;let T,x,S,C=0;if(!n){x=new nt.PassThrough;const t=v.getRaw().length;if(this.chunkSize<b)throw new Error(`Configured chunk size is too small for transaction header! (${this.chunkSize} < ${b})`);T=await m(this.chunkSize),C++,A+=T.length,x.write(T.slice(t));const e=[this.arbundles.stringToBuffer("dataitem"),this.arbundles.stringToBuffer("1"),this.arbundles.stringToBuffer(v.signatureType.toString()),v.rawOwner,v.rawTarget,v.rawAnchor,v.rawTags,new ht(x)];S=this.arbundles.deepHash(e)}let _=l.pop();while(f){if(this.paused&&await new Promise((t=>this.on("resume",(()=>t(void 0))))),_){const t=+_[0]-A;if(t<=this.chunkSize){const t=_[1],e=await m(t);n||x.write(e),A+=t,_=l.pop(),C++,h+=t;continue}}const t=await m(this.chunkSize);n||x.write(t);while(k.size>=this.batchSize){const[t]=await Promise.race(k);k.delete(t)}const e=(async()=>await u(t,A,++C))().then((t=>[e,t]));k.add(e),A+=t.length}if(x&&x.end(),await Promise.all(k),!n){const t=await S,e=ut.from(await this.tokenConfig.getSigner().sign(t));T.set(e,2),await u(T,0,0)}const I=await this.api.post(`/chunks/${this.token}/${r}/-1`,null,{headers:{"Content-Type":"application/octet-stream",...i},timeout:this.api.config?.timeout??4e5});if(402===I.status)throw new Error("Not enough funds to send data");if(p.checkAndThrow(I,"Finalising upload",[201]),201===I.status)throw new Error(I.data);return I.data.verify=p.verifyReceipt.bind({},this.arbundles,I.data.data),this.emit("done",I),I}get completionPromise(){return new Promise((t=>this.on("done",t)))}}var gt=r(90712)["Buffer"];const wt=5e7;class pt{constructor(t,e,r,n,a){(0,i.A)(this,"api",void 0),(0,i.A)(this,"token",void 0),(0,i.A)(this,"tokenConfig",void 0),(0,i.A)(this,"utils",void 0),(0,i.A)(this,"contentTypeOverride",void 0),(0,i.A)(this,"forceUseChunking",void 0),(0,i.A)(this,"arbundles",void 0),(0,i.A)(this,"irysTransaction",void 0),this.api=t,this.token=r,this.tokenConfig=n,this.arbundles=this.tokenConfig.irys.arbundles,this.utils=e,this.irysTransaction=a}async uploadTransaction(t,e){let r;const n=this.arbundles.DataItem.isDataItem(t);if(this.forceUseChunking||n&&t.getRaw().length>=wt||!n)r=await this.chunkedUploader.uploadTransaction(n?t.getRaw():t,e);else{const{url:e,timeout:n,headers:i}=this.api.getConfig(),a={"Content-Type":"application/octet-stream",...i};if(r=await this.api.post(new URL(`/tx/${this.token}`,e).toString(),t.getRaw(),{headers:a,timeout:n,maxBodyLength:1/0}),201===r.status)throw new Error(r.data)}switch(r.status){case 402:throw new Error("Not enough funds to send data");default:if(r.status>=400)throw new Error(`whilst uploading Irys transaction: ${r.status} ${r.statusText}`)}return r.data.verify=async()=>this.utils.verifyReceipt(r.data),r}async uploadData(t,e){if("string"===typeof t&&(t=gt.from(t)),gt.isBuffer(t)&&t.length<=wt){const r=this.arbundles.createData(t,this.tokenConfig.getSigner(),{...e,anchor:e?.anchor??(0,c.randomBytes)(32).toString("base64").slice(0,32)});return await r.sign(this.tokenConfig.getSigner()),(await this.uploadTransaction(r,{...e?.upload})).data}return(await this.chunkedUploader.uploadData(t,e)).data}async concurrentUploader(t,e){const r=[],n=e?.logFunction?e?.logFunction:async t=>{},i=e?.concurrency??5,a=await rt.PromisePool.for(t).withConcurrency(i>=1?i:5).handleError((async(t,e)=>{if(r.push(t),"Not enough funds to send data"===t.message)throw t})).process((async(t,r,a)=>{await o((async a=>{try{const a=await this.processItem(t,e?.itemOptions);return r%i==0&&await n(`Processed ${r} Items`),e?.resultProcessor?await e.resultProcessor({item:t,res:a,i:r}):{item:t,res:a,i:r}}catch(s){throw"Not enough funds to send data"===s?.message&&a(s),s}}),{retries:3,minTimeout:1e3,maxTimeout:1e4})}));return{errors:r,results:a.results}}async processItem(t,e){return this.arbundles.DataItem.isDataItem(t)?this.uploadTransaction(t,{...e?.upload}):this.uploadData(t,e)}async generateManifest(t){const{items:e,indexFile:r}=t,n={manifest:"arweave/paths",version:"0.1.0",paths:{}};if(r){if(!e.has(r))throw new Error(`Unable to access item: ${r}`);n.index={path:r}}for(const[i,a]of e.entries())n.paths[i]={id:a};return n}get chunkedUploader(){return new lt(this.tokenConfig,this.api)}set useChunking(t){"boolean"===typeof t&&(this.forceUseChunking=t)}set contentType(t){this.contentTypeOverride=t}async uploadBundle(t,e){const r=e?.throwawayKey??await this.arbundles.getCryptoDriver().generateJWK(),n=new x.en(r),i=t.map((t=>this.arbundles.DataItem.isDataItem(t)?t:this.arbundles.createData(t,n))),a=await this.arbundles.bundleAndSignData(i,n),s=this.arbundles.createData(a.getRaw(),this.tokenConfig.getSigner(),{tags:[{name:"Bundle-Format",value:"binary"},{name:"Bundle-Version",value:"2.0.0"}]});await s.sign(this.tokenConfig.getSigner());const o=await this.uploadTransaction(s,e),c=u(gt.from(await this.arbundles.getCryptoDriver().hash(u.toBuffer(u(n.publicKey)))));return{...o,txs:i,throwawayKey:r,throwawayKeyAddress:c}}}var yt=r(90712)["Buffer"];class ft extends pt{constructor(t){super(t.api,t.utils,t.token,t.tokenConfig,t.IrysTransaction),(0,i.A)(this,"irys",void 0),this.irys=t}async uploadFile(t,e){const r=!!e?.tags&&e.tags.some((({name:t})=>"content-type"===t.toLowerCase())),n=r?e?.tags:[...e?.tags??[],{name:"Content-Type",value:t.type}];return this.uploadData(yt.from(await t.arrayBuffer()),{tags:n,...e})}async uploadFolder(t,e){const r=[],n=new Map,i=e?.throwawayKey??await this.irys.arbundles.getCryptoDriver().generateJWK(),a=new x.en(i);for(const d of t){const t=d.webkitRelativePath?d.webkitRelativePath:d.name,e=!!d.tags&&d.tags.some((({name:t})=>"content-type"===t.toLowerCase())),i=e?d.tags:[...d.tags??[],{name:"Content-Type",value:d.type}],s=this.irys.arbundles.createData(yt.from(await d.arrayBuffer()),a,{tags:i});await s.sign(a),r.push(s),n.set(t,s.id)}const s=await this.generateManifest({items:n,indexFile:e?.indexFileRelPath}),o=this.irys.arbundles.createData(JSON.stringify(s),e?.seperateManifestTx?this.irys.tokenConfig.getSigner():a,{tags:[{name:"Type",value:"manifest"},{name:"Content-Type",value:"application/x.arweave-manifest+json"},...e?.manifestTags??[]]});!0===e?.seperateManifestTx?(await o.sign(this.irys.tokenConfig.getSigner()),await this.uploadTransaction(o,{...e})):(await o.sign(a),r.push(o));const c=await this.uploadBundle(r,{...e});return{...c.data,manifestId:o.id,manifest:s,throwawayKey:c.throwawayKey,throwawayKeyAddress:c.throwawayKeyAddress,txs:c.txs}}}class mt extends v{constructor({url:t,token:e,wallet:r,config:a}){switch(t){case void 0:case"node1":t="https://node1.irys.xyz";break;case"node2":t="https://node2.irys.xyz";break;case"devnet":t="https://devnet.irys.xyz";break}const s=new URL(t);if(super({url:s,arbundles:n}),(0,i.A)(this,"tokenConfig",void 0),(0,i.A)(this,"uploader",void 0),(0,i.A)(this,"uploadFolder",void 0),(0,i.A)(this,"uploadFile",void 0),this.api=new A({url:s,timeout:a?.timeout??1e5,headers:a?.headers}),this.tokenConfig=X({irys:this,token:e.toLowerCase(),wallet:r?.provider,providerUrl:a?.providerUrl??r?.rpcUrl,contractAddress:a?.contractAddress,providerName:r?.name}),this.token=this.tokenConfig.name,"devnet.irys.network"===s.host&&!(a?.providerUrl??(r?.rpcUrl||this.tokenConfig.inheritsRPC)))throw new Error(`Using ${s.host} requires a dev/testnet RPC to be configured! see https://docs.irys.network/sdk/using-devnet`);this.utils=new p(this.api,this.token,this.tokenConfig),this.uploader=new ft(this),this.funder=new k(this.utils),this.uploader=new ft(this),this.provenance=new Y(this),this.transactions=new et(this),this.address="Please run `await Irys.ready()`",this.uploadFolder=this.uploader.uploadFolder.bind(this.uploader),this.uploadFile=this.uploader.uploadFile.bind(this.uploader)}}var vt=mt}}]);
//# sourceMappingURL=vendor.irys-7e0a1a81.5c0b8b49.js.map