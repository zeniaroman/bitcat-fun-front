{"version":3,"file":"js/4891.f09b9a01.js","mappings":"gNAcA,MAAMA,EAAgD,CACpDC,KAAM,cACNC,YAAaA,CAACC,EAAcC,KAC1B,MAAMC,EAAOC,EAAAA,GAAqBC,QAAQJ,EAAMC,GAC1CI,EAAUF,EAAAA,GAAqBG,OAAON,EAAMC,GAClD,MAAO,CAACI,EAASH,EAAK,EAExBK,QAAAA,GACE,MAAM,IAAIC,EAAAA,EACZ,GAUWC,IAHmBC,EAAAA,EAAAA,IAA0Bb,IAIxDc,EAAAA,EAAAA,IAAsCd,IAElCe,EAAkD,CACtDd,KAAM,eACNC,YAAaA,CAACC,EAAcC,KAC1B,MAAMC,EAAOW,EAAAA,GAAsBT,QAAQJ,EAAMC,GAC3CI,EAAUQ,EAAAA,GAAsBP,OAAON,EAAMC,GACnD,MAAO,CAACI,EAASH,EAAK,EAExBK,QAAAA,GACE,MAAM,IAAIC,EAAAA,EACZ,GAUWM,IAHoBJ,EAAAA,EAAAA,IAA0BE,IAIzDD,EAAAA,EAAAA,IAAsCC,G,6ECrD3BG,EAAmB,IAAIC,EAAAA,UAClC,8C,wGCEkCC,EAAAA,EA0B7B,MAAMC,UAAwBD,EAAAA,EACnCE,WAAAA,CAAYC,EAAoBC,GAC9BC,MAAMF,EAAUC,GAAaE,EAAAA,IAC7BC,KAAKC,UAAUC,EAAAA,GACjB,CAEAC,UAAAA,GACE,OAAOH,KAAKI,MAAM,EAAG,GACvB,CAEAC,SAAAA,CAAUC,GACR,OAAON,KAAKO,MAAM,EAAGD,EACvB,CAEAE,WAAAA,GACE,OAAOR,KAAKI,MAAM,GAAI,GACxB,CAEAK,UAAAA,CAAWC,GACT,OAAOV,KAAKO,MAAM,GAAIG,EACxB,CAEAC,YAAAA,GACE,OAAOX,KAAKI,MAAM,GAAI,EACxB,CAEAQ,WAAAA,CAAYC,GACV,OAAOb,KAAKO,MAAM,GAAIM,EACxB,CAEAC,uBAAAA,GACE,OAAOd,KAAKO,MAAM,GAAI,EACxB,CAEAQ,gBAAAA,GACE,OAAOf,KAAKO,MAAM,GAAI,EACxB,CAEAS,aAAAA,CAAcC,GACZ,OAAOjB,KAAKe,mBAAmBR,MAAM,GAAIU,EAC3C,E,mFCGW,MAAAC,EAAUC,IACrB,MAAMC,EAAeD,EAAQE,UAAUC,OAAO/B,EAAAA,GACxCgC,EAA6B,CACjCC,OAAQJ,EAAe,MAAQ,QAC/BK,SAAUN,EAAQ3C,KAAKiD,SACvBC,UAAW,aAGb,MAAO,CACLC,MAAO,OACPC,QAAST,EAAQE,UACjBQ,qBAAsBV,EAAQ3C,KAAKsD,oBAC/BX,EAAQ3C,KAAKuD,cACb,KACJC,uBAAwBb,EAAQ3C,KAAKyD,sBACjCd,EAAQ3C,KAAK0D,gBACb,KACJT,SAAUN,EAAQ3C,KAAKiD,SACvBU,QAAQtB,EAAAA,EAAAA,IAAOM,EAAQ3C,KAAK2D,OAAOC,WAAYb,GAC/CH,eACAG,WACD,C,wICnBU,MAAAc,EAAWlB,IACtB,MAAMmB,EAAyBC,EAAAA,EAAIC,KAAKC,EAAAA,EAAuBb,QAAS,CACtET,EAAQ3C,KAAKkC,MAAMgC,WACnBvB,EAAQT,MAAMgC,WACdvB,EAAQ3C,KAAK8B,KAAKoC,aAEdC,EAAoBL,EAAuBhB,OAAOH,EAAQE,WAEhE,MAAO,CACLM,MAAO,QACPC,QAASe,EAAoBL,EAAyBnB,EAAQE,UAC9DsB,oBACAC,YAAazB,EAAQ3C,KAAK8B,KAC1BuC,aAAc1B,EAAQ3C,KAAKkC,MAC3BG,QAAQiC,EAAAA,EAAAA,IAAM3B,EAAQ3C,KAAKqC,OAAOuB,YAClCW,sBAAuB5B,EAAQ3C,KAAKwE,qBAChC7B,EAAQ3C,KAAKyE,eACb,KACJC,gBAAiB/B,EAAQ3C,KAAK2E,eAAiBhC,EAAQ3C,KAAKyC,SAAW,KACvEmC,gBAAgBN,EAAAA,EAAAA,IAAM3B,EAAQ3C,KAAK6E,gBAAgBjB,YACnDkB,MAAOnC,EAAQ3C,KAAK8E,MACrB,E,MAsBUC,EAAkBA,CAC7BC,EACAC,KAEA,MAAMX,EAAQT,EAAQmB,GACtB,MAAO,IACFV,EACHnB,MAAO,gBACPrB,KAAMmD,EACN5C,QAAQA,EAAAA,EAAAA,IAAOiC,EAAMjC,OAAO6C,YAAaD,EAAUlC,UACnD6B,gBAAgBvC,EAAAA,EAAAA,IACdiC,EAAMM,eAAeM,YACrBD,EAAUlC,UAEb,C,+HCnHH,MAAMoC,EAAM,sBAYCC,GAAsBC,EAAAA,EAAAA,GAAkCF,GAuExDG,EACX,CACE,YAAMC,CACJC,EACApE,EACAqE,GAEA,MAAMC,QAAgBC,EAAkBvE,EAAUoE,EAAUI,MAAOH,GACnEA,EAAMI,kBAEN,MAAMC,GAAiBC,EAAAA,EAAAA,GACrB3E,EACAqE,EAAMK,gBAEFE,QAAeN,EAAQO,eAAe7E,EAAU0E,GACtDL,EAAMI,kBAEN,MAAM/D,QAAaV,EAChB8E,SACAC,kBAAkB,CAAE/C,QAAS4C,EAAOI,WAAWvD,WAAa4C,GAE/D,MAAO,IAAKO,EAAQlE,OACtB,GAyCS6D,EAAoBU,MAC/BjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,SACJtD,EAAW,EAAC,KACZnB,EAAO8E,EAAAA,QAAQC,WAAU,cACzBtD,EAAgBnC,EAAS0F,WAAWjE,UAAS,gBAC7Ca,EAAkBH,GAChB+C,EAEES,EAAe3F,EAASoF,WAAWQ,SAASR,GAElD,OACES,EAAAA,EAAmBC,OAChBC,YAAYV,GACZW,WAAW,CAAEhB,WAAYtE,IAGzBuF,UACOjG,EACHkG,SACAC,WACAC,cACC,CACEC,WAAY3F,EACZ4F,MAAOC,EAAAA,GACPC,QAASb,EAAa3D,QACtByE,eACEvB,EAAOwB,6BAA+B,iBAE1C,CAAErB,QAAOD,cAKda,IAAI,CACHU,aAAaC,EAAAA,EAAAA,IACXlG,EAAKe,UACLI,EACAM,EACAG,EACAqD,EAAa3D,SAEf6E,QAAS,CAACnG,GACVoG,IAAK5B,EAAO6B,8BAAgC,kBAC5C,E,oEC3LR,MAAMhD,EAAM,uBAYCiD,GAAuB/C,EAAAA,EAAAA,GAAmCF,GAyD1DkD,EACX,CACE,YAAM9C,CACJC,EACApE,EACAqE,GAEA,MAAMC,QAAgB4C,EACpBlH,EACAoE,EAAUI,MACVH,GAEFA,EAAMI,kBAEN,MAAMC,GAAiBC,EAAAA,EAAAA,GACrB3E,EACAqE,EAAMK,gBAEFE,QAAeN,EAAQO,eAAe7E,EAAU0E,GACtDL,EAAMI,kBAEN,MAAMvB,QAAclD,EACjB8E,SACAqC,mBAAmB,CAAEnF,QAAS4C,EAAOwC,cAAgB/C,GAExD,MAAO,IAAKO,EAAQ1B,QACtB,GA4CSgE,EAAqBjC,MAChCjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,KAAEzE,EAAI,MAAEI,EAAQd,EAAS0F,WAAWjE,UAAS,MAAEyB,GAAUgC,EAEzDS,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5CvC,EAAyB7C,EAC5BoF,WACAiC,mBAAmBjC,GAEhBrC,OAA8BuE,IAAVpE,EACpBoB,EACJuB,EAAAA,EAAmBC,OAAkCC,YAAYV,GAEnE,GAAItC,EAAmB,CACrB,MAAML,EAAyB1C,EAC5B8E,SACAyC,OACAC,uBAAuB,CAAE9G,OAAMI,QAAOsE,aAEzC,OACEd,EACG0B,WAAW,CAAEoB,aAAc1E,IAG3BuD,IAAI,CACHU,aAAac,EAAAA,EAAAA,IACXpC,EAAM5D,UACNiB,EACA5B,EACAJ,EACAiF,EAAa3D,QACba,EAAuBb,SAEzB6E,QAAS,CAACxB,GACVyB,IACE5B,EAAOwC,4CACP,gCAGV,CAEA,OACEpD,EACGyB,YAAYV,GACZW,WAAW,CAAEoB,aAAclE,EAAMzB,YAGjCwE,UACOjG,EACHkG,SACAC,WACAC,cACC,CACEC,WAAYnD,EACZoD,MAAOhG,EAAAA,GACPkG,QAASb,EAAa3D,QACtByE,eACEvB,EAAOwB,6BAA+B,iBAE1C,CAAErB,QAAOD,cAKda,IAAI,CACHU,aAAagB,EAAAA,EAAAA,IACXzE,EAAMzB,UACNf,EACAI,EACA6E,EAAa3D,SAEf6E,QAAS,CAAC3D,GACV4D,IAAK5B,EAAO0C,+BAAiC,mBAC7C,EAwCKC,EAA8B5C,MACzCjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,KACJzE,EAAI,MACJI,EAAQd,EAAS0F,WAAWjE,UAAS,MACrCyB,EAAK,YACL4E,GAAc,EAAI,cAClBC,EAAgB,SACd7C,EAEE8C,EACJ9E,GACAlD,EAAS8E,SAASyC,OAAOC,uBAAuB,CAAE9G,OAAMI,QAAOsE,aAC3D6C,GAAqBC,EAAAA,EAAAA,GAAYF,GACjC1D,EAAUuB,EAAAA,EAAmBC,OAChCC,YAAYV,GACZW,WAAW,CAAEoB,aAAca,IAE9B,GAAIH,EACF,OAAOxD,EAIT,GAAIpB,KAAUiF,EAAAA,EAAAA,IAASjF,GACrB,MAAM,IAAIkF,EAAAA,GACRL,EACA,YACC,iBAAgBA,0BACAE,2GAEeF,qKAMpC,OAAOzD,EAAQ2B,UACPjG,EACH8E,SACAqB,WACAkC,YACC,IACKnD,EACHxE,OACAI,QACAoC,SAEF,CAAEkC,WAAUC,UAEjB,E,0BC3UI,MAAMiD,UAAmBC,EAAAA,EAE9BxI,WAAAA,CAAYyI,EAAiBC,GAC3BvI,MAAMsI,EAAS,SAAU,QAASC,IAAOC,EAAAA,EAAAA,IAAA,YAFnB,aAGxB,EAIK,MAAMC,UAA0DL,EAErEvI,WAAAA,GACE,MAAMyI,EACJ,idAKFtI,MAAMsI,IAASE,EAAAA,EAAAA,IAAA,YARO,oDASxB,EAIK,MAAME,UAAoCN,EAC/CvI,WAAAA,CAAYmD,EAAkB2F,EAAsBnI,GAClD,MAAM8H,EACH,iFAAgFK,mCACjD3F,oDAAwDxC,gFAE1FR,MAAMsI,EACR,ECXF,MAAMzE,EAAM,+BAaC+E,GACX7E,EAAAA,EAAAA,GAA2CF,GAiGhCgF,EACX,CACE,YAAM5E,CACJC,EACApE,EACAqE,GAEA,MAAMC,QAAgB0E,EACpBhJ,EACAoE,EAAUI,MACVH,GAEFA,EAAMI,kBAEN,MAAMC,GAAiBC,EAAAA,EAAAA,GACrB3E,EACAqE,EAAMK,gBAEFE,QAAeN,EAAQO,eAAe7E,EAAU0E,GACtDL,EAAMI,kBAEN,MAAMvB,QAAclD,EAAS8E,SAASmE,wBACpC,CACEvI,KAAMkE,EAAOI,WAAWvD,UACxBO,QAAS4C,EAAOwC,aAChB8B,YAAa,SAEf7E,GAGF,MAAO,IAAKO,EAAQ1B,QACtB,GAwDS8F,EAA6B/D,MACxCjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,SACJtD,EAAW,EAAC,cACZsH,EAAa,KACbzI,EAAO8E,EAAAA,QAAQC,WAAU,cACzBtD,EAAgBnC,EAAS0F,WAAU,gBACnCpD,EAAkBtC,EAAS0F,WAAWjE,UAAS,MAC/CX,EAAQd,EAAS0F,WAAWjE,UAAS,MACrCyB,GACEgC,EAEEX,QAA0BvE,EAC7B8E,SACAqB,WACAiD,WACC,CACEvH,WACAnB,OACAyB,eAAe+F,EAAAA,EAAAA,GAAY/F,GAC3BG,kBACAoE,4BACExB,EAAOmE,iCAAmC,oBAC5CtC,6BACE7B,EAAO6B,8BAAgC,kBAE3C,CAAE3B,WAAUC,UAGV6B,QAA2BlH,EAC9B8E,SACAqB,WACAkC,YACC,CACE3H,KAAMA,EAAKe,UACXX,QACAoC,QACAwE,2CACExC,EAAOwC,4CACP,+BACFhB,4BACExB,EAAOoE,kCAAoC,qBAC7C1B,8BACE1C,EAAO0C,+BAAiC,mBAE5C,CAAEvC,QAAOD,cAGP,aAAEgC,GAAiBF,EAAmBqC,aAEtCjF,EAAUuB,EAAAA,EAAmBC,OAChCC,YAAYV,GACZW,WAAW,CAAEhB,WAAYtE,EAAM0G,iBAG/BnB,IAAI1B,GAGJ0B,IAAIiB,GAGP,GAAMiC,EAAe,CACnB,KAAKhB,EAAAA,EAAAA,IAAShG,GACZ,MAAM,IAAIwG,EAGZrE,EAAQ2B,UACAjG,EACH8E,SACAqB,WACAzF,KACC,CACEsC,YAAatC,EAAKe,UAClBgB,QAAS2E,EACTnG,OAAQkI,EACRhH,gBACAqH,yBACEtE,EAAOsE,0BAA4B,cAEvC,CAAEnE,QAAOD,aAGjB,CAEA,OAAOd,CAAO,E,cC/RhB,MAAMP,EAAM,sBAkBC0F,GAAsBxF,EAAAA,EAAAA,GAAkCF,GAyExD2F,EACX,CACE,YAAMvF,CACJC,EACApE,EACAqE,GAEA,MAAM,SAAEe,EAAQ,eAAEV,GAAmBL,GAC/B,YACJrB,EAAW,QACX2G,EAAU3J,EAAS0F,WAAWjE,UAAS,QACvCgB,GACE2B,EAAUI,MAERwD,EACJvF,GACAzC,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAO6I,EACPvE,aAEE6C,GAAqBC,EAAAA,EAAAA,GAAYF,GACjC4B,QAAiC5J,EACpCsF,MACAuE,cAAc5B,GACjB5D,EAAMI,kBAEN,MAAMH,QAAgBwF,EACpB9J,EACA,IAAKoE,EAAUI,MAAOuF,cAAeH,GACrCvF,GAIF,OAFAA,EAAMI,kBAECH,EAAQO,eAAe7E,EAAU0E,EAC1C,GAqDSoF,EAAoB7E,MAC/BjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,OACX/B,EAAM,QACN0I,EAAU3J,EAAS0F,WAAWjE,UAAS,QACvCgB,EAAO,cACPsH,GAAgB,EAAI,cACpB5H,EAAgBnC,EAAS0F,WAAU,aACnCsE,EAAe,IACb9E,GAEG+E,EAAwBpD,IAAWsB,EAAAA,EAAAA,IAAShG,GAC/C,CAACA,EAAcV,UAAW,CAACU,IAC3B,CAACA,EAAe6H,GAEdrE,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5C4C,EACJvF,GACAzC,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAO6I,EACPvE,aAGJ,OACES,EAAAA,EAAmBC,OAGhBG,UACOjG,EACH8E,SACAqB,WACA+D,qBACC,IACKhF,EACHxE,KAAMsC,EACNlC,MAAO6I,EACPzG,MAAOT,EACPqF,YAAaiC,EACbhC,cAAe,WAEjB,CAAE1C,QAAOD,cAKda,IAAI,CACHU,aAAawD,EAAAA,EAAAA,IACXnH,GACAkF,EAAAA,EAAAA,GAAYF,GACZiC,EACAhJ,EAAO6C,YAAYsG,WACnBJ,EACArE,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAOsE,0BAA4B,cACxC,E,iCCjPR,MAAMzF,EAAM,sBAkBCsG,GAAsBpG,EAAAA,EAAAA,GAAkCF,GA+FxDuG,EACX,CACE,YAAMnG,CACJC,EACApE,EACAqE,GAEA,MAAM,YACJrB,EAAW,QACX2G,EAAU3J,EAAS0F,WAAWjE,UAAS,QACvCgB,GACE2B,EAAUI,MAERwD,EACJvF,GACAzC,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAO6I,EACPvE,SAAUf,EAAMe,WAEd6C,GAAqBC,EAAAA,EAAAA,GAAYF,GACjC4B,QAAiC5J,EACpCsF,MACAuE,cAAc5B,GACjB5D,EAAMI,kBAEN,MAAMH,QAAgBiG,EACpBvK,EACA,IAAKoE,EAAUI,MAAOuF,cAAeH,GACrCvF,GAIF,OAFAA,EAAMI,kBAECH,EAAQO,eAAe7E,EAAUqE,EAAMK,eAChD,GAqDS6F,EAAoBtF,MAC/BjF,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,OACX/B,EAAM,QACN0I,EAAU3J,EAAS0F,WAAWjE,UAAS,QACvCgB,EAAO,cACPsH,GAAgB,EAAI,UACpBS,EAAYxK,EAAS0F,WAAU,UAC/B+E,EAAS,iBACTC,EAAmB,GAAE,kBACrBC,GACEzF,GAEG0F,EAAoB/D,IAAWsB,EAAAA,EAAAA,IAASqC,GAC3C,CAACA,EAAU/I,UAAW,CAAC+I,IACvB,CAACA,EAAW,CAACG,KAAsBD,GAAkBG,OAAO1C,EAAAA,KAE1DxC,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5C0F,EACJL,GACAzK,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAO8J,EACPxF,aAEE4C,EACJvF,GACAzC,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAO6I,EACPvE,aAGJ,OACES,EAAAA,EAAmBC,OAChBC,YAAYV,GAGZY,UACOjG,EACH8E,SACAqB,WACA+D,qBACC,IACKhF,EACHxE,KAAMsC,EACNlC,MAAO6I,EACPzG,MAAOT,EACPqF,YAAaiC,EACbhC,cAAe,WAEjB,CAAE3C,WAAUC,WAKjBY,IAAI,CACHU,aAAaoE,EAAAA,EAAAA,IACXD,GACA5C,EAAAA,EAAAA,GAAYF,GACZ2C,EAAoBA,EAAkBlJ,UAAYmJ,EAClD3J,EAAO6C,YAAYsG,WACnBM,EACA/E,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAO8F,8BAAgC,kBAC5C,E,eClRR,MAAMjH,EAAM,wBAYCkH,GAAwBhH,EAAAA,EAAAA,GAAoCF,GAgE5DmH,EACX,CACE,YAAM/G,CACJC,EACApE,EACAqE,GAEA,OAAO8G,EACLnL,EACAoE,EAAUI,MACVH,GACAQ,eAAe7E,EAAUqE,EAAMK,eACnC,GA6BSyG,EAAsBA,CACjCnL,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,WACXoI,EAAapL,EAAS0F,WAAWjE,UAAS,aAC1C2F,EAAY,aACZ4C,EAAe,GAAE,gBACjB1H,GACE4C,GAEGmG,EAAoBxE,IAAWsB,EAAAA,EAAAA,IAAS7F,GAC3C,CAACA,EAAgBb,UAAW,CAACa,IAC7B,CAACA,EAAiB0H,GAEhBrE,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5CkG,EACJlE,GACApH,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAOsK,EACPhG,aAGJ,OAAOS,EAAAA,EAAmBC,OACvBC,YAAYV,GACZY,IAAI,CACHU,aAAa4E,EAAAA,EAAAA,IACXD,EACAtI,EACAqI,EACArB,EACArE,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAOuB,gBAAkB,gBAC9B,E,eC5JN,MAAM1C,EAAM,sBAYCyH,GAAsBvH,EAAAA,EAAAA,GAAkCF,GAgExD0H,EACX,CACE,YAAMtH,CACJC,EACApE,EACAqE,GAEA,OAAOqH,EAAkB1L,EAAUoE,EAAUI,MAAOH,GAAOQ,eACzD7E,EACAqE,EAAMK,eAEV,GA6BSgH,EAAoBA,CAC/B1L,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,WACXoI,EAAapL,EAAS0F,WAAWjE,UAAS,aAC1C2F,EAAY,aACZ4C,EAAe,GAAE,gBACjB1H,GACE4C,GAEGmG,EAAoBxE,IAAWsB,EAAAA,EAAAA,IAAS7F,GAC3C,CAACA,EAAgBb,UAAW,CAACa,IAC7B,CAACA,EAAiB0H,GAEhBrE,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5CkG,EACJlE,GACApH,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAOsK,EACPhG,aAGJ,OAAOS,EAAAA,EAAmBC,OACvBC,YAAYV,GACZY,IAAI,CACHU,aAAagF,EAAAA,EAAAA,IACXL,EACAtI,EACAqI,EACArB,EACArE,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAOuB,gBAAkB,cAC9B,E,2BCzJN,MAAM1C,GAAM,yCAiBC6H,IACX3H,EAAAA,EAAAA,GAAqDF,IAsE1C8H,GACX,CACE1H,OAAQc,MACNb,EACApE,EACAqE,IAEOyH,GACL9L,EACAoE,EAAUI,MACVH,GACAQ,eAAe7E,EAAUqE,EAAMK,iBAoC1BoH,GAAuCA,CAClD9L,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,kBACX2H,EAAiB,OACjB1J,GAASiC,EAAAA,GAAAA,IAAM,GAAE,MACjBpC,EAAQd,EAAS0F,WAAU,aAC3B0B,EAAY,aACZ4C,EAAe,IACb9E,GAEG6G,EAAgBlF,IAAWsB,EAAAA,EAAAA,IAASrH,GACvC,CAACA,EAAMW,UAAW,CAACX,IACnB,CAACA,EAAOkJ,GAENrE,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5CkG,EACJlE,GACApH,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAOiL,EACP3G,aAGJ,OAAOS,EAAAA,EAAmBC,OACvBC,YAAYV,GACZY,IAAI,CACHU,aAAaqF,EAAAA,EAAAA,IACXV,EACAX,EACAoB,EACA9K,EAAO6C,YAAYsG,WACnBJ,EACArE,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAOuB,gBAAkB,4BAC9B,E,gBClLN,MAAM1C,GAAM,wCAcCkI,IACXhI,EAAAA,EAAAA,GAAoDF,IA0DzCmI,GACX,CACE/H,OAAQc,MACNb,EACApE,EACAqE,IAEO8H,GACLnM,EACAoE,EAAUI,MACVH,GACAQ,eAAe7E,EAAUqE,EAAMK,iBAiC1ByH,GAAsCA,CACjDnM,EACAkF,EACAC,EAAqC,CAAC,KAEtC,MAAM,SAAEC,EAAQ,MAAEC,EAAQrF,EAASsF,MAAMC,sBAAyBJ,GAC5D,YACJnC,EAAW,MACXlC,EAAQd,EAAS0F,WAAU,aAC3B0B,EAAY,aACZ4C,EAAe,IACb9E,GAEG6G,EAAgBlF,IAAWsB,EAAAA,EAAAA,IAASrH,GACvC,CAACA,EAAMW,UAAW,CAACX,IACnB,CAACA,EAAOkJ,GAENrE,EAAe3F,EAASoF,WAAWQ,SAASR,GAC5CxB,EACJwD,GACApH,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,KAAMsC,EACNlC,MAAOiL,EACP3G,aAGJ,OAAOS,EAAAA,EAAmBC,OACvBC,YAAYV,GACZY,IAAI,CACHU,aAAayF,EAAAA,GAAAA,IACXxI,EACAmI,EACA/B,EACArE,EAAa3D,SAEf6E,UACAC,IAAK5B,EAAOuB,gBAAkB,2BAC9B,EC7IC,MAAM4F,GACXtM,WAAAA,CAA+BC,GAAoB,KAApBA,SAAAA,CAAqB,CAOpDoJ,UAAAA,CACE5E,EACAW,GAEA,OAAOZ,EAAkBnE,KAAKJ,SAAUwE,EAAOW,EACjD,CAGAkD,WAAAA,CACE7D,EACAW,GAEA,OAAO+B,EAAmB9G,KAAKJ,SAAUwE,EAAOW,EAClD,CAGA+E,oBAAAA,CACE1F,EACAW,GAEA,OAAO0C,EAA4BzH,KAAKJ,SAAUwE,EAAOW,EAC3D,CAGAmH,mBAAAA,CACE9H,EACAW,GAEA,OAAO6D,EAA2B5I,KAAKJ,SAAUwE,EAAOW,EAC1D,CAOAzE,IAAAA,CAAK8D,EAAgCW,GACnC,OAAO2E,EAAkB1J,KAAKJ,SAAUwE,EAAOW,EACjD,CAGAoH,IAAAA,CAAK/H,EAAgCW,GACnC,OAAOoF,EAAkBnK,KAAKJ,SAAUwE,EAAOW,EACjD,CAGAqH,MAAAA,CACEhI,EACAW,GAEA,OAAOgG,EAAoB/K,KAAKJ,SAAUwE,EAAOW,EACnD,CAGAsH,IAAAA,CAAKjI,EAAgCW,GACnC,OAAOuG,EAAkBtL,KAAKJ,SAAUwE,EAAOW,EACjD,CAOAuH,wBAAAA,CACElI,EACAW,GAEA,OAAO2G,GAAqC1L,KAAKJ,SAAUwE,EAAOW,EACpE,CAGAwH,uBAAAA,CACEnI,EACAW,GAEA,OAAOgH,GAAoC/L,KAAKJ,SAAUwE,EAAOW,EACnE,E,yBC3GK,MAAMyH,GACX7M,WAAAA,CAA+BC,GAAoB,KAApBA,SAAAA,CAAqB,CAGpDwH,sBAAAA,EAAuB,KACrB9G,EAAI,MACJI,EAAK,SACLsE,IASA,MAAMO,EAAevF,KAAKJ,SAASoF,WAAWQ,SAASR,GACjDvC,EAAyBzC,KAAKJ,SACjCoF,WACAiC,mBAAmBjC,GACtB,OAAOzC,GAAAA,EAAIC,KAAKC,EAAuBb,QAAS,CAC9ClB,EAAMgC,WACN6C,EAAa3D,QAAQc,WACrBpC,EAAKoC,YAET,E,4BCnBF,MAAMiB,GAAM,6BAYC8I,IACX5I,EAAAA,EAAAA,GAAyCF,IAyB9B+I,GACX,CACE3I,OAAQc,MACNb,EACApE,EACAqE,KAEA,MAAM,WAAE0I,GAAe1I,GACjB,QAAErC,GAAYoC,EAAUI,MAExBjD,GAAUlC,EAAAA,GAAAA,UACRW,EAASsF,MAAM0H,WAAWhL,EAAS+K,IAG3C,OAAOzL,EAAAA,GAAAA,IAAOC,EAAQ,G,gBCpD5B,MAAMwC,GAAM,8BAYCkJ,IACXhJ,EAAAA,EAAAA,GAA0CF,IAyB/BmJ,GACX,CACE/I,OAAQc,MACNb,EACApE,EACAqE,KAEA,MAAM,WAAE0I,GAAe1I,GACjB,QAAErC,GAAYoC,EAAUI,MAExBjD,GAAU7B,EAAAA,GAAAA,UACRM,EAASsF,MAAM0H,WAAWhL,EAAS+K,IAG3C,OAAOtK,EAAAA,GAAAA,IAAQlB,EAAQ,GCnDvBwC,GAAM,sCAaCoJ,IACXlJ,EAAAA,EAAAA,GAAkDF,IAyBvCqJ,GACX,CACEjJ,OAAQc,MACNb,EACApE,EACAqE,KAEA,MAAM,WAAE0I,GAAe1I,GACjB,QAAErC,GAAYoC,EAAUI,MAExBZ,GAAelE,EAAAA,GAAAA,UACbM,EAASsF,MAAM0H,WAAWhL,EAAS+K,IAGrCM,GAAchO,EAAAA,GAAAA,UACZW,EAASsF,MAAM0H,WAAWpJ,EAAahF,KAAK8B,KAAMqM,IAG1D,OAAOpJ,EAAAA,GAAAA,IAAgBC,GAActC,EAAAA,GAAAA,IAAO+L,GAAa,GCxDzDtJ,GAAM,mCAqBCuJ,IACXrJ,EAAAA,EAAAA,GAA+CF,IAqCpCwJ,GACX,CACEpJ,OAAQc,MACNb,EACApE,EACAqE,KAEA,MAAM,WAAE0I,EAAU,SAAE3H,GAAaf,GAC3B,KAAE3D,EAAI,QAAEsB,EAAO,YAAEkH,GAAgB9E,EAAUI,MAC3C4C,EACY,UAAhB8B,EACIlJ,EAAS8E,SAASyC,OAAOC,uBAAuB,CAC9C9G,OACAI,MAAOkB,EACPoD,aAEFpD,EAEAwL,QAAiBxN,EACpBsF,MACAmI,oBAAoB,CAAC/M,EAAM0G,GAAe2F,GAEvCM,GAAchO,EAAAA,GAAAA,IAAcmO,EAAS,IACrC5J,GAAelE,EAAAA,GAAAA,IAAe8N,EAAS,IAE7C,IAAK5J,EAAahF,KAAK8B,KAAKgB,OAAOhB,GACjC,MAAM,IAAIkI,EACRxB,EACAxD,EAAahF,KAAK8B,KAClBA,GAIJ,OAAOiD,EAAAA,GAAAA,IAAgBC,GAActC,EAAAA,GAAAA,IAAO+L,GAAa,GCrDxD,MAAMK,GACX3N,WAAAA,CAA+BC,GAAoB,KAApBA,SAAAA,CAAqB,CAUpDmG,QAAAA,GACE,OAAO,IAAIkG,GAAoBjM,KAAKJ,SACtC,CASAuH,IAAAA,GACE,OAAO,IAAIqF,GAAgBxM,KAAKJ,SAClC,CAOA+E,iBAAAA,CAAkBP,EAA+BW,GAC/C,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQf,GAA2BrI,GAAQW,EAChD,CAGAgC,kBAAAA,CACE3C,EACAW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQX,GAA4BzI,GAAQW,EACjD,CAGA0I,0BAAAA,CACErJ,EACAW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQT,GAAoC3I,GAAQW,EACzD,CAGA8D,uBAAAA,CACEzE,EACAW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQN,GAAiC9I,GAAQW,EACtD,CAOAiE,UAAAA,CAAW5E,EAAyB,CAAC,EAAGW,GACtC,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQ5J,EAAoBQ,GAAQW,EACzC,CAOAkD,WAAAA,CAAY7D,EAAyBW,GACnC,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQ5G,EAAqBxC,GAAQW,EAC1C,CAGAmH,mBAAAA,CACE9H,EAAkC,CAAC,EACnCW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQ9E,EAA6BtE,GAAQW,EAClD,CAOAzE,IAAAA,CAAK8D,EAAwBW,GAC3B,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQnE,EAAoBjF,GAAQW,EACzC,CAGAoH,IAAAA,CAAK/H,EAAwBW,GAC3B,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQvD,EAAoB7F,GAAQW,EACzC,CAGAqH,MAAAA,CAAOhI,EAA0BW,GAC/B,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQ3C,EAAsBzG,GAAQW,EAC3C,CAGAsH,IAAAA,CAAKjI,EAAwBW,GAC3B,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQpC,EAAoBhH,GAAQW,EACzC,CAOAuH,wBAAAA,CACElI,EACAW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQhC,GAAuCpH,GAAQW,EAC5D,CAGAwH,uBAAAA,CACEnI,EACAW,GAEA,OAAO/E,KAAKJ,SACT2N,aACAC,QAAQ3B,GAAsCzH,GAAQW,EAC3D,EC5KK,MAAM2I,GAAcA,KAAA,CACzBC,OAAAA,CAAQ/N,GAENA,EAASoF,WAAW4I,SAASrI,EAAAA,GAC7B3F,EAASoF,WAAWQ,SAAW,SAE7BR,GAEA,OAAOhF,KAAK6N,IAAItI,EAAAA,EAAajH,KAAM0G,E,EAIrCpF,EAASoF,WAAW4I,SAASnL,EAAAA,GAC7B7C,EAASoF,WAAWiC,mBAAqB,SAEvCjC,GAEA,OAAOhF,KAAK6N,IAAIpL,EAAAA,EAAuBnE,KAAM0G,E,EAI/C,MAAM8I,EAAKlO,EAAS2N,aACpBO,EAAGF,SACDpC,GACAC,IAEFqC,EAAGF,SAAShK,EAAqBE,GACjCgK,EAAGF,SAAShH,EAAsBC,GAClCiH,EAAGF,SACDlF,EACAC,GAEFmF,EAAGF,SAASnB,GAA4BC,IACxCoB,EAAGF,SACDf,GACAC,IAEFgB,EAAGF,SACDb,GACAC,IAEFc,EAAGF,SACDV,GACAC,IAEFW,EAAGF,SAAS/C,EAAuBC,GACnCgD,EAAGF,SAASvE,EAAqBC,GACjCwE,EAAGF,SACD/B,GACAC,IAEFgC,EAAGF,SAAS3D,EAAqBC,GACjC4D,EAAGF,SAASxC,EAAqBC,GAEjCzL,EAAS8E,OAAS,WAChB,OAAO,IAAI4I,GAAYtN,K,CAE3B,G,8FCvFK,MAAMuF,EAAwB,CACnCjH,KAAM,eACNsD,QAAS7B,EAAAA,IAIE0C,EAAkC,CAC7CnE,KAAM,yBACNsD,QAASmM,EAAAA,G,kFCNX,MAAMC,EAAkB,IAKjB,MAAMC,EAKXtO,WAAAA,CAAYC,IAAoB0I,EAAAA,EAAAA,IAAA,iCAHwB,OAAIA,EAAAA,EAAAA,IAAA,yBACZ,MAG9CtI,KAAKJ,SAAWA,CAClB,CAEA,cAAMsO,CACJC,EACAC,EAAmB,EACnBC,EAAuB,EACvBC,GAAW,GAEX,MAAMC,QAAavO,KAAKwO,aAAaL,EAAOC,EAAkBE,GACxDG,EAAkBzO,KAAK0O,uBAAuBL,GAEpD,OAAOM,EAAAA,EAAAA,IAAWJ,EAAME,EAC1B,CAEA,kBAAMD,CACJL,EACAC,EAAmB,EACnBE,GAAW,GAEX,IACGA,GACkC,OAAnCtO,KAAK4O,2BACsB,OAA3B5O,KAAK6O,kBACL,CACA,MAAMC,QAAsB9O,KAAKJ,SAASsF,MAAM6J,QAAQ,GAGlDC,QAAqBhP,KAAKJ,SAASsF,MAAM6J,QAAQ,GACvD/O,KAAK4O,0BAA4BE,EACjC9O,KAAK6O,mBAAoBI,EAAAA,EAAAA,IAAgBD,EAAcF,EACzD,CAEA,MAAMI,GAAkBC,EAAAA,EAAAA,IACtBnP,KAAK4O,0BACLR,GAEIgB,GAAeD,EAAAA,EAAAA,IAAenP,KAAK6O,kBAAmBV,GAE5D,OAAOQ,EAAAA,EAAAA,IAAWO,EAAiBE,EACrC,CAEAV,sBAAAA,CAAuBL,EAAuB,GAE5C,OAAOgB,EAAAA,EAAAA,IAAShB,EAAuBL,EACzC,EC5DK,MAAMsB,EAAcA,KAAA,CACzB3B,OAAAA,CAAQ/N,GACN,MAAM2P,EAAc,IAAItB,EAAYrO,GACpCA,EAAS4P,MAAQ,IAAMD,CACzB,G,uECKK,MAAME,EAGX9P,WAAAA,CAAY+P,GACV1P,KAAK0P,cAAgBA,CACvB,CAEA,aAAIrO,GACF,IAAKrB,KAAK0P,cAAcrO,UACtB,MAAM,IAAIsO,EAAAA,GAGZ,OAAO3P,KAAK0P,cAAcrO,SAC5B,CAEA,iBAAauO,CAAYxH,GACvB,QAAuClB,IAAnClH,KAAK0P,cAAcE,YACrB,MAAM,IAAIC,EAAAA,GAA0C,eAGtD,OAAO7P,KAAK0P,cAAcE,YAAYxH,EACxC,CAEA,qBAAa0H,CAAgBC,GAC3B,QAA2C7I,IAAvClH,KAAK0P,cAAcI,gBACrB,MAAM,IAAID,EAAAA,GAA0C,mBAGtD,OAAO7P,KAAK0P,cAAcI,gBAAgBC,EAC5C,CAEA,yBAAaC,CACXC,GAEA,QAA+C/I,IAA3ClH,KAAK0P,cAAcM,oBACrB,MAAM,IAAIH,EAAAA,GACR,uBAIJ,OAAO7P,KAAK0P,cAAcM,oBAAoBC,EAChD,EChDW,MAAAC,EACXR,IAA4B,CAE5B/B,OAAAA,CAAQ/N,GACNA,EACG0F,WACA6K,UAAU,IAAIV,EAA4BC,GAC/C,G","sources":["webpack://app/../../../../src/plugins/tokenModule/accounts.ts","webpack://app/../../../../src/plugins/tokenModule/constants.ts","webpack://app/../../../../src/plugins/tokenModule/gpaBuilders.ts","webpack://app/../../../../src/plugins/tokenModule/models/Mint.ts","webpack://app/../../../../src/plugins/tokenModule/models/Token.ts","webpack://app/../../../../src/plugins/tokenModule/operations/createMint.ts","webpack://app/../../../../src/plugins/tokenModule/operations/createToken.ts","webpack://app/../../../../src/plugins/tokenModule/errors.ts","webpack://app/../../../../src/plugins/tokenModule/operations/createTokenWithMint.ts","webpack://app/../../../../src/plugins/tokenModule/operations/mintTokens.ts","webpack://app/../../../../src/plugins/tokenModule/operations/sendTokens.ts","webpack://app/../../../../src/plugins/tokenModule/operations/freezeTokens.ts","webpack://app/../../../../src/plugins/tokenModule/operations/thawTokens.ts","webpack://app/../../../../src/plugins/tokenModule/operations/approveTokenDelegateAuthority.ts","webpack://app/../../../../src/plugins/tokenModule/operations/revokeTokenDelegateAuthority.ts","webpack://app/../../../../src/plugins/tokenModule/TokenBuildersClient.ts","webpack://app/../../../../src/plugins/tokenModule/TokenPdasClient.ts","webpack://app/../../../../src/plugins/tokenModule/operations/findMintByAddress.ts","webpack://app/../../../../src/plugins/tokenModule/operations/findTokenByAddress.ts","webpack://app/../../../../src/plugins/tokenModule/operations/findTokenWithMintByAddress.ts","webpack://app/../../../../src/plugins/tokenModule/operations/findTokenWithMintByMint.ts","webpack://app/../../../../src/plugins/tokenModule/TokenClient.ts","webpack://app/../../../../src/plugins/tokenModule/plugin.ts","webpack://app/../../../../src/plugins/tokenModule/program.ts","webpack://app/../../../../src/plugins/utilsModule/UtilsClient.ts","webpack://app/../../../../src/plugins/utilsModule/plugin.ts","webpack://app/../../../../src/plugins/walletAdapterIdentity/WalletAdapterIdentityDriver.ts","webpack://app/../../../../src/plugins/walletAdapterIdentity/plugin.ts"],"sourcesContent":["import {\n  AccountLayout as SplTokenAccountLayout,\n  MintLayout as SplMintAccountLayout,\n  RawAccount as SplTokenAccount,\n  RawMint as SplMintAccount,\n} from '@solana/spl-token';\nimport { NotYetImplementedError } from '@/errors';\nimport {\n  Account,\n  SolitaType,\n  getAccountParsingAndAssertingFunction,\n  getAccountParsingFunction,\n} from '@/types';\n\nconst mintAccountParser: SolitaType<SplMintAccount> = {\n  name: 'MintAccount',\n  deserialize: (data: Buffer, offset?: number) => {\n    const span = SplMintAccountLayout.getSpan(data, offset);\n    const decoded = SplMintAccountLayout.decode(data, offset);\n    return [decoded, span];\n  },\n  fromArgs() {\n    throw new NotYetImplementedError();\n  },\n};\n\n/** @group Accounts */\nexport type MintAccount = Account<SplMintAccount>;\n\n/** @group Account Helpers */\nexport const parseMintAccount = getAccountParsingFunction(mintAccountParser);\n\n/** @group Account Helpers */\nexport const toMintAccount =\n  getAccountParsingAndAssertingFunction(mintAccountParser);\n\nconst tokenAccountParser: SolitaType<SplTokenAccount> = {\n  name: 'TokenAccount',\n  deserialize: (data: Buffer, offset?: number) => {\n    const span = SplTokenAccountLayout.getSpan(data, offset);\n    const decoded = SplTokenAccountLayout.decode(data, offset);\n    return [decoded, span];\n  },\n  fromArgs() {\n    throw new NotYetImplementedError();\n  },\n};\n\n/** @group Accounts */\nexport type TokenAccount = Account<SplTokenAccount>;\n\n/** @group Account Helpers */\nexport const parseTokenAccount = getAccountParsingFunction(tokenAccountParser);\n\n/** @group Account Helpers */\nexport const toTokenAccount =\n  getAccountParsingAndAssertingFunction(tokenAccountParser);\n","import { PublicKey } from '@solana/web3.js';\n\n/** @group Constants */\nexport const WRAPPED_SOL_MINT = new PublicKey(\n  'So11111111111111111111111111111111111111112'\n);\n","import { PublicKey } from '@solana/web3.js';\nimport { MINT_SIZE, ACCOUNT_SIZE, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Metaplex } from '@/Metaplex';\nimport { GpaBuilder } from '@/utils';\nimport { BigNumber } from '@/types';\n\nexport class MintGpaBuilder extends GpaBuilder {\n  constructor(metaplex: Metaplex, programId?: PublicKey) {\n    super(metaplex, programId ?? TOKEN_PROGRAM_ID);\n    this.whereSize(MINT_SIZE);\n  }\n\n  whereDoesntHaveMintAuthority() {\n    return this.where(0, 0);\n  }\n\n  whereHasMintAuthority() {\n    return this.where(0, 1);\n  }\n\n  whereMintAuthority(mintAuthority: PublicKey) {\n    return this.whereHasMintAuthority().where(4, mintAuthority);\n  }\n\n  whereSupply(supply: number | BigNumber) {\n    return this.where(36, supply);\n  }\n\n  // TODO(loris): Map the rest of the layout.\n  // https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/state/mint.ts#L43\n}\n\nexport class TokenGpaBuilder extends GpaBuilder {\n  constructor(metaplex: Metaplex, programId?: PublicKey) {\n    super(metaplex, programId ?? TOKEN_PROGRAM_ID);\n    this.whereSize(ACCOUNT_SIZE);\n  }\n\n  selectMint() {\n    return this.slice(0, 32);\n  }\n\n  whereMint(mint: PublicKey) {\n    return this.where(0, mint);\n  }\n\n  selectOwner() {\n    return this.slice(32, 32);\n  }\n\n  whereOwner(owner: PublicKey) {\n    return this.where(32, owner);\n  }\n\n  selectAmount() {\n    return this.slice(64, 8);\n  }\n\n  whereAmount(amount: number | BigNumber) {\n    return this.where(64, amount);\n  }\n\n  whereDoesntHaveDelegate() {\n    return this.where(72, 0);\n  }\n\n  whereHasDelegate() {\n    return this.where(72, 1);\n  }\n\n  whereDelegate(delegate: PublicKey) {\n    return this.whereHasDelegate().where(76, delegate);\n  }\n\n  // TODO(loris): Map the rest of the layout.\n  // https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/state/account.ts#L59\n}\n","import type { PublicKey } from '@solana/web3.js';\nimport { MintAccount } from '../accounts';\nimport { WRAPPED_SOL_MINT } from '../constants';\nimport { amount, SplTokenCurrency, SplTokenAmount } from '@/types';\nimport { assert, Option } from '@/utils';\n\n/**\n * This model represents a mint account.\n *\n * @group Models\n */\nexport type Mint = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'mint';\n\n  /** The address of the mint account. */\n  readonly address: PublicKey;\n\n  /**\n   * The address of the authority that is allowed\n   * to mint new tokens to token accounts.\n   *\n   * When `null`, no authority is ever allowed to mint new tokens.\n   */\n  readonly mintAuthorityAddress: Option<PublicKey>;\n\n  /**\n   * The address of the authority that is allowed\n   * to freeze token accounts.\n   *\n   * When `null`, no authority is ever allowed to freeze token accounts.\n   */\n  readonly freezeAuthorityAddress: Option<PublicKey>;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   */\n  readonly decimals: number;\n\n  /**\n   * The current supply of tokens across all token accounts.\n   */\n  readonly supply: SplTokenAmount;\n\n  /**\n   * Helper boolean to determine whether this mint account is the\n   * mint account that wraps SOL as an SPL token.\n   */\n  readonly isWrappedSol: boolean;\n\n  /**\n   * A currency object that can be used to create amounts\n   * representing the tokens of this mint account.\n   *\n   * For instance, here's how you can transform an amount of token\n   * in basis points into an `Amount` object.\n   *\n   * ```ts\n   * const tokenBasisPoints = 1000;\n   * const tokensAsAmount = amount(tokenBasisPoints, mint.currency);\n   * ```\n   */\n  readonly currency: SplTokenCurrency;\n};\n\n/** @group Model Helpers */\nexport const isMint = (value: any): value is Mint =>\n  typeof value === 'object' && value.model === 'mint';\n\n/** @group Model Helpers */\nexport function assertMint(value: any): asserts value is Mint {\n  assert(isMint(value), `Expected Mint model`);\n}\n\n/** @group Model Helpers */\nexport const toMint = (account: MintAccount): Mint => {\n  const isWrappedSol = account.publicKey.equals(WRAPPED_SOL_MINT);\n  const currency: SplTokenCurrency = {\n    symbol: isWrappedSol ? 'SOL' : 'Token',\n    decimals: account.data.decimals,\n    namespace: 'spl-token',\n  };\n\n  return {\n    model: 'mint',\n    address: account.publicKey,\n    mintAuthorityAddress: account.data.mintAuthorityOption\n      ? account.data.mintAuthority\n      : null,\n    freezeAuthorityAddress: account.data.freezeAuthorityOption\n      ? account.data.freezeAuthority\n      : null,\n    decimals: account.data.decimals,\n    supply: amount(account.data.supply.toString(), currency),\n    isWrappedSol,\n    currency,\n  };\n};\n","import type { PublicKey } from '@solana/web3.js';\nimport { AccountState } from '@solana/spl-token';\nimport { TokenAccount } from '../accounts';\nimport { associatedTokenProgram } from '../program';\nimport { Mint } from './Mint';\nimport { amount, Pda, SplTokenAmount, token } from '@/types';\nimport { assert, Option } from '@/utils';\n\n/**\n * This model represents a token account.\n *\n * @group Models\n */\nexport type Token = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'token';\n\n  /** The address of the token account. */\n  readonly address: PublicKey | Pda;\n\n  /** Whether or not this is an associated token account. */\n  readonly isAssociatedToken: boolean;\n\n  /** The address of the mint account. */\n  readonly mintAddress: PublicKey;\n\n  /** The address of the owner of this token account. */\n  readonly ownerAddress: PublicKey;\n\n  /** The amount of tokens held in this account. */\n  readonly amount: SplTokenAmount;\n\n  /**\n   * The address of the authority that can close the account.\n   * This field is optional and may be `null`.\n   */\n  readonly closeAuthorityAddress: Option<PublicKey>;\n\n  /**\n   * The address of the authority that can act on behalf of the owner\n   * of the account. This field is optional and may be `null`.\n   */\n  readonly delegateAddress: Option<PublicKey>;\n\n  /**\n   * The amount of tokens that were delegated to the delegate authority.\n   * This means the delegate authority cannot transfer more tokens\n   * than this amount even if the token account has more tokens available.\n   *\n   * This field is only relevant if the account has a delegate authority.\n   */\n  readonly delegateAmount: SplTokenAmount;\n\n  /**\n   * The state of the token account.\n   * It is mostly used to determine whether or not the account is frozen.\n   *\n   * It can be one of the following:\n   * - `AccountState.Uninitialized`: The account has not been initialized.\n   *   This should never happen in this model since the SDK would fail to\n   *   parse this model if it were uninitialized.\n   * - `AccountState.Initialized`: The account has been initialized and is not frozen.\n   * - `AccountState.Frozen`: The account has been initialized and is frozen.\n   */\n  readonly state: AccountState;\n};\n\n/** @group Model Helpers */\nexport const isToken = (value: any): value is Token =>\n  typeof value === 'object' && value.model === 'token';\n\n/** @group Model Helpers */\nexport function assertToken(value: any): asserts value is Token {\n  assert(isToken(value), `Expected Token model`);\n}\n\n/** @group Model Helpers */\nexport const toToken = (account: TokenAccount): Token => {\n  const associatedTokenAddress = Pda.find(associatedTokenProgram.address, [\n    account.data.owner.toBuffer(),\n    account.owner.toBuffer(),\n    account.data.mint.toBuffer(),\n  ]);\n  const isAssociatedToken = associatedTokenAddress.equals(account.publicKey);\n\n  return {\n    model: 'token',\n    address: isAssociatedToken ? associatedTokenAddress : account.publicKey,\n    isAssociatedToken,\n    mintAddress: account.data.mint,\n    ownerAddress: account.data.owner,\n    amount: token(account.data.amount.toString()),\n    closeAuthorityAddress: account.data.closeAuthorityOption\n      ? account.data.closeAuthority\n      : null,\n    delegateAddress: account.data.delegateOption ? account.data.delegate : null,\n    delegateAmount: token(account.data.delegatedAmount.toString()),\n    state: account.data.state,\n  };\n};\n\n/** @group Models */\nexport type TokenWithMint = Omit<Token, 'model' | 'mintAddress'> &\n  Readonly<{\n    model: 'tokenWithMint';\n    mint: Mint;\n  }>;\n\n/** @group Model Helpers */\nexport const isTokenWithMint = (value: any): value is TokenWithMint =>\n  typeof value === 'object' && value.model === 'tokenWithMint';\n\n/** @group Model Helpers */\nexport function assertTokenWithMint(\n  value: any\n): asserts value is TokenWithMint {\n  assert(isTokenWithMint(value), `Expected TokenWithMint model`);\n}\n\n/** @group Model Helpers */\nexport const toTokenWithMint = (\n  tokenAccount: TokenAccount,\n  mintModel: Mint\n): TokenWithMint => {\n  const token = toToken(tokenAccount);\n  return {\n    ...token,\n    model: 'tokenWithMint',\n    mint: mintModel,\n    amount: amount(token.amount.basisPoints, mintModel.currency),\n    delegateAmount: amount(\n      token.delegateAmount.basisPoints,\n      mintModel.currency\n    ),\n  };\n};\n","import { createInitializeMintInstruction, MINT_SIZE } from '@solana/spl-token';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Mint } from '../models/Mint';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateMintOperation' as const;\n\n/**\n * Creates a new mint account.\n *\n * ```ts\n * const { mint } = await metaplex.tokens().createMint();\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createMintOperation = useOperation<CreateMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateMintOperation = Operation<\n  typeof Key,\n  CreateMintInput,\n  CreateMintOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateMintInput = {\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /**\n   * The address of the new mint account as a Signer.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  mint?: Signer;\n\n  /**\n   * The address of the authority that is allowed\n   * to mint new tokens to token accounts.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  mintAuthority?: PublicKey;\n\n  /**\n   * The address of the authority that is allowed\n   * to freeze token accounts.\n   *\n   * @defaultValue Defaults to using the same value as the\n   * `mintAuthority` parameter.\n   */\n  freezeAuthority?: Option<PublicKey>;\n};\n\n/**\n * Create a new Mint account from the provided input\n * and returns the newly created `Mint` model.\n *\n * @group Operations\n * @category Outputs\n */\nexport type CreateMintOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The mint account as a Signer. */\n  mintSigner: Signer;\n\n  /** The created mint account. */\n  mint: Mint;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createMintOperationHandler: OperationHandler<CreateMintOperation> =\n  {\n    async handle(\n      operation: CreateMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateMintOutput> {\n      const builder = await createMintBuilder(metaplex, operation.input, scope);\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const mint = await metaplex\n        .tokens()\n        .findMintByAddress({ address: output.mintSigner.publicKey }, scope);\n\n      return { ...output, mint };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateMintBuilderParams = Omit<\n  CreateMintInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateMintBuilderContext = Omit<\n  CreateMintOutput,\n  'response' | 'mint'\n>;\n\n/**\n * Creates a new mint account.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createMint();\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createMintBuilder = async (\n  metaplex: Metaplex,\n  params: CreateMintBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateMintBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    decimals = 0,\n    mint = Keypair.generate(),\n    mintAuthority = metaplex.identity().publicKey,\n    freezeAuthority = mintAuthority,\n  } = params;\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n\n  return (\n    TransactionBuilder.make<CreateMintBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({ mintSigner: mint })\n\n      // Create an empty account for the mint.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: mint,\n              space: MINT_SIZE,\n              program: tokenProgram.address,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the mint.\n      .add({\n        instruction: createInitializeMintInstruction(\n          mint.publicKey,\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          tokenProgram.address\n        ),\n        signers: [mint],\n        key: params.initializeMintInstructionKey ?? 'initializeMint',\n      })\n  );\n};\n","import {\n  ACCOUNT_SIZE,\n  createAssociatedTokenAccountInstruction,\n  createInitializeAccountInstruction,\n} from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Token } from '../models/Token';\nimport { ExpectedSignerError } from '@/errors';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenOperation' as const;\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createToken({ mint });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createTokenOperation = useOperation<CreateTokenOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateTokenOperation = Operation<\n  typeof Key,\n  CreateTokenInput,\n  CreateTokenOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateTokenInput = {\n  /**\n   * The address of the mint account associated\n   * with the new token account.\n   */\n  mint: PublicKey;\n\n  /**\n   * The address of the owner of the new token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The token account as a Signer if we want to create\n   * a new token account with a specific address instead of\n   * creating a new associated token account.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mint` and `owner` parameters.\n   */\n  token?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateTokenOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created token account. */\n  token: Token;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createTokenOperationHandler: OperationHandler<CreateTokenOperation> =\n  {\n    async handle(\n      operation: CreateTokenOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateTokenOutput> {\n      const builder = await createTokenBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const token = await metaplex\n        .tokens()\n        .findTokenByAddress({ address: output.tokenAddress }, scope);\n\n      return { ...output, token };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenBuilderParams = Omit<\n  CreateTokenInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateTokenBuilderContext = {\n  /** The computed address of the token account to create. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createToken({ mint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createTokenBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mint, owner = metaplex.identity().publicKey, token } = params;\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex\n    .programs()\n    .getAssociatedToken(programs);\n\n  const isAssociatedToken = token === undefined;\n  const builder =\n    TransactionBuilder.make<CreateTokenBuilderContext>().setFeePayer(payer);\n\n  if (isAssociatedToken) {\n    const associatedTokenAddress = metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({ mint, owner, programs });\n\n    return (\n      builder\n        .setContext({ tokenAddress: associatedTokenAddress })\n\n        // Create an associated token account.\n        .add({\n          instruction: createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedTokenAddress,\n            owner,\n            mint,\n            tokenProgram.address,\n            associatedTokenProgram.address\n          ),\n          signers: [payer],\n          key:\n            params.createAssociatedTokenAccountInstructionKey ??\n            'createAssociatedTokenAccount',\n        })\n    );\n  }\n\n  return (\n    builder\n      .setFeePayer(payer)\n      .setContext({ tokenAddress: token.publicKey })\n\n      // Create an empty account for the Token.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: token,\n              space: ACCOUNT_SIZE,\n              program: tokenProgram.address,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the Token.\n      .add({\n        instruction: createInitializeAccountInstruction(\n          token.publicKey,\n          mint,\n          owner,\n          tokenProgram.address\n        ),\n        signers: [token],\n        key: params.initializeTokenInstructionKey ?? 'initializeToken',\n      })\n  );\n};\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenIfMissingBuilderParams = Omit<\n  CreateTokenBuilderParams,\n  'token'\n> & {\n  /**\n   * The token account to create if it does not exist.\n   * Here, it may be passed as a PublicKey if and only\n   * if it already exists.\n   */\n  token?: PublicKey | Signer;\n\n  /**\n   * Whether or not the token account exists.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /**\n   * The name of the token variable on the operation that uses\n   * this helper token builder.\n   *\n   * @defaultValue `\"token\"`\n   */\n  tokenVariable?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Constructors\n * @internal\n */\nexport const createTokenIfMissingBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenIfMissingBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mint,\n    owner = metaplex.identity().publicKey,\n    token,\n    tokenExists = true,\n    tokenVariable = 'token',\n  } = params;\n\n  const destination =\n    token ??\n    metaplex.tokens().pdas().associatedTokenAccount({ mint, owner, programs });\n  const destinationAddress = toPublicKey(destination);\n  const builder = TransactionBuilder.make<CreateTokenBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ tokenAddress: destinationAddress });\n\n  if (tokenExists) {\n    return builder;\n  }\n\n  // When creating a token account, ensure it is passed as a Signer.\n  if (token && !isSigner(token)) {\n    throw new ExpectedSignerError(\n      tokenVariable,\n      'PublicKey',\n      `The provided \"${tokenVariable}\" account ` +\n        `at address [${destinationAddress}] does not exist. ` +\n        `Therefore, it needs to be created and passed as a Signer. ` +\n        `If you want to create the \"${tokenVariable}\" account, then please pass it as a Signer. ` +\n        `Alternatively, you can pass the owner account as a PublicKey instead to ` +\n        `use (or create) an associated token account.`\n    );\n  }\n\n  return builder.add(\n    await metaplex\n      .tokens()\n      .builders()\n      .createToken(\n        {\n          ...params,\n          mint,\n          owner,\n          token,\n        },\n        { programs, payer }\n      )\n  );\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { MetaplexError } from '@/errors';\n\n/** @group Errors */\nexport class TokenError extends MetaplexError {\n  readonly name: string = 'TokenError';\n  constructor(message: string, cause?: Error) {\n    super(message, 'plugin', 'Token', cause);\n  }\n}\n\n/** @group Errors */\nexport class MintAuthorityMustBeSignerToMintInitialSupplyError extends TokenError {\n  readonly name: string = 'MintAuthorityMustBeSignerToMintInitialSupplyError';\n  constructor() {\n    const message =\n      'You are trying to create a Mint and a Token account and to send an initial ' +\n      'supply of token to the newly created Token account. The issue is, you have provided ' +\n      \"a Mint Authority as a Public Key which means we don't have the rights to send this transaction. \" +\n      'Please provide the Mint Authority as a Signer when using the \"createTokenWithMint\" operation ' +\n      ', so we can send the initial supply. Alternative, remove the initial supply from the operation for it to succeed.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class TokenAndMintDoNotMatchError extends TokenError {\n  constructor(token: PublicKey, tokenMint: PublicKey, mint: PublicKey) {\n    const message =\n      `The provided Token and Mint accounts do not match. That is, the mint address [${tokenMint}] ` +\n      `stored in the Token account [${token}] do not match the address of the Mint account [${mint}]. ` +\n      'Please provide a Token account that belongs to the provided Mint account.';\n    super(message);\n  }\n}\n","import { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { MintAuthorityMustBeSignerToMintInitialSupplyError } from '../errors';\nimport { TokenWithMint } from '../models/Token';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenWithMintOperation' as const;\n\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createTokenWithMint();\n * const mint = token.mint;\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createTokenWithMintOperation =\n  useOperation<CreateTokenWithMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateTokenWithMintOperation = Operation<\n  typeof Key,\n  CreateTokenWithMintInput,\n  CreateTokenWithMintOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateTokenWithMintInput = {\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /**\n   * The initial amount of tokens to mint to the new token account.\n   *\n   * @defaultValue `0`\n   */\n  initialSupply?: SplTokenAmount;\n\n  /**\n   * The address of the new mint account as a Signer.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  mint?: Signer;\n\n  /**\n   * The address of the authority that is allowed\n   * to mint new tokens to token accounts.\n   *\n   * It may be required as a Signer in order to\n   * mint the initial supply.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer | PublicKey;\n\n  /**\n   * The address of the authority that is allowed\n   * to freeze token accounts.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  freezeAuthority?: Option<PublicKey>;\n\n  /**\n   * The address of the owner of the new token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The token account as a Signer if we want to create\n   * a new token account with a specific address instead of\n   * creating a new associated token account.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mint` and `owner` parameters.\n   */\n  token?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateTokenWithMintOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The new mint account as a Signer. */\n  mintSigner: Signer;\n\n  /**\n   * A model representing the newly created token\n   * account and its associated mint account.\n   */\n  token: TokenWithMint;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createTokenWithMintOperationHandler: OperationHandler<CreateTokenWithMintOperation> =\n  {\n    async handle(\n      operation: CreateTokenWithMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateTokenWithMintOutput> {\n      const builder = await createTokenWithMintBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const token = await metaplex.tokens().findTokenWithMintByMint(\n        {\n          mint: output.mintSigner.publicKey,\n          address: output.tokenAddress,\n          addressType: 'token',\n        },\n        scope\n      );\n\n      return { ...output, token };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenWithMintBuilderParams = Omit<\n  CreateTokenWithMintInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associates token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens to the token account. */\n  mintTokensInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateTokenWithMintBuilderContext = {\n  /** The mint account to create as a Signer. */\n  mintSigner: Signer;\n\n  /** The computed address of the token account to create. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createTokenWithMint();\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createTokenWithMintBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenWithMintBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenWithMintBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    decimals = 0,\n    initialSupply,\n    mint = Keypair.generate(),\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    owner = metaplex.identity().publicKey,\n    token,\n  } = params;\n\n  const createMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createMint(\n      {\n        decimals,\n        mint,\n        mintAuthority: toPublicKey(mintAuthority),\n        freezeAuthority,\n        createAccountInstructionKey:\n          params.createMintAccountInstructionKey ?? 'createMintAccount',\n        initializeMintInstructionKey:\n          params.initializeMintInstructionKey ?? 'initializeMint',\n      },\n      { programs, payer }\n    );\n\n  const createTokenBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createToken(\n      {\n        mint: mint.publicKey,\n        owner,\n        token,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey ??\n          'createAssociatedTokenAccount',\n        createAccountInstructionKey:\n          params.createTokenAccountInstructionKey ?? 'createTokenAccount',\n        initializeTokenInstructionKey:\n          params.initializeTokenInstructionKey ?? 'initializeToken',\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = createTokenBuilder.getContext();\n\n  const builder = TransactionBuilder.make<CreateTokenWithMintBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ mintSigner: mint, tokenAddress })\n\n    // Create the Mint account.\n    .add(createMintBuilder)\n\n    // Create the Token account.\n    .add(createTokenBuilder);\n\n  // Potentially mint the initial supply to the token account.\n  if (!!initialSupply) {\n    if (!isSigner(mintAuthority)) {\n      throw new MintAuthorityMustBeSignerToMintInitialSupplyError();\n    }\n\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .mint(\n          {\n            mintAddress: mint.publicKey,\n            toToken: tokenAddress,\n            amount: initialSupply,\n            mintAuthority,\n            mintTokensInstructionKey:\n              params.mintTokensInstructionKey ?? 'mintTokens',\n          },\n          { payer, programs }\n        )\n    );\n  }\n\n  return builder;\n};\n","import { createMintToInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintTokensOperation' as const;\n\n/**\n * Mint tokens to an account.\n *\n * ```ts\n * await metaplex\n *   .tokens()\n *   .mint({\n *     mintAddress,\n *     toOwner,\n *     amount: token(100),\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintTokensOperation = useOperation<MintTokensOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintTokensOperation = Operation<\n  typeof Key,\n  MintTokensInput,\n  MintTokensOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintTokensInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The amount of tokens to mint. */\n  amount: SplTokenAmount;\n\n  /**\n   * The owner of the token account to mint to.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  toOwner?: PublicKey;\n\n  /**\n   * The address of the token account to mint to.\n   *\n   * Note that this may be required as a `Signer` if the destination\n   * token account does not exist and we need to create it before\n   * minting the tokens.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `toOwner` parameters.\n   */\n  toToken?: PublicKey | Signer;\n\n  /**\n   * The authority that is allowed to mint new tokens as a Signer.\n   *\n   * This may be provided as a PublicKey if and only if\n   * the `multiSigners` parameter is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: PublicKey | Signer;\n\n  /**\n   * The signing accounts to use if the mint authority is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  multiSigners?: KeypairSigner[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintTokensOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintTokensOperationHandler: OperationHandler<MintTokensOperation> =\n  {\n    async handle(\n      operation: MintTokensOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MintTokensOutput> {\n      const { programs, confirmOptions } = scope;\n      const {\n        mintAddress,\n        toOwner = metaplex.identity().publicKey,\n        toToken,\n      } = operation.input;\n\n      const destination =\n        toToken ??\n        metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: toOwner,\n          programs,\n        });\n      const destinationAddress = toPublicKey(destination);\n      const destinationAccountExists = await metaplex\n        .rpc()\n        .accountExists(destinationAddress);\n      scope.throwIfCanceled();\n\n      const builder = await mintTokensBuilder(\n        metaplex,\n        { ...operation.input, toTokenExists: destinationAccountExists },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      return builder.sendAndConfirm(metaplex, confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintTokensBuilderParams = Omit<\n  MintTokensInput,\n  'confirmOptions'\n> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  toTokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n};\n\n/**\n * Mint tokens to an account.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .tokens()\n *   .builders()\n *   .mint({\n *     mintAddress,\n *     toOwner,\n *     amount: token(100),\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintTokensBuilder = async (\n  metaplex: Metaplex,\n  params: MintTokensBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    amount,\n    toOwner = metaplex.identity().publicKey,\n    toToken,\n    toTokenExists = true,\n    mintAuthority = metaplex.identity(),\n    multiSigners = [],\n  } = params;\n\n  const [mintAuthorityPublicKey, signers] = isSigner(mintAuthority)\n    ? [mintAuthority.publicKey, [mintAuthority]]\n    : [mintAuthority, multiSigners];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const destination =\n    toToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: toOwner,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n\n      // Create token account if missing.\n      .add(\n        await metaplex\n          .tokens()\n          .builders()\n          .createTokenIfMissing(\n            {\n              ...params,\n              mint: mintAddress,\n              owner: toOwner,\n              token: toToken,\n              tokenExists: toTokenExists,\n              tokenVariable: 'toToken',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Mint tokens.\n      .add({\n        instruction: createMintToInstruction(\n          mintAddress,\n          toPublicKey(destination),\n          mintAuthorityPublicKey,\n          amount.basisPoints.toNumber(),\n          multiSigners,\n          tokenProgram.address\n        ),\n        signers,\n        key: params.mintTokensInstructionKey ?? 'mintTokens',\n      })\n  );\n};\n","import { createTransferInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'SendTokensOperation' as const;\n\n/**\n * Send tokens from one account to another.\n *\n * ```ts\n * await metaplex\n *   .tokens()\n *   .send({\n *     mintAddress,\n *     toOwner,\n *     amount: token(100),\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const sendTokensOperation = useOperation<SendTokensOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type SendTokensOperation = Operation<\n  typeof Key,\n  SendTokensInput,\n  SendTokensOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type SendTokensInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The amount of tokens to send. */\n  amount: SplTokenAmount;\n\n  /**\n   * The owner of the destination token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  toOwner?: PublicKey;\n\n  /**\n   * The address of the destination token account.\n   *\n   * Note that this may be required as a `Signer` if the destination\n   * token account does not exist and we need to create it before\n   * sending the tokens.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `toOwner` parameters.\n   */\n  toToken?: PublicKey | Signer;\n\n  /**\n   * The owner of the source token account.\n   *\n   * This may be provided as a PublicKey if one of the following is true:\n   * - the owner of the source token account is a multisig and the\n   *   `fromMultiSigners` parameter is provided.\n   * - we are using a delegate authority to send the tokens and the\n   *   `delegateAuthority` parameter is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  fromOwner?: PublicKey | Signer; // Defaults to mx.identity().\n\n  /**\n   * The address of the source token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `fromOwner` parameters.\n   */\n  fromToken?: PublicKey;\n\n  /**\n   * The signing accounts to use if the source token owner is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  fromMultiSigners?: KeypairSigner[];\n\n  /**\n   * The delegate authority of the source token account as a Signer.\n   *\n   * This is required when the owner of the source token account\n   * is provided as a PublicKey as someone needs to authorize\n   * that transfer of tokens.\n   *\n   * @defaultValue Defaults to not using a delegate authority.\n   */\n  delegateAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type SendTokensOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const sendTokensOperationHandler: OperationHandler<SendTokensOperation> =\n  {\n    async handle(\n      operation: SendTokensOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<SendTokensOutput> {\n      const {\n        mintAddress,\n        toOwner = metaplex.identity().publicKey,\n        toToken,\n      } = operation.input;\n\n      const destination =\n        toToken ??\n        metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: toOwner,\n          programs: scope.programs,\n        });\n      const destinationAddress = toPublicKey(destination);\n      const destinationAccountExists = await metaplex\n        .rpc()\n        .accountExists(destinationAddress);\n      scope.throwIfCanceled();\n\n      const builder = await sendTokensBuilder(\n        metaplex,\n        { ...operation.input, toTokenExists: destinationAccountExists },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type SendTokensBuilderParams = Omit<\n  SendTokensInput,\n  'confirmOptions'\n> & {\n  /**\n   * Whether or not the receiving token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  toTokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that transfers the tokens. */\n  transferTokensInstructionKey?: string;\n};\n\n/**\n * Send tokens from one account to another.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .tokens()\n *   .builders()\n *   .send({\n *     mintAddress,\n *     toOwner,\n *     amount: token(100),\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const sendTokensBuilder = async (\n  metaplex: Metaplex,\n  params: SendTokensBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    amount,\n    toOwner = metaplex.identity().publicKey,\n    toToken,\n    toTokenExists = true,\n    fromOwner = metaplex.identity(),\n    fromToken,\n    fromMultiSigners = [],\n    delegateAuthority,\n  } = params;\n\n  const [fromOwnerPublicKey, signers] = isSigner(fromOwner)\n    ? [fromOwner.publicKey, [fromOwner]]\n    : [fromOwner, [delegateAuthority, ...fromMultiSigners].filter(isSigner)];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const source =\n    fromToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: fromOwnerPublicKey,\n      programs,\n    });\n  const destination =\n    toToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: toOwner,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Create token account if missing.\n      .add(\n        await metaplex\n          .tokens()\n          .builders()\n          .createTokenIfMissing(\n            {\n              ...params,\n              mint: mintAddress,\n              owner: toOwner,\n              token: toToken,\n              tokenExists: toTokenExists,\n              tokenVariable: 'toToken',\n            },\n            { programs, payer }\n          )\n      )\n\n      // Transfer tokens.\n      .add({\n        instruction: createTransferInstruction(\n          source,\n          toPublicKey(destination),\n          delegateAuthority ? delegateAuthority.publicKey : fromOwnerPublicKey,\n          amount.basisPoints.toNumber(),\n          fromMultiSigners,\n          tokenProgram.address\n        ),\n        signers,\n        key: params.transferTokensInstructionKey ?? 'transferTokens',\n      })\n  );\n};\n","import { createFreezeAccountInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FreezeTokensOperation' as const;\n\n/**\n * Freezes a token account.\n *\n * ```ts\n * await metaplex.tokens().freeze({ mintAddress, freezeAuthority });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const freezeTokensOperation = useOperation<FreezeTokensOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FreezeTokensOperation = Operation<\n  typeof Key,\n  FreezeTokensInput,\n  FreezeTokensOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FreezeTokensInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The freeze authority as a Signer.\n   *\n   * This may be provided as a PublicKey if and only if\n   * the `multiSigners` parameter is provided.\n   */\n  freezeAuthority: PublicKey | Signer;\n\n  /**\n   * The owner of the token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The signing accounts to use if the freeze authority is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  multiSigners?: KeypairSigner[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FreezeTokensOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const freezeTokensOperationHandler: OperationHandler<FreezeTokensOperation> =\n  {\n    async handle(\n      operation: FreezeTokensOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FreezeTokensOutput> {\n      return freezeTokensBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type FreezeTokensBuilderParams = Omit<\n  FreezeTokensInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that freezes the token account. */\n  instructionKey?: string;\n};\n\n/**\n * Freezes a token account.\n *\n * ```ts\n * const transactionBuilder = metaplex.tokens().builders().freeze({ mintAddress, freezeAuthority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const freezeTokensBuilder = (\n  metaplex: Metaplex,\n  params: FreezeTokensBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    tokenOwner = metaplex.identity().publicKey,\n    tokenAddress,\n    multiSigners = [],\n    freezeAuthority,\n  } = params;\n\n  const [authorityPublicKey, signers] = isSigner(freezeAuthority)\n    ? [freezeAuthority.publicKey, [freezeAuthority]]\n    : [freezeAuthority, multiSigners];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenAddressOrAta =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createFreezeAccountInstruction(\n        tokenAddressOrAta,\n        mintAddress,\n        authorityPublicKey,\n        multiSigners,\n        tokenProgram.address\n      ),\n      signers,\n      key: params.instructionKey ?? 'freezeTokens',\n    });\n};\n","import { createThawAccountInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ThawTokensOperation' as const;\n\n/**\n * Thaws a token account.\n *\n * ```ts\n * await metaplex.tokens().thaw({ mintAddress, freezeAuthority });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const thawTokensOperation = useOperation<ThawTokensOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ThawTokensOperation = Operation<\n  typeof Key,\n  ThawTokensInput,\n  ThawTokensOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ThawTokensInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The freeze authority as a Signer.\n   *\n   * This may be provided as a PublicKey if and only if\n   * the `multiSigners` parameter is provided.\n   */\n  freezeAuthority: PublicKey | Signer;\n\n  /**\n   * The owner of the token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The signing accounts to use if the freeze authority is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  multiSigners?: KeypairSigner[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ThawTokensOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const thawTokensOperationHandler: OperationHandler<ThawTokensOperation> =\n  {\n    async handle(\n      operation: ThawTokensOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ThawTokensOutput> {\n      return thawTokensBuilder(metaplex, operation.input, scope).sendAndConfirm(\n        metaplex,\n        scope.confirmOptions\n      );\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ThawTokensBuilderParams = Omit<\n  ThawTokensInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that thaws the token account. */\n  instructionKey?: string;\n};\n\n/**\n * Thaws a token account.\n *\n * ```ts\n * const transactionBuilder = metaplex.tokens().builders().thaw({ mintAddress, freezeAuthority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const thawTokensBuilder = (\n  metaplex: Metaplex,\n  params: ThawTokensBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    tokenOwner = metaplex.identity().publicKey,\n    tokenAddress,\n    multiSigners = [],\n    freezeAuthority,\n  } = params;\n\n  const [authorityPublicKey, signers] = isSigner(freezeAuthority)\n    ? [freezeAuthority.publicKey, [freezeAuthority]]\n    : [freezeAuthority, multiSigners];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenAddressOrAta =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createThawAccountInstruction(\n        tokenAddressOrAta,\n        mintAddress,\n        authorityPublicKey,\n        multiSigners,\n        tokenProgram.address\n      ),\n      signers,\n      key: params.instructionKey ?? 'thawTokens',\n    });\n};\n","import { createApproveInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  token,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ApproveTokenDelegateAuthorityOperation' as const;\n\n/**\n * Approves a delegate authority for a token account.\n *\n * ```ts\n * await metaplex\n *   .tokens()\n *   .approveDelegateAuthority({\n *     delegateAuthority,\n *     mintAddress,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const approveTokenDelegateAuthorityOperation =\n  useOperation<ApproveTokenDelegateAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ApproveTokenDelegateAuthorityOperation = Operation<\n  typeof Key,\n  ApproveTokenDelegateAuthorityInput,\n  ApproveTokenDelegateAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n * */\nexport type ApproveTokenDelegateAuthorityInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the new delegate authority. */\n  delegateAuthority: PublicKey;\n\n  /**\n   * The maximum amount of tokens that can be manipulated\n   * by the new delegate authority.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n\n  /**\n   * The owner of the token account as a Signer.\n   *\n   * This may be provided as a PublicKey if and only if\n   * the `multiSigners` parameter is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: Signer | PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The signing accounts to use if the token owner is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  multiSigners?: KeypairSigner[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ApproveTokenDelegateAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const approveTokenDelegateAuthorityOperationHandler: OperationHandler<ApproveTokenDelegateAuthorityOperation> =\n  {\n    handle: async (\n      operation: ApproveTokenDelegateAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ApproveTokenDelegateAuthorityOutput> => {\n      return approveTokenDelegateAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ApproveTokenDelegateAuthorityBuilderParams = Omit<\n  ApproveTokenDelegateAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that approves the delegate authority. */\n  instructionKey?: string;\n};\n\n/**\n * Approves a delegate authority for a token account.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .tokens()\n *   .builders()\n *   .approveDelegateAuthority({\n *     delegateAuthority,\n *     mintAddress,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const approveTokenDelegateAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: ApproveTokenDelegateAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    delegateAuthority,\n    amount = token(1),\n    owner = metaplex.identity(),\n    tokenAddress,\n    multiSigners = [],\n  } = params;\n\n  const [ownerPublicKey, signers] = isSigner(owner)\n    ? [owner.publicKey, [owner]]\n    : [owner, multiSigners];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenAddressOrAta =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: ownerPublicKey,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createApproveInstruction(\n        tokenAddressOrAta,\n        delegateAuthority,\n        ownerPublicKey,\n        amount.basisPoints.toNumber(),\n        multiSigners,\n        tokenProgram.address\n      ),\n      signers,\n      key: params.instructionKey ?? 'approveDelegateAuthority',\n    });\n};\n","import { createRevokeInstruction } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  KeypairSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'RevokeTokenDelegateAuthorityOperation' as const;\n\n/**\n * Revokes the current delegate authority for a token account.\n *\n * ```ts\n * await metaplex\n *   .tokens()\n *   .revokeDelegateAuthority({ mintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const revokeTokenDelegateAuthorityOperation =\n  useOperation<RevokeTokenDelegateAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type RevokeTokenDelegateAuthorityOperation = Operation<\n  typeof Key,\n  RevokeTokenDelegateAuthorityInput,\n  RevokeTokenDelegateAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type RevokeTokenDelegateAuthorityInput = {\n  mintAddress: PublicKey;\n\n  /**\n   * The owner of the token account as a Signer.\n   *\n   * This may be provided as a PublicKey if and only if\n   * the `multiSigners` parameter is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: Signer | PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The signing accounts to use if the token owner is a multisig.\n   *\n   * @defaultValue `[]`\n   */\n  multiSigners?: KeypairSigner[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type RevokeTokenDelegateAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const revokeTokenDelegateAuthorityOperationHandler: OperationHandler<RevokeTokenDelegateAuthorityOperation> =\n  {\n    handle: async (\n      operation: RevokeTokenDelegateAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<RevokeTokenDelegateAuthorityOutput> => {\n      return revokeTokenDelegateAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type RevokeTokenDelegateAuthorityBuilderParams = Omit<\n  RevokeTokenDelegateAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that revokes the delegated authority. */\n  instructionKey?: string;\n};\n\n/**\n * Revokes the current delegate authority for a token account.\n *\n * ```ts\n * await metaplex\n *   .tokens()\n *   .builders()\n *   .revokeDelegateAuthority({ mintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const revokeTokenDelegateAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: RevokeTokenDelegateAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    owner = metaplex.identity(),\n    tokenAddress,\n    multiSigners = [],\n  } = params;\n\n  const [ownerPublicKey, signers] = isSigner(owner)\n    ? [owner.publicKey, [owner]]\n    : [owner, multiSigners];\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenAccount =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: ownerPublicKey,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createRevokeInstruction(\n        tokenAccount,\n        ownerPublicKey,\n        multiSigners,\n        tokenProgram.address\n      ),\n      signers,\n      key: params.instructionKey ?? 'revokeDelegateAuthority',\n    });\n};\n","import {\n  approveTokenDelegateAuthorityBuilder,\n  ApproveTokenDelegateAuthorityBuilderParams,\n  createMintBuilder,\n  CreateMintBuilderParams,\n  createTokenBuilder,\n  CreateTokenBuilderParams,\n  createTokenIfMissingBuilder,\n  CreateTokenIfMissingBuilderParams,\n  createTokenWithMintBuilder,\n  CreateTokenWithMintBuilderParams,\n  freezeTokensBuilder,\n  FreezeTokensBuilderParams,\n  mintTokensBuilder,\n  MintTokensBuilderParams,\n  revokeTokenDelegateAuthorityBuilder,\n  RevokeTokenDelegateAuthorityBuilderParams,\n  sendTokensBuilder,\n  SendTokensBuilderParams,\n  thawTokensBuilder,\n  ThawTokensBuilderParams,\n} from './operations';\nimport type { Metaplex } from '@/Metaplex';\nimport { TransactionBuilderOptions } from '@/utils';\n\n/**\n * This client allows you to access the underlying Transaction Builders\n * for the write operations of the Token module.\n *\n * @see {@link TokenClient}\n * @group Module Builders\n * */\nexport class TokenBuildersClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  // -----------------\n  // Create\n  // -----------------\n\n  /** {@inheritDoc createMintBuilder} */\n  createMint(\n    input: CreateMintBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createMintBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createTokenBuilder} */\n  createToken(\n    input: CreateTokenBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createTokenBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createTokenIfMissingBuilder} @internal */\n  createTokenIfMissing(\n    input: CreateTokenIfMissingBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createTokenIfMissingBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createTokenWithMintBuilder} */\n  createTokenWithMint(\n    input: CreateTokenWithMintBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createTokenWithMintBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Update\n  // -----------------\n\n  /** {@inheritDoc mintTokensBuilder} */\n  mint(input: MintTokensBuilderParams, options?: TransactionBuilderOptions) {\n    return mintTokensBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc sendTokensBuilder} */\n  send(input: SendTokensBuilderParams, options?: TransactionBuilderOptions) {\n    return sendTokensBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc freezeTokensBuilder} */\n  freeze(\n    input: FreezeTokensBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return freezeTokensBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc thawTokensBuilder} */\n  thaw(input: ThawTokensBuilderParams, options?: TransactionBuilderOptions) {\n    return thawTokensBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Delegate\n  // -----------------\n\n  /** {@inheritDoc approveTokenDelegateAuthorityBuilder} */\n  approveDelegateAuthority(\n    input: ApproveTokenDelegateAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return approveTokenDelegateAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc revokeTokenDelegateAuthorityBuilder} */\n  revokeDelegateAuthority(\n    input: RevokeTokenDelegateAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return revokeTokenDelegateAuthorityBuilder(this.metaplex, input, options);\n  }\n}\n","import type { Metaplex } from '@/Metaplex';\nimport { Pda, Program, PublicKey } from '@/types';\n\n/**\n * This client allows you to build PDAs related to the Token module.\n *\n * @see {@link TokenClient}\n * @group Module Pdas\n */\nexport class TokenPdasClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Finds the address of the Associated Token Account. */\n  associatedTokenAccount({\n    mint,\n    owner,\n    programs,\n  }: {\n    /** The address of the mint account. */\n    mint: PublicKey;\n    /** The address of the owner account. */\n    owner: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const tokenProgram = this.metaplex.programs().getToken(programs);\n    const associatedTokenProgram = this.metaplex\n      .programs()\n      .getAssociatedToken(programs);\n    return Pda.find(associatedTokenProgram.address, [\n      owner.toBuffer(),\n      tokenProgram.address.toBuffer(),\n      mint.toBuffer(),\n    ]);\n  }\n}\n","import type { PublicKey } from '@solana/web3.js';\nimport { toMintAccount } from '../accounts';\nimport { Mint, toMint } from '../models/Mint';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindMintByAddressOperation' as const;\n\n/**\n * Finds a mint account by its address.\n *\n * ```ts\n * const mint = await metaplex.tokens().findMintByAddress({ address });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findMintByAddressOperation =\n  useOperation<FindMintByAddressOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindMintByAddressOperation = Operation<\n  typeof Key,\n  FindMintByAddressInput,\n  Mint\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindMintByAddressInput = {\n  /** The address of the mint account. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findMintByAddressOperationHandler: OperationHandler<FindMintByAddressOperation> =\n  {\n    handle: async (\n      operation: FindMintByAddressOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const { commitment } = scope;\n      const { address } = operation.input;\n\n      const account = toMintAccount(\n        await metaplex.rpc().getAccount(address, commitment)\n      );\n\n      return toMint(account);\n    },\n  };\n","import type { PublicKey } from '@solana/web3.js';\nimport { toTokenAccount } from '../accounts';\nimport { Token, toToken } from '../models/Token';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenByAddressOperation' as const;\n\n/**\n * Finds a token account by its address.\n *\n * ```ts\n * const token = await metaplex.tokens().findTokenByAddress({ address });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findTokenByAddressOperation =\n  useOperation<FindTokenByAddressOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindTokenByAddressOperation = Operation<\n  typeof Key,\n  FindTokenByAddressInput,\n  Token\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindTokenByAddressInput = {\n  /** The address of the token account. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findTokenByAddressOperationHandler: OperationHandler<FindTokenByAddressOperation> =\n  {\n    handle: async (\n      operation: FindTokenByAddressOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<Token> => {\n      const { commitment } = scope;\n      const { address } = operation.input;\n\n      const account = toTokenAccount(\n        await metaplex.rpc().getAccount(address, commitment)\n      );\n\n      return toToken(account);\n    },\n  };\n","import type { PublicKey } from '@solana/web3.js';\nimport { toMintAccount, toTokenAccount } from '../accounts';\nimport { toMint } from '../models/Mint';\nimport { TokenWithMint, toTokenWithMint } from '../models/Token';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenWithMintByAddressOperation' as const;\n\n/**\n * Finds a token account and its associated mint account\n * by providing the token address.\n *\n * ```ts\n * const tokenWithMint = await metaplex.tokens().findTokenWithMintByAddress({ address });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findTokenWithMintByAddressOperation =\n  useOperation<FindTokenWithMintByAddressOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindTokenWithMintByAddressOperation = Operation<\n  typeof Key,\n  FindTokenWithMintByAddressInput,\n  TokenWithMint\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindTokenWithMintByAddressInput = {\n  /** The address of the token account. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findTokenWithMintByAddressOperationHandler: OperationHandler<FindTokenWithMintByAddressOperation> =\n  {\n    handle: async (\n      operation: FindTokenWithMintByAddressOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TokenWithMint> => {\n      const { commitment } = scope;\n      const { address } = operation.input;\n\n      const tokenAccount = toTokenAccount(\n        await metaplex.rpc().getAccount(address, commitment)\n      );\n\n      const mintAccount = toMintAccount(\n        await metaplex.rpc().getAccount(tokenAccount.data.mint, commitment)\n      );\n\n      return toTokenWithMint(tokenAccount, toMint(mintAccount));\n    },\n  };\n","import type { PublicKey } from '@solana/web3.js';\nimport { toMintAccount, toTokenAccount } from '../accounts';\nimport { TokenAndMintDoNotMatchError } from '../errors';\nimport { toMint } from '../models/Mint';\nimport { TokenWithMint, toTokenWithMint } from '../models/Token';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenWithMintByMintOperation' as const;\n\n/**\n * Finds a token account and its associated mint account\n * by providing the mint address and either:\n * - the token address or\n * - the address of the token's owner.\n *\n * ```ts\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: tokenAddress, type: \"token\" };\n *\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: ownerAddress, type: \"owner\" };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findTokenWithMintByMintOperation =\n  useOperation<FindTokenWithMintByMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindTokenWithMintByMintOperation = Operation<\n  typeof Key,\n  FindTokenWithMintByMintInput,\n  TokenWithMint\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindTokenWithMintByMintInput = {\n  /** The address of the mint account. */\n  mint: PublicKey;\n\n  /**\n   * The address of the token account or its owner,\n   * distinguished by the `addressType`` parameter.\n   */\n  address: PublicKey;\n\n  /**\n   * Determines whether the `address` parameter is the token address\n   * or the address of its owner.\n   */\n  addressType: 'owner' | 'token';\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findTokenWithMintByMintOperationHandler: OperationHandler<FindTokenWithMintByMintOperation> =\n  {\n    handle: async (\n      operation: FindTokenWithMintByMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TokenWithMint> => {\n      const { commitment, programs } = scope;\n      const { mint, address, addressType } = operation.input;\n      const tokenAddress =\n        addressType === 'owner'\n          ? metaplex.tokens().pdas().associatedTokenAccount({\n              mint,\n              owner: address,\n              programs,\n            })\n          : address;\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts([mint, tokenAddress], commitment);\n\n      const mintAccount = toMintAccount(accounts[0]);\n      const tokenAccount = toTokenAccount(accounts[1]);\n\n      if (!tokenAccount.data.mint.equals(mint)) {\n        throw new TokenAndMintDoNotMatchError(\n          tokenAddress,\n          tokenAccount.data.mint,\n          mint\n        );\n      }\n\n      return toTokenWithMint(tokenAccount, toMint(mintAccount));\n    },\n  };\n","import {\n  ApproveTokenDelegateAuthorityInput,\n  approveTokenDelegateAuthorityOperation,\n  CreateMintInput,\n  createMintOperation,\n  CreateTokenInput,\n  createTokenOperation,\n  CreateTokenWithMintInput,\n  createTokenWithMintOperation,\n  FindMintByAddressInput,\n  findMintByAddressOperation,\n  FindTokenByAddressInput,\n  findTokenByAddressOperation,\n  FindTokenWithMintByAddressInput,\n  findTokenWithMintByAddressOperation,\n  FindTokenWithMintByMintInput,\n  findTokenWithMintByMintOperation,\n  FreezeTokensInput,\n  freezeTokensOperation,\n  MintTokensInput,\n  mintTokensOperation,\n  RevokeTokenDelegateAuthorityInput,\n  revokeTokenDelegateAuthorityOperation,\n  SendTokensInput,\n  sendTokensOperation,\n  ThawTokensInput,\n  thawTokensOperation,\n} from './operations';\nimport { TokenBuildersClient } from './TokenBuildersClient';\nimport { TokenPdasClient } from './TokenPdasClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { OperationOptions } from '@/types';\n\n/**\n * This is a client for the Token module.\n *\n * It enables us to interact with the SPL Token program in order to\n * create, send, freeze, thaw, and mint tokens.\n *\n * You may access this client via the `tokens()` method of your `Metaplex` instance.\n *\n * ```ts\n * const tokenClient = metaplex.tokens();\n * ```\n *\n * @example\n * You can create a new mint account with an associated token account like so.\n * The owner of this token account will, by default, be the current identity\n * of the metaplex instance.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createTokenWithMint();\n * ```\n *\n * @group Modules\n */\nexport class TokenClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /**\n   * You may use the `builders()` client to access the\n   * underlying Transaction Builders of this module.\n   *\n   * ```ts\n   * const buildersClient = metaplex.tokens().builders();\n   * ```\n   */\n  builders() {\n    return new TokenBuildersClient(this.metaplex);\n  }\n\n  /**\n   * You may use the `pdas()` client to build PDAs related to this module.\n   *\n   * ```ts\n   * const pdasClient = metaplex.tokens().pdas();\n   * ```\n   */\n  pdas() {\n    return new TokenPdasClient(this.metaplex);\n  }\n\n  // -----------------\n  // Queries\n  // -----------------\n\n  /** {@inheritDoc findMintByAddressOperation} */\n  findMintByAddress(input: FindMintByAddressInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findMintByAddressOperation(input), options);\n  }\n\n  /** {@inheritDoc findTokenByAddressOperation} */\n  findTokenByAddress(\n    input: FindTokenByAddressInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findTokenByAddressOperation(input), options);\n  }\n\n  /** {@inheritDoc findTokenWithMintByAddressOperation} */\n  findTokenWithMintByAddress(\n    input: FindTokenWithMintByAddressInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findTokenWithMintByAddressOperation(input), options);\n  }\n\n  /** {@inheritDoc findTokenWithMintByMintOperation} */\n  findTokenWithMintByMint(\n    input: FindTokenWithMintByMintInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findTokenWithMintByMintOperation(input), options);\n  }\n\n  // -----------------\n  // Create\n  // -----------------\n\n  /** {@inheritDoc createMintOperation} */\n  createMint(input: CreateMintInput = {}, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(createMintOperation(input), options);\n  }\n\n  /**\n   * Create a new Token account from the provided input\n   * and returns the newly created `Token` model.\n   */\n  /** {@inheritDoc createTokenOperation} */\n  createToken(input: CreateTokenInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(createTokenOperation(input), options);\n  }\n\n  /** {@inheritDoc createTokenWithMintOperation} */\n  createTokenWithMint(\n    input: CreateTokenWithMintInput = {},\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(createTokenWithMintOperation(input), options);\n  }\n\n  // -----------------\n  // Update\n  // -----------------\n\n  /** {@inheritDoc mintTokensOperation} */\n  mint(input: MintTokensInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(mintTokensOperation(input), options);\n  }\n\n  /** {@inheritDoc sendTokensOperation} */\n  send(input: SendTokensInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(sendTokensOperation(input), options);\n  }\n\n  /** {@inheritDoc freezeTokensOperation} */\n  freeze(input: FreezeTokensInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(freezeTokensOperation(input), options);\n  }\n\n  /** {@inheritDoc thawTokensOperation} */\n  thaw(input: ThawTokensInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(thawTokensOperation(input), options);\n  }\n\n  // -----------------\n  // Delegate\n  // -----------------\n\n  /** {@inheritDoc approveTokenDelegateAuthorityOperation} */\n  approveDelegateAuthority(\n    input: ApproveTokenDelegateAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(approveTokenDelegateAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc revokeTokenDelegateAuthorityOperation} */\n  revokeDelegateAuthority(\n    input: RevokeTokenDelegateAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(revokeTokenDelegateAuthorityOperation(input), options);\n  }\n}\n","import { ProgramClient } from '../programModule';\nimport {\n  approveTokenDelegateAuthorityOperation,\n  approveTokenDelegateAuthorityOperationHandler,\n  createMintOperation,\n  createMintOperationHandler,\n  createTokenOperation,\n  createTokenOperationHandler,\n  createTokenWithMintOperation,\n  createTokenWithMintOperationHandler,\n  findMintByAddressOperation,\n  findMintByAddressOperationHandler,\n  findTokenByAddressOperation,\n  findTokenByAddressOperationHandler,\n  findTokenWithMintByAddressOperation,\n  findTokenWithMintByAddressOperationHandler,\n  findTokenWithMintByMintOperation,\n  findTokenWithMintByMintOperationHandler,\n  freezeTokensOperation,\n  freezeTokensOperationHandler,\n  mintTokensOperation,\n  mintTokensOperationHandler,\n  revokeTokenDelegateAuthorityOperation,\n  revokeTokenDelegateAuthorityOperationHandler,\n  sendTokensOperation,\n  sendTokensOperationHandler,\n  thawTokensOperation,\n  thawTokensOperationHandler,\n} from './operations';\nimport { associatedTokenProgram, tokenProgram } from './program';\nimport { TokenClient } from './TokenClient';\nimport type { MetaplexPlugin, Program } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n/**\n * @group Plugins\n */\n/** @group Plugins */\nexport const tokenModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    // Token Program.\n    metaplex.programs().register(tokenProgram);\n    metaplex.programs().getToken = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(tokenProgram.name, programs);\n    };\n\n    // Associated Token Program.\n    metaplex.programs().register(associatedTokenProgram);\n    metaplex.programs().getAssociatedToken = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(associatedTokenProgram.name, programs);\n    };\n\n    // Operations.\n    const op = metaplex.operations();\n    op.register(\n      approveTokenDelegateAuthorityOperation,\n      approveTokenDelegateAuthorityOperationHandler\n    );\n    op.register(createMintOperation, createMintOperationHandler);\n    op.register(createTokenOperation, createTokenOperationHandler);\n    op.register(\n      createTokenWithMintOperation,\n      createTokenWithMintOperationHandler\n    );\n    op.register(findMintByAddressOperation, findMintByAddressOperationHandler);\n    op.register(\n      findTokenByAddressOperation,\n      findTokenByAddressOperationHandler\n    );\n    op.register(\n      findTokenWithMintByAddressOperation,\n      findTokenWithMintByAddressOperationHandler\n    );\n    op.register(\n      findTokenWithMintByMintOperation,\n      findTokenWithMintByMintOperationHandler\n    );\n    op.register(freezeTokensOperation, freezeTokensOperationHandler);\n    op.register(mintTokensOperation, mintTokensOperationHandler);\n    op.register(\n      revokeTokenDelegateAuthorityOperation,\n      revokeTokenDelegateAuthorityOperationHandler\n    );\n    op.register(sendTokensOperation, sendTokensOperationHandler);\n    op.register(thawTokensOperation, thawTokensOperationHandler);\n\n    metaplex.tokens = function () {\n      return new TokenClient(this);\n    };\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    tokens(): TokenClient;\n  }\n}\n\ndeclare module '../programModule/ProgramClient' {\n  interface ProgramClient {\n    getToken(programs?: Program[]): Program;\n    getAssociatedToken(programs?: Program[]): Program;\n  }\n}\n","import {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from '@solana/spl-token';\nimport { Program } from '@/types';\n\n/** @group Programs */\nexport const tokenProgram: Program = {\n  name: 'TokenProgram',\n  address: TOKEN_PROGRAM_ID,\n};\n\n/** @group Programs */\nexport const associatedTokenProgram: Program = {\n  name: 'AssociatedTokenProgram',\n  address: ASSOCIATED_TOKEN_PROGRAM_ID,\n};\n","import type { Metaplex } from '@/Metaplex';\nimport {\n  addAmounts,\n  lamports,\n  multiplyAmount,\n  SolAmount,\n  subtractAmounts,\n} from '@/types';\n\nconst TRANSACTION_FEE = 5000;\n\n/**\n * @group Modules\n */\nexport class UtilsClient {\n  protected readonly metaplex: Metaplex;\n  protected cachedRentPerEmptyAccount: SolAmount | null = null;\n  protected cachedRentPerByte: SolAmount | null = null;\n\n  constructor(metaplex: Metaplex) {\n    this.metaplex = metaplex;\n  }\n\n  async estimate(\n    bytes: number,\n    numberOfAccounts = 1,\n    numberOfTransactions = 1,\n    useCache = true\n  ): Promise<SolAmount> {\n    const rent = await this.estimateRent(bytes, numberOfAccounts, useCache);\n    const transactionFees = this.estimateTransactionFee(numberOfTransactions);\n\n    return addAmounts(rent, transactionFees);\n  }\n\n  async estimateRent(\n    bytes: number,\n    numberOfAccounts = 1,\n    useCache = true\n  ): Promise<SolAmount> {\n    if (\n      !useCache ||\n      this.cachedRentPerEmptyAccount === null ||\n      this.cachedRentPerByte === null\n    ) {\n      const rentFor0Bytes = await this.metaplex.rpc().getRent(0);\n\n      // TODO(loris): Infer from header size in bytes.\n      const rentFor1Byte = await this.metaplex.rpc().getRent(1);\n      this.cachedRentPerEmptyAccount = rentFor0Bytes;\n      this.cachedRentPerByte = subtractAmounts(rentFor1Byte, rentFor0Bytes);\n    }\n\n    const rentForAccounts = multiplyAmount(\n      this.cachedRentPerEmptyAccount,\n      numberOfAccounts\n    );\n    const rentForBytes = multiplyAmount(this.cachedRentPerByte, bytes);\n\n    return addAmounts(rentForAccounts, rentForBytes);\n  }\n\n  estimateTransactionFee(numberOfTransactions = 1): SolAmount {\n    // TODO(loris): Improve with an RPC call to get the current transaction fee.\n    return lamports(numberOfTransactions * TRANSACTION_FEE);\n  }\n}\n","import { UtilsClient } from './UtilsClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const utilsModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const utilsClient = new UtilsClient(metaplex);\n    metaplex.utils = () => utilsClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    utils(): UtilsClient;\n  }\n}\n","import { PublicKey, Transaction } from '@solana/web3.js';\nimport { IdentityDriver } from '../identityModule';\nimport {\n  OperationNotSupportedByWalletAdapterError,\n  UninitializedWalletAdapterError,\n} from '@/errors';\n\nexport type WalletAdapter = {\n  publicKey: PublicKey | null;\n  signMessage?: (message: Uint8Array) => Promise<Uint8Array>;\n  signTransaction?: (transaction: Transaction) => Promise<Transaction>;\n  signAllTransactions?: (transactions: Transaction[]) => Promise<Transaction[]>;\n};\n\nexport class WalletAdapterIdentityDriver implements IdentityDriver {\n  public readonly walletAdapter: WalletAdapter;\n\n  constructor(walletAdapter: WalletAdapter) {\n    this.walletAdapter = walletAdapter;\n  }\n\n  get publicKey(): PublicKey {\n    if (!this.walletAdapter.publicKey) {\n      throw new UninitializedWalletAdapterError();\n    }\n\n    return this.walletAdapter.publicKey;\n  }\n\n  public async signMessage(message: Uint8Array): Promise<Uint8Array> {\n    if (this.walletAdapter.signMessage === undefined) {\n      throw new OperationNotSupportedByWalletAdapterError('signMessage');\n    }\n\n    return this.walletAdapter.signMessage(message);\n  }\n\n  public async signTransaction(transaction: Transaction): Promise<Transaction> {\n    if (this.walletAdapter.signTransaction === undefined) {\n      throw new OperationNotSupportedByWalletAdapterError('signTransaction');\n    }\n\n    return this.walletAdapter.signTransaction(transaction);\n  }\n\n  public async signAllTransactions(\n    transactions: Transaction[]\n  ): Promise<Transaction[]> {\n    if (this.walletAdapter.signAllTransactions === undefined) {\n      throw new OperationNotSupportedByWalletAdapterError(\n        'signAllTransactions'\n      );\n    }\n\n    return this.walletAdapter.signAllTransactions(transactions);\n  }\n}\n","import {\n  WalletAdapterIdentityDriver,\n  WalletAdapter,\n} from './WalletAdapterIdentityDriver';\nimport { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\nexport const walletAdapterIdentity = (\n  walletAdapter: WalletAdapter\n): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    metaplex\n      .identity()\n      .setDriver(new WalletAdapterIdentityDriver(walletAdapter));\n  },\n});\n"],"names":["mintAccountParser","name","deserialize","data","offset","span","MintLayout","getSpan","decoded","decode","fromArgs","NotYetImplementedError","toMintAccount","getAccountParsingFunction","getAccountParsingAndAssertingFunction","tokenAccountParser","AccountLayout","toTokenAccount","WRAPPED_SOL_MINT","PublicKey","GpaBuilder","TokenGpaBuilder","constructor","metaplex","programId","super","TOKEN_PROGRAM_ID","this","whereSize","ACCOUNT_SIZE","selectMint","slice","whereMint","mint","where","selectOwner","whereOwner","owner","selectAmount","whereAmount","amount","whereDoesntHaveDelegate","whereHasDelegate","whereDelegate","delegate","toMint","account","isWrappedSol","publicKey","equals","currency","symbol","decimals","namespace","model","address","mintAuthorityAddress","mintAuthorityOption","mintAuthority","freezeAuthorityAddress","freezeAuthorityOption","freezeAuthority","supply","toString","toToken","associatedTokenAddress","Pda","find","associatedTokenProgram","toBuffer","isAssociatedToken","mintAddress","ownerAddress","token","closeAuthorityAddress","closeAuthorityOption","closeAuthority","delegateAddress","delegateOption","delegateAmount","delegatedAmount","state","toTokenWithMint","tokenAccount","mintModel","basisPoints","Key","createMintOperation","useOperation","createMintOperationHandler","handle","operation","scope","builder","createMintBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","tokens","findMintByAddress","mintSigner","async","params","options","programs","payer","rpc","getDefaultFeePayer","Keypair","generate","identity","tokenProgram","getToken","TransactionBuilder","make","setFeePayer","setContext","add","system","builders","createAccount","newAccount","space","MINT_SIZE","program","instructionKey","createAccountInstructionKey","instruction","createInitializeMintInstruction","signers","key","initializeMintInstructionKey","createTokenOperation","createTokenOperationHandler","createTokenBuilder","findTokenByAddress","tokenAddress","getAssociatedToken","undefined","pdas","associatedTokenAccount","createAssociatedTokenAccountInstruction","createAssociatedTokenAccountInstructionKey","createInitializeAccountInstruction","initializeTokenInstructionKey","createTokenIfMissingBuilder","tokenExists","tokenVariable","destination","destinationAddress","toPublicKey","isSigner","ExpectedSignerError","createToken","TokenError","MetaplexError","message","cause","_defineProperty","MintAuthorityMustBeSignerToMintInitialSupplyError","TokenAndMintDoNotMatchError","tokenMint","createTokenWithMintOperation","createTokenWithMintOperationHandler","createTokenWithMintBuilder","findTokenWithMintByMint","addressType","initialSupply","createMint","createMintAccountInstructionKey","createTokenAccountInstructionKey","getContext","mintTokensInstructionKey","mintTokensOperation","mintTokensOperationHandler","toOwner","destinationAccountExists","accountExists","mintTokensBuilder","toTokenExists","multiSigners","mintAuthorityPublicKey","createTokenIfMissing","createMintToInstruction","toNumber","sendTokensOperation","sendTokensOperationHandler","sendTokensBuilder","fromOwner","fromToken","fromMultiSigners","delegateAuthority","fromOwnerPublicKey","filter","source","createTransferInstruction","transferTokensInstructionKey","freezeTokensOperation","freezeTokensOperationHandler","freezeTokensBuilder","tokenOwner","authorityPublicKey","tokenAddressOrAta","createFreezeAccountInstruction","thawTokensOperation","thawTokensOperationHandler","thawTokensBuilder","createThawAccountInstruction","approveTokenDelegateAuthorityOperation","approveTokenDelegateAuthorityOperationHandler","approveTokenDelegateAuthorityBuilder","ownerPublicKey","createApproveInstruction","revokeTokenDelegateAuthorityOperation","revokeTokenDelegateAuthorityOperationHandler","revokeTokenDelegateAuthorityBuilder","createRevokeInstruction","TokenBuildersClient","createTokenWithMint","send","freeze","thaw","approveDelegateAuthority","revokeDelegateAuthority","TokenPdasClient","findMintByAddressOperation","findMintByAddressOperationHandler","commitment","getAccount","findTokenByAddressOperation","findTokenByAddressOperationHandler","findTokenWithMintByAddressOperation","findTokenWithMintByAddressOperationHandler","mintAccount","findTokenWithMintByMintOperation","findTokenWithMintByMintOperationHandler","accounts","getMultipleAccounts","TokenClient","operations","execute","findTokenWithMintByAddress","tokenModule","install","register","get","op","ASSOCIATED_TOKEN_PROGRAM_ID","TRANSACTION_FEE","UtilsClient","estimate","bytes","numberOfAccounts","numberOfTransactions","useCache","rent","estimateRent","transactionFees","estimateTransactionFee","addAmounts","cachedRentPerEmptyAccount","cachedRentPerByte","rentFor0Bytes","getRent","rentFor1Byte","subtractAmounts","rentForAccounts","multiplyAmount","rentForBytes","lamports","utilsModule","utilsClient","utils","WalletAdapterIdentityDriver","walletAdapter","UninitializedWalletAdapterError","signMessage","OperationNotSupportedByWalletAdapterError","signTransaction","transaction","signAllTransactions","transactions","walletAdapterIdentity","setDriver"],"sourceRoot":""}