"use strict";(self["webpackChunkapp"]=self["webpackChunkapp"]||[]).push([[7949],{63558:function(e,t,n){
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
n(44114),n(16573),n(78100),n(77936),n(37467),n(44732),n(79577),n(98992),n(8872),Object.defineProperty(t,"__esModule",{value:!0}),t.s16=t.s8=t.nu64be=t.u48be=t.u40be=t.u32be=t.u24be=t.u16be=t.nu64=t.u48=t.u40=t.u32=t.u24=t.u16=t.u8=t.offset=t.greedy=t.Constant=t.UTF8=t.CString=t.Blob=t.Boolean=t.BitField=t.BitStructure=t.VariantLayout=t.Union=t.UnionLayoutDiscriminator=t.UnionDiscriminator=t.Structure=t.Sequence=t.DoubleBE=t.Double=t.FloatBE=t.Float=t.NearInt64BE=t.NearInt64=t.NearUInt64BE=t.NearUInt64=t.IntBE=t.Int=t.UIntBE=t.UInt=t.OffsetLayout=t.GreedyCount=t.ExternalLayout=t.bindConstructorLayout=t.nameWithProperty=t.Layout=t.uint8ArrayToBuffer=t.checkUint8Array=void 0,t.constant=t.utf8=t.cstr=t.blob=t.unionLayoutDiscriminator=t.union=t.seq=t.bits=t.struct=t.f64be=t.f64=t.f32be=t.f32=t.ns64be=t.s48be=t.s40be=t.s32be=t.s24be=t.s16be=t.ns64=t.s48=t.s40=t.s32=t.s24=void 0;const r=n(90712);function o(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function s(e){return o(e),r.Buffer.from(e.buffer,e.byteOffset,e.length)}t.checkUint8Array=o,t.uint8ArrayToBuffer=s;class i{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function a(e,t){return t.property?e+"["+t.property+"]":e}function c(e,t){if("function"!==typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof i))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,n){return t.encode(this,e,n)},writable:!0}),Object.defineProperty(e,"decode",{value(e,n){return t.decode(e,n)},writable:!0})}t.Layout=i,t.nameWithProperty=a,t.bindConstructorLayout=c;class u extends i{isCount(){throw new Error("ExternalLayout is abstract")}}t.ExternalLayout=u;class d extends u{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){o(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}t.GreedyCount=d;class f extends u{constructor(e,t=0,n){if(!(e instanceof i))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof p||this.layout instanceof l}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}t.OffsetLayout=f;class p extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readUIntLE(t,this.span)}encode(e,t,n=0){return s(t).writeUIntLE(e,n,this.span),this.span}}t.UInt=p;class l extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readUIntBE(t,this.span)}encode(e,t,n=0){return s(t).writeUIntBE(e,n,this.span),this.span}}t.UIntBE=l;class h extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readIntLE(t,this.span)}encode(e,t,n=0){return s(t).writeIntLE(e,n,this.span),this.span}}t.Int=h;class y extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return s(e).readIntBE(t,this.span)}encode(e,t,n=0){return s(t).writeIntBE(e,n,this.span),this.span}}t.IntBE=y;const w=Math.pow(2,32);function b(e){const t=Math.floor(e/w),n=e-t*w;return{hi32:t,lo32:n}}function g(e,t){return e*w+t}class m extends i{constructor(e){super(8,e)}decode(e,t=0){const n=s(e),r=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return g(o,r)}encode(e,t,n=0){const r=b(e),o=s(t);return o.writeUInt32LE(r.lo32,n),o.writeUInt32LE(r.hi32,n+4),8}}t.NearUInt64=m;class E extends i{constructor(e){super(8,e)}decode(e,t=0){const n=s(e),r=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return g(r,o)}encode(e,t,n=0){const r=b(e),o=s(t);return o.writeUInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}t.NearUInt64BE=E;class x extends i{constructor(e){super(8,e)}decode(e,t=0){const n=s(e),r=n.readUInt32LE(t),o=n.readInt32LE(t+4);return g(o,r)}encode(e,t,n=0){const r=b(e),o=s(t);return o.writeUInt32LE(r.lo32,n),o.writeInt32LE(r.hi32,n+4),8}}t.NearInt64=x;class v extends i{constructor(e){super(8,e)}decode(e,t=0){const n=s(e),r=n.readInt32BE(t),o=n.readUInt32BE(t+4);return g(r,o)}encode(e,t,n=0){const r=b(e),o=s(t);return o.writeInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}t.NearInt64BE=v;class S extends i{constructor(e){super(4,e)}decode(e,t=0){return s(e).readFloatLE(t)}encode(e,t,n=0){return s(t).writeFloatLE(e,n),4}}t.Float=S;class B extends i{constructor(e){super(4,e)}decode(e,t=0){return s(e).readFloatBE(t)}encode(e,t,n=0){return s(t).writeFloatBE(e,n),4}}t.FloatBE=B;class I extends i{constructor(e){super(8,e)}decode(e,t=0){return s(e).readDoubleLE(t)}encode(e,t,n=0){return s(t).writeDoubleLE(e,n),8}}t.Double=I;class L extends i{constructor(e){super(8,e)}decode(e,t=0){return s(e).readDoubleBE(t)}encode(e,t,n=0){return s(t).writeDoubleBE(e,n),8}}t.DoubleBE=L;class D extends i{constructor(e,t,n){if(!(e instanceof i))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof u&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof u)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof u&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let o=0;while(o<r)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let r=0,o=this.count;o instanceof u&&(o=o.decode(e,t));while(r<o)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){const r=this.elementLayout,o=e.reduce(((e,o)=>e+r.encode(o,t,n+e)),0);return this.count instanceof u&&this.count.encode(e.length,t,n),o}}t.Sequence=D;class U extends i{constructor(e,t,n){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof i),!0))throw new TypeError("fields must be array of Layout instances");"boolean"===typeof t&&void 0===n&&(n=t,t=void 0);for(const s of e)if(0>s.span&&void 0===s.property)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(o){}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce(((n,r)=>{const o=r.getSpan(e,t);return t+=o,n+o}),0)}catch(r){throw new RangeError("indeterminate span")}return n}decode(e,t=0){o(e);const n=this.makeDestinationObject();for(const r of this.fields)if(void 0!==r.property&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const r=n;let o=0,s=0;for(const i of this.fields){let r=i.span;if(s=0<r?r:0,void 0!==i.property){const o=e[i.property];void 0!==o&&(s=i.encode(o,t,n),0>r&&(r=i.getSpan(t,n)))}o=n,n+=r}return o+s-r}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)void 0!==n.property&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if("string"!==typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!==typeof e)throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}t.Structure=U;class O{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}t.UnionDiscriminator=O;class j extends O{constructor(e,t){if(!(e instanceof u&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}t.UnionLayoutDiscriminator=j;class _ extends i{constructor(e,t,n){let r;if(e instanceof p||e instanceof l)r=new j(new f(e));else if(e instanceof u&&e.isCount())r=new j(e);else{if(!(e instanceof O))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");r=e}if(void 0===t&&(t=null),!(null===t||t instanceof i))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof p||e instanceof l)&&(o+=r.layout.span)),super(o,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof p||e instanceof l,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const r=this.discriminator,o=r.decode(e,t),s=this.registry[o];if(void 0===s){const s=this.defaultLayout;let i=0;this.usesPrefixDiscriminator&&(i=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[s.property]=s.decode(e,t+i)}else n=s.decode(e,t);return n}encode(e,t,n=0){const r=this.getSourceVariant(e);if(void 0===r){const r=this.discriminator,o=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=r.layout.span),r.encode(e[r.property],t,n),s+o.encode(e[o.property],t,n+s)}return r.encode(e,t,n)}addVariant(e,t,n){const r=new k(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return n=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[n]}}t.Union=_;class k extends i{constructor(e,t,n,r){if(!(e instanceof _))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"===typeof n&&void 0===r&&(r=n,n=null),n){if(!(n instanceof i))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!==typeof r)throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),o+=this.layout.getSpan(t,n+r),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function P(e){return 0>e&&(e+=4294967296),e}t.VariantLayout=k;class T extends i{constructor(e,t,n){if(!(e instanceof p||e instanceof l))throw new TypeError("word must be a UInt or UIntBE layout");if("string"===typeof t&&void 0===n&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(e){return r=P(e),this},this._packedGetValue=function(){return r}}decode(e,t=0){const n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(const o of this.fields)void 0!==o.property&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const r=this.word.decode(t,n);this._packedSetValue(r);for(const o of this.fields)if(void 0!==o.property){const t=e[o.property];void 0!==t&&o.encode(t)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new z(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new A(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!==typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}t.BitStructure=T;class z{constructor(e,t,n){if(!(e instanceof T))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const r=8*e.span,o=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+o>r)throw new Error("bits too long for span remainder ("+(r-o)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=r-o-t),this.wordMask=P(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue(),r=P(n&this.wordMask),o=r>>>this.start;return o}encode(e){if("number"!==typeof e||!Number.isInteger(e)||e!==P(e&this.valueMask))throw new TypeError(a("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=P(e<<this.start);this.container._packedSetValue(P(t&~this.wordMask)|n)}}t.BitField=z;class A extends z{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"===typeof e&&(e=+e),super.encode(e)}}t.Boolean=A;class C extends i{constructor(e,t){if(!(e instanceof u&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof u||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),s(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof u&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(a("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");const o=s(e);return s(t).write(o.toString("hex"),n,r,"hex"),this.length instanceof u&&this.length.encode(r,t,n),r}}t.Blob=C;class V extends i{constructor(e){super(-1,e)}getSpan(e,t=0){o(e);let n=t;while(n<e.length&&0!==e[n])n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return s(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){"string"!==typeof e&&(e=String(e));const o=r.Buffer.from(e,"utf8"),i=o.length;if(n+i>t.length)throw new RangeError("encoding overruns Buffer");const a=s(t);return o.copy(a,n),a[n+i]=0,i+1}}t.CString=V;class M extends i{constructor(e,t){if("string"===typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return o(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return s(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){"string"!==typeof e&&(e=String(e));const o=r.Buffer.from(e,"utf8"),i=o.length;if(0<=this.maxSpan&&this.maxSpan<i)throw new RangeError("text length exceeds maxSpan");if(n+i>t.length)throw new RangeError("encoding overruns Buffer");return o.copy(s(t),n),i}}t.UTF8=M;class F extends i{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}t.Constant=F,t.greedy=(e,t)=>new d(e,t),t.offset=(e,t,n)=>new f(e,t,n),t.u8=e=>new p(1,e),t.u16=e=>new p(2,e),t.u24=e=>new p(3,e),t.u32=e=>new p(4,e),t.u40=e=>new p(5,e),t.u48=e=>new p(6,e),t.nu64=e=>new m(e),t.u16be=e=>new l(2,e),t.u24be=e=>new l(3,e),t.u32be=e=>new l(4,e),t.u40be=e=>new l(5,e),t.u48be=e=>new l(6,e),t.nu64be=e=>new E(e),t.s8=e=>new h(1,e),t.s16=e=>new h(2,e),t.s24=e=>new h(3,e),t.s32=e=>new h(4,e),t.s40=e=>new h(5,e),t.s48=e=>new h(6,e),t.ns64=e=>new x(e),t.s16be=e=>new y(2,e),t.s24be=e=>new y(3,e),t.s32be=e=>new y(4,e),t.s40be=e=>new y(5,e),t.s48be=e=>new y(6,e),t.ns64be=e=>new v(e),t.f32=e=>new S(e),t.f32be=e=>new B(e),t.f64=e=>new I(e),t.f64be=e=>new L(e),t.struct=(e,t,n)=>new U(e,t,n),t.bits=(e,t,n)=>new T(e,t,n),t.seq=(e,t,n)=>new D(e,t,n),t.union=(e,t,n)=>new _(e,t,n),t.unionLayoutDiscriminator=(e,t)=>new j(e,t),t.blob=(e,t)=>new C(e,t),t.cstr=e=>new V(e),t.utf8=(e,t)=>new M(e,t),t.constant=(e,t)=>new F(e,t)},31743:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.encodeDecode=void 0;const n=e=>{const t=e.decode.bind(e),n=e.encode.bind(e);return{decode:t,encode:n}};t.encodeDecode=n},77605:function(e,t,n){var r=n(90712)["Buffer"];Object.defineProperty(t,"__esModule",{value:!0}),t.u256be=t.u256=t.u192be=t.u192=t.u128be=t.u128=t.u64be=t.u64=t.bigIntBE=t.bigInt=void 0;const o=n(63558),s=n(93203),i=n(31743),a=e=>t=>{const n=(0,o.blob)(e,t),{encode:a,decode:c}=(0,i.encodeDecode)(n),u=n;return u.decode=(e,t)=>{const n=c(e,t);return(0,s.toBigIntLE)(r.from(n))},u.encode=(t,n,r)=>{const o=(0,s.toBufferLE)(t,e);return a(o,n,r)},u};t.bigInt=a;const c=e=>t=>{const n=(0,o.blob)(e,t),{encode:a,decode:c}=(0,i.encodeDecode)(n),u=n;return u.decode=(e,t)=>{const n=c(e,t);return(0,s.toBigIntBE)(r.from(n))},u.encode=(t,n,r)=>{const o=(0,s.toBufferBE)(t,e);return a(o,n,r)},u};t.bigIntBE=c,t.u64=(0,t.bigInt)(8),t.u64be=(0,t.bigIntBE)(8),t.u128=(0,t.bigInt)(16),t.u128be=(0,t.bigIntBE)(16),t.u192=(0,t.bigInt)(24),t.u192be=(0,t.bigIntBE)(24),t.u256=(0,t.bigInt)(32),t.u256be=(0,t.bigIntBE)(32)},42155:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decimal=t.WAD=void 0;const o=r(n(28577)),s=n(31743),i=n(77605);t.WAD=new o.default("1e+18");const a=e=>{const n=(0,i.u128)(e),{encode:r,decode:a}=(0,s.encodeDecode)(n),c=n;return c.decode=(e,n)=>{const r=a(e,n).toString();return new o.default(r).div(t.WAD)},c.encode=(e,n,o)=>{const s=BigInt(e.times(t.WAD).integerValue().toString());return r(s,n,o)},c};t.decimal=a},77280:function(e,t,n){var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),o(n(31743),t),o(n(77605),t),o(n(42155),t),o(n(51933),t),o(n(76977),t)},51933:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.bool=void 0;const r=n(63558),o=n(31743),s=e=>{const t=(0,r.u8)(e),{encode:n,decode:s}=(0,o.encodeDecode)(t),i=t;return i.decode=(e,t)=>{const n=s(e,t);return!!n},i.encode=(e,t,r)=>{const o=Number(e);return n(o,t,r)},i};t.bool=s},76977:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.publicKey=void 0;const r=n(63558),o=n(75290),s=n(31743),i=e=>{const t=(0,r.blob)(32,e),{encode:n,decode:i}=(0,s.encodeDecode)(t),a=t;return a.decode=(e,t)=>{const n=i(e,t);return new o.PublicKey(n)},a.encode=(e,t,r)=>{const o=e.toBuffer();return n(o,t,r)},a};t.publicKey=i},53076:function(e,t,n){n.d(t,{lc:function(){return f},jE:function(){return l},_l:function(){return u}});var r=n(63558),o=n(93203);const s=e=>{const t=e.decode.bind(e),n=e.encode.bind(e);return{decode:t,encode:n}};var i=n(90712)["Buffer"];const a=e=>t=>{const n=(0,r.blob)(e,t),{encode:a,decode:c}=s(n),u=n;return u.decode=(e,t)=>{const n=c(e,t);return(0,o.toBigIntLE)(i.from(n))},u.encode=(t,n,r)=>{const s=(0,o.toBufferLE)(t,e);return a(s,n,r)},u},c=e=>t=>{const n=(0,r.blob)(e,t),{encode:a,decode:c}=s(n),u=n;return u.decode=(e,t)=>{const n=c(e,t);return(0,o.toBigIntBE)(i.from(n))},u.encode=(t,n,r)=>{const s=(0,o.toBufferBE)(t,e);return a(s,n,r)},u},u=a(8);c(8),a(16),c(16),a(24),c(24),a(32),c(32);var d=n(74013);new d.A("1e+18");const f=e=>{const t=(0,r.u8)(e),{encode:n,decode:o}=s(t),i=t;return i.decode=(e,t)=>{const n=o(e,t);return!!n},i.encode=(e,t,r)=>{const o=Number(e);return n(o,t,r)},i};var p=n(75290);const l=e=>{const t=(0,r.blob)(32,e),{encode:n,decode:o}=s(t),i=t;return i.decode=(e,t)=>{const n=o(e,t);return new p.PublicKey(n)},i.encode=(e,t,r)=>{const o=e.toBuffer();return n(o,t,r)},i}},80583:function(e,t,n){n.d(t,{g2:function(){return O},eC:function(){return D}});n(16573),n(78100),n(77936),n(37467),n(44732),n(79577);var r=n(91114),o=(n(44114),n(98992),n(3949),n(81454),n(64979),8078e3),s=8078001,i=8078004,a=8078005,c=8078006,u=8078011;function d(e){if(Array.isArray(e)){const t=e.map(d).join("%2C%20");return"%5B"+t+"%5D"}return"bigint"===typeof e?`${e}n`:encodeURIComponent(String(null!=e&&null===Object.getPrototypeOf(e)?{...e}:e))}function f([e,t]){return`${e}=${d(t)}`}function p(e){const t=Object.entries(e).map(f).join("&");return btoa(t)}function l(e,t={}){{let n=`Solana error #${e}; Decode this error by running \`npx @solana/errors decode -- ${e}`;return Object.keys(t).length&&(n+=` '${p(t)}'`),`${n}\``}}var h=class extends Error{constructor(...[e,t]){let n,o;if(t){const{cause:e,...r}=t;e&&(o={cause:e}),Object.keys(r).length>0&&(n=r)}const s=l(e,n);super(s,o),(0,r.A)(this,"cause",this.cause),(0,r.A)(this,"context",void 0),this.context={__code:e,...n},this.name="SolanaError"}};n(23215),n(54520),n(8872);function y(e,t){return"fixedSize"in t?t.fixedSize:t.getSizeFromValue(e)}function w(e){return Object.freeze({...e,encode:t=>{const n=new Uint8Array(y(t,e));return e.write(t,n,0),n}})}function b(e){return Object.freeze({...e,decode:(t,n=0)=>e.read(t,n)[0]})}function g(e){return"fixedSize"in e&&"number"===typeof e.fixedSize}function m(e,t){if(g(e)!==g(t))throw new h(i);if(g(e)&&g(t)&&e.fixedSize!==t.fixedSize)throw new h(a,{decoderFixedSize:t.fixedSize,encoderFixedSize:e.fixedSize});if(!g(e)&&!g(t)&&e.maxSize!==t.maxSize)throw new h(c,{decoderMaxSize:t.maxSize,encoderMaxSize:e.maxSize});return{...t,...e,decode:t.decode,encode:e.encode,read:t.read,write:e.write}}function E(e,t,n=0){if(t.length-n<=0)throw new h(o,{codecDescription:e})}function x(e,t,n,r=0){const o=n.length-r;if(o<t)throw new h(s,{bytesLength:o,codecDescription:e,expected:t})}function v(e,t,n,r){if(r<t||r>n)throw new h(u,{codecDescription:e,max:n,min:t,value:r})}function S(e){return 1!==e?.endian}function B(e){return w({fixedSize:e.size,write(t,n,r){e.range&&v(e.name,e.range[0],e.range[1],t);const o=new ArrayBuffer(e.size);return e.set(new DataView(o),t,S(e.config)),n.set(new Uint8Array(o),r),r+e.size}})}function I(e){return b({fixedSize:e.size,read(t,n=0){E(e.name,t,n),x(e.name,e.size,t,n);const r=new DataView(L(t,n,e.size));return[e.get(r,S(e.config)),n+e.size]}})}function L(e,t,n){const r=e.byteOffset+(t??0),o=n??e.byteLength;return e.buffer.slice(r,r+o)}var D=(e={})=>B({config:e,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),U=(e={})=>I({config:e,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),O=(e={})=>m(D(e),U(e))}}]);
//# sourceMappingURL=solana-vendors-72cd900f.73b32902.js.map