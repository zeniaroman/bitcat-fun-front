(self["webpackChunkapp"]=self["webpackChunkapp"]||[]).push([[7059],{51878:function(e,r,t){e.exports=t(80118)(t(586))},586:function(e,r,t){t(16573),t(78100),t(77936),t(37467),t(44732),t(79577),t(98992),t(41795);const n=t(96240).ec,i=new n("secp256k1"),o=i.curve,a=o.n.constructor;function c(e,r){let t=new a(r);if(t.cmp(o.p)>=0)return null;t=t.toRed(o.red);let n=t.redSqr().redIMul(t).redIAdd(o.b).redSqrt();3===e!==n.isOdd()&&(n=n.redNeg());const c=t.redSqr().redIMul(t);return n.redSqr().redISub(c.redIAdd(o.b)).isZero()?i.keyPair({pub:{x:t,y:n}}):null}function u(e,r,t){let n=new a(r),c=new a(t);if(n.cmp(o.p)>=0||c.cmp(o.p)>=0)return null;if(n=n.toRed(o.red),c=c.toRed(o.red),(6===e||7===e)&&c.isOdd()!==(7===e))return null;const u=n.redSqr().redIMul(n);return c.redSqr().redISub(u.redIAdd(o.b)).isZero()?i.keyPair({pub:{x:n,y:c}}):null}function s(e){const r=e[0];switch(r){case 2:case 3:return 33!==e.length?null:c(r,e.subarray(1,33));case 4:case 6:case 7:return 65!==e.length?null:u(r,e.subarray(1,33),e.subarray(33,65));default:return null}}function l(e,r){const t=r.encode(null,33===e.length);for(let n=0;n<e.length;++n)e[n]=t[n]}e.exports={contextRandomize(){return 0},privateKeyVerify(e){const r=new a(e);return r.cmp(o.n)<0&&!r.isZero()?0:1},privateKeyNegate(e){const r=new a(e),t=o.n.sub(r).umod(o.n).toArrayLike(Uint8Array,"be",32);return e.set(t),0},privateKeyTweakAdd(e,r){const t=new a(r);if(t.cmp(o.n)>=0)return 1;if(t.iadd(new a(e)),t.cmp(o.n)>=0&&t.isub(o.n),t.isZero())return 1;const n=t.toArrayLike(Uint8Array,"be",32);return e.set(n),0},privateKeyTweakMul(e,r){let t=new a(r);if(t.cmp(o.n)>=0||t.isZero())return 1;t.imul(new a(e)),t.cmp(o.n)>=0&&(t=t.umod(o.n));const n=t.toArrayLike(Uint8Array,"be",32);return e.set(n),0},publicKeyVerify(e){const r=s(e);return null===r?1:0},publicKeyCreate(e,r){const t=new a(r);if(t.cmp(o.n)>=0||t.isZero())return 1;const n=i.keyFromPrivate(r).getPublic();return l(e,n),0},publicKeyConvert(e,r){const t=s(r);if(null===t)return 1;const n=t.getPublic();return l(e,n),0},publicKeyNegate(e,r){const t=s(r);if(null===t)return 1;const n=t.getPublic();return n.y=n.y.redNeg(),l(e,n),0},publicKeyCombine(e,r){const t=new Array(r.length);for(let i=0;i<r.length;++i)if(t[i]=s(r[i]),null===t[i])return 1;let n=t[0].getPublic();for(let i=1;i<t.length;++i)n=n.add(t[i].pub);return n.isInfinity()?2:(l(e,n),0)},publicKeyTweakAdd(e,r,t){const n=s(r);if(null===n)return 1;if(t=new a(t),t.cmp(o.n)>=0)return 2;const i=n.getPublic().add(o.g.mul(t));return i.isInfinity()?2:(l(e,i),0)},publicKeyTweakMul(e,r,t){const n=s(r);if(null===n)return 1;if(t=new a(t),t.cmp(o.n)>=0||t.isZero())return 2;const i=n.getPublic().mul(t);return l(e,i),0},signatureNormalize(e){const r=new a(e.subarray(0,32)),t=new a(e.subarray(32,64));return r.cmp(o.n)>=0||t.cmp(o.n)>=0?1:(1===t.cmp(i.nh)&&e.set(o.n.sub(t).toArrayLike(Uint8Array,"be",32),32),0)},signatureExport(e,r){const t=r.subarray(0,32),n=r.subarray(32,64);if(new a(t).cmp(o.n)>=0)return 1;if(new a(n).cmp(o.n)>=0)return 1;const{output:i}=e;let c=i.subarray(4,37);c[0]=0,c.set(t,1);let u=33,s=0;for(;u>1&&0===c[s]&&!(128&c[s+1]);--u,++s);if(c=c.subarray(s),128&c[0])return 1;if(u>1&&0===c[0]&&!(128&c[1]))return 1;let l=i.subarray(39,72);l[0]=0,l.set(n,1);let w=33,y=0;for(;w>1&&0===l[y]&&!(128&l[y+1]);--w,++y);return l=l.subarray(y),128&l[0]||w>1&&0===l[0]&&!(128&l[1])?1:(e.outputlen=6+u+w,i[0]=48,i[1]=e.outputlen-2,i[2]=2,i[3]=c.length,i.set(c,4),i[4+u]=2,i[5+u]=l.length,i.set(l,6+u),0)},signatureImport(e,r){if(r.length<8)return 1;if(r.length>72)return 1;if(48!==r[0])return 1;if(r[1]!==r.length-2)return 1;if(2!==r[2])return 1;const t=r[3];if(0===t)return 1;if(5+t>=r.length)return 1;if(2!==r[4+t])return 1;const n=r[5+t];if(0===n)return 1;if(6+t+n!==r.length)return 1;if(128&r[4])return 1;if(t>1&&0===r[4]&&!(128&r[5]))return 1;if(128&r[t+6])return 1;if(n>1&&0===r[t+6]&&!(128&r[t+7]))return 1;let i=r.subarray(4,4+t);if(33===i.length&&0===i[0]&&(i=i.subarray(1)),i.length>32)return 1;let c=r.subarray(6+t);if(33===c.length&&0===c[0]&&(c=c.slice(1)),c.length>32)throw new Error("S length is too long");let u=new a(i);u.cmp(o.n)>=0&&(u=new a(0));let s=new a(r.subarray(6+t));return s.cmp(o.n)>=0&&(s=new a(0)),e.set(u.toArrayLike(Uint8Array,"be",32),0),e.set(s.toArrayLike(Uint8Array,"be",32),32),0},ecdsaSign(e,r,t,n,c){if(c){const e=c;c=i=>{const o=e(r,t,null,n,i),c=o instanceof Uint8Array&&32===o.length;if(!c)throw new Error("This is the way");return new a(o)}}const u=new a(t);if(u.cmp(o.n)>=0||u.isZero())return 1;let s;try{s=i.sign(r,t,{canonical:!0,k:c,pers:n})}catch(l){return 1}return e.signature.set(s.r.toArrayLike(Uint8Array,"be",32),0),e.signature.set(s.s.toArrayLike(Uint8Array,"be",32),32),e.recid=s.recoveryParam,0},ecdsaVerify(e,r,t){const n={r:e.subarray(0,32),s:e.subarray(32,64)},c=new a(n.r),u=new a(n.s);if(c.cmp(o.n)>=0||u.cmp(o.n)>=0)return 1;if(1===u.cmp(i.nh)||c.isZero()||u.isZero())return 3;const l=s(t);if(null===l)return 2;const w=l.getPublic(),y=i.verify(r,n,w);return y?0:3},ecdsaRecover(e,r,t,n){const c={r:r.slice(0,32),s:r.slice(32,64)},u=new a(c.r),s=new a(c.s);if(u.cmp(o.n)>=0||s.cmp(o.n)>=0)return 1;if(u.isZero()||s.isZero())return 2;let w;try{w=i.recoverPubKey(n,c,t)}catch(y){return 2}return l(e,w),0},ecdh(e,r,t,n,c,u,l){const w=s(r);if(null===w)return 1;const y=new a(t);if(y.cmp(o.n)>=0||y.isZero())return 2;const p=w.getPublic().mul(y);if(void 0===c){const r=p.encode(null,!0),t=i.hash().update(r).digest();for(let n=0;n<32;++n)e[n]=t[n]}else{u||(u=new Uint8Array(32));const r=p.getX().toArray("be",32);for(let e=0;e<32;++e)u[e]=r[e];l||(l=new Uint8Array(32));const t=p.getY().toArray("be",32);for(let e=0;e<32;++e)l[e]=t[e];const i=c(u,l,n),o=i instanceof Uint8Array&&i.length===e.length;if(!o)return 2;e.set(i)}return 0}}},80118:function(e,r,t){t(16573),t(78100),t(77936),t(37467),t(44732),t(79577);const n={IMPOSSIBLE_CASE:"Impossible case. Please create issue.",TWEAK_ADD:"The tweak was out of range or the resulted private key is invalid",TWEAK_MUL:"The tweak was out of range or equal to zero",CONTEXT_RANDOMIZE_UNKNOW:"Unknow error on context randomization",SECKEY_INVALID:"Private Key is invalid",PUBKEY_PARSE:"Public Key could not be parsed",PUBKEY_SERIALIZE:"Public Key serialization error",PUBKEY_COMBINE:"The sum of the public keys is not valid",SIG_PARSE:"Signature could not be parsed",SIGN:"The nonce generation function failed, or the private key was invalid",RECOVER:"Public key could not be recover",ECDH:"Scalar was invalid (zero or overflow)"};function i(e,r){if(!e)throw new Error(r)}function o(e,r,t){if(i(r instanceof Uint8Array,`Expected ${e} to be an Uint8Array`),void 0!==t)if(Array.isArray(t)){const n=t.join(", "),o=`Expected ${e} to be an Uint8Array with length [${n}]`;i(t.includes(r.length),o)}else{const n=`Expected ${e} to be an Uint8Array with length ${t}`;i(r.length===t,n)}}function a(e){i("Boolean"===u(e),"Expected compressed to be a Boolean")}function c(e=e=>new Uint8Array(e),r){return"function"===typeof e&&(e=e(r)),o("output",e,r),e}function u(e){return Object.prototype.toString.call(e).slice(8,-1)}e.exports=e=>({contextRandomize(r){switch(i(null===r||r instanceof Uint8Array,"Expected seed to be an Uint8Array or null"),null!==r&&o("seed",r,32),e.contextRandomize(r)){case 1:throw new Error(n.CONTEXT_RANDOMIZE_UNKNOW)}},privateKeyVerify(r){return o("private key",r,32),0===e.privateKeyVerify(r)},privateKeyNegate(r){switch(o("private key",r,32),e.privateKeyNegate(r)){case 0:return r;case 1:throw new Error(n.IMPOSSIBLE_CASE)}},privateKeyTweakAdd(r,t){switch(o("private key",r,32),o("tweak",t,32),e.privateKeyTweakAdd(r,t)){case 0:return r;case 1:throw new Error(n.TWEAK_ADD)}},privateKeyTweakMul(r,t){switch(o("private key",r,32),o("tweak",t,32),e.privateKeyTweakMul(r,t)){case 0:return r;case 1:throw new Error(n.TWEAK_MUL)}},publicKeyVerify(r){return o("public key",r,[33,65]),0===e.publicKeyVerify(r)},publicKeyCreate(r,t=!0,i){switch(o("private key",r,32),a(t),i=c(i,t?33:65),e.publicKeyCreate(i,r)){case 0:return i;case 1:throw new Error(n.SECKEY_INVALID);case 2:throw new Error(n.PUBKEY_SERIALIZE)}},publicKeyConvert(r,t=!0,i){switch(o("public key",r,[33,65]),a(t),i=c(i,t?33:65),e.publicKeyConvert(i,r)){case 0:return i;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.PUBKEY_SERIALIZE)}},publicKeyNegate(r,t=!0,i){switch(o("public key",r,[33,65]),a(t),i=c(i,t?33:65),e.publicKeyNegate(i,r)){case 0:return i;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.IMPOSSIBLE_CASE);case 3:throw new Error(n.PUBKEY_SERIALIZE)}},publicKeyCombine(r,t=!0,u){i(Array.isArray(r),"Expected public keys to be an Array"),i(r.length>0,"Expected public keys array will have more than zero items");for(const e of r)o("public key",e,[33,65]);switch(a(t),u=c(u,t?33:65),e.publicKeyCombine(u,r)){case 0:return u;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.PUBKEY_COMBINE);case 3:throw new Error(n.PUBKEY_SERIALIZE)}},publicKeyTweakAdd(r,t,i=!0,u){switch(o("public key",r,[33,65]),o("tweak",t,32),a(i),u=c(u,i?33:65),e.publicKeyTweakAdd(u,r,t)){case 0:return u;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.TWEAK_ADD)}},publicKeyTweakMul(r,t,i=!0,u){switch(o("public key",r,[33,65]),o("tweak",t,32),a(i),u=c(u,i?33:65),e.publicKeyTweakMul(u,r,t)){case 0:return u;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.TWEAK_MUL)}},signatureNormalize(r){switch(o("signature",r,64),e.signatureNormalize(r)){case 0:return r;case 1:throw new Error(n.SIG_PARSE)}},signatureExport(r,t){o("signature",r,64),t=c(t,72);const i={output:t,outputlen:72};switch(e.signatureExport(i,r)){case 0:return t.slice(0,i.outputlen);case 1:throw new Error(n.SIG_PARSE);case 2:throw new Error(n.IMPOSSIBLE_CASE)}},signatureImport(r,t){switch(o("signature",r),t=c(t,64),e.signatureImport(t,r)){case 0:return t;case 1:throw new Error(n.SIG_PARSE);case 2:throw new Error(n.IMPOSSIBLE_CASE)}},ecdsaSign(r,t,a={},s){o("message",r,32),o("private key",t,32),i("Object"===u(a),"Expected options to be an Object"),void 0!==a.data&&o("options.data",a.data),void 0!==a.noncefn&&i("Function"===u(a.noncefn),"Expected options.noncefn to be a Function"),s=c(s,64);const l={signature:s,recid:null};switch(e.ecdsaSign(l,r,t,a.data,a.noncefn)){case 0:return l;case 1:throw new Error(n.SIGN);case 2:throw new Error(n.IMPOSSIBLE_CASE)}},ecdsaVerify(r,t,i){switch(o("signature",r,64),o("message",t,32),o("public key",i,[33,65]),e.ecdsaVerify(r,t,i)){case 0:return!0;case 3:return!1;case 1:throw new Error(n.SIG_PARSE);case 2:throw new Error(n.PUBKEY_PARSE)}},ecdsaRecover(r,t,s,l=!0,w){switch(o("signature",r,64),i("Number"===u(t)&&t>=0&&t<=3,"Expected recovery id to be a Number within interval [0, 3]"),o("message",s,32),a(l),w=c(w,l?33:65),e.ecdsaRecover(w,r,t,s)){case 0:return w;case 1:throw new Error(n.SIG_PARSE);case 2:throw new Error(n.RECOVER);case 3:throw new Error(n.IMPOSSIBLE_CASE)}},ecdh(r,t,a={},s){switch(o("public key",r,[33,65]),o("private key",t,32),i("Object"===u(a),"Expected options to be an Object"),void 0!==a.data&&o("options.data",a.data),void 0!==a.hashfn?(i("Function"===u(a.hashfn),"Expected options.hashfn to be a Function"),void 0!==a.xbuf&&o("options.xbuf",a.xbuf,32),void 0!==a.ybuf&&o("options.ybuf",a.ybuf,32),o("output",s)):s=c(s,32),e.ecdh(s,r,t,a.data,a.hashfn,a.xbuf,a.ybuf)){case 0:return s;case 1:throw new Error(n.PUBKEY_PARSE);case 2:throw new Error(n.ECDH)}}})}}]);
//# sourceMappingURL=vendor.secp256k1.552dddbd.js.map