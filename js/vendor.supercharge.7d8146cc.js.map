{"version":3,"file":"js/vendor.supercharge.7d8146cc.js","mappings":"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","sources":["webpack://app/./node_modules/@supercharge/promise-pool/dist/contracts.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/index.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/promise-pool-error.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/promise-pool-executor.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/promise-pool.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/return-value.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/stop-the-promise-pool-error.js","webpack://app/./node_modules/@supercharge/promise-pool/dist/validation-error.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","'use strict';\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst promise_pool_1 = require(\"./promise-pool\");\nexports.default = promise_pool_1.PromisePool;\n__exportStar(require(\"./contracts\"), exports);\n__exportStar(require(\"./promise-pool\"), exports);\n__exportStar(require(\"./promise-pool-error\"), exports);\n__exportStar(require(\"./return-value\"), exports);\n__exportStar(require(\"./stop-the-promise-pool-error\"), exports);\n__exportStar(require(\"./validation-error\"), exports);\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePoolError = void 0;\nclass PromisePoolError extends Error {\n    /**\n     * Create a new instance for the given `message` and `item`.\n     *\n     * @param error  The original error\n     * @param item   The item causing the error\n     */\n    constructor(error, item) {\n        super();\n        this.raw = error;\n        this.item = item;\n        this.name = this.constructor.name;\n        this.message = this.messageFrom(error);\n        if (Error.captureStackTrace && typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    /**\n     * Returns a new promise pool error instance wrapping the `error` and `item`.\n     *\n     * @param {*} error\n     * @param {*} item\n     *\n     * @returns {PromisePoolError}\n     */\n    static createFrom(error, item) {\n        return new this(error, item);\n    }\n    /**\n     * Returns the error message from the given `error`.\n     *\n     * @param {*} error\n     *\n     * @returns {String}\n     */\n    messageFrom(error) {\n        if (error instanceof Error) {\n            return error.message;\n        }\n        if (typeof error === 'object') {\n            return error.message;\n        }\n        if (typeof error === 'string' || typeof error === 'number') {\n            return error.toString();\n        }\n        return '';\n    }\n}\nexports.PromisePoolError = PromisePoolError;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePoolExecutor = void 0;\nconst promise_pool_1 = require(\"./promise-pool\");\nconst validation_error_1 = require(\"./validation-error\");\nconst promise_pool_error_1 = require(\"./promise-pool-error\");\nconst stop_the_promise_pool_error_1 = require(\"./stop-the-promise-pool-error\");\nclass PromisePoolExecutor {\n    /**\n     * Creates a new promise pool executer instance with a default concurrency of 10.\n     */\n    constructor() {\n        this.meta = {\n            tasks: [],\n            items: [],\n            errors: [],\n            results: [],\n            stopped: false,\n            concurrency: 10,\n            shouldResultsCorrespond: false,\n            processedItems: [],\n            taskTimeout: 0\n        };\n        this.handler = (item) => item;\n        this.errorHandler = undefined;\n        this.onTaskStartedHandlers = [];\n        this.onTaskFinishedHandlers = [];\n    }\n    /**\n     * Set the number of tasks to process concurrently the promise pool.\n     *\n     * @param {Integer} concurrency\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    useConcurrency(concurrency) {\n        if (!this.isValidConcurrency(concurrency)) {\n            throw validation_error_1.ValidationError.createFrom(`\"concurrency\" must be a number, 1 or up. Received \"${concurrency}\" (${typeof concurrency})`);\n        }\n        this.meta.concurrency = concurrency;\n        return this;\n    }\n    /**\n     * Determine whether the given `concurrency` value is valid.\n     *\n     * @param {Number} concurrency\n     *\n     * @returns {Boolean}\n     */\n    isValidConcurrency(concurrency) {\n        return typeof concurrency === 'number' && concurrency >= 1;\n    }\n    /**\n     * Set the timeout in ms for the pool handler\n     *\n     * @param {Number} timeout\n     *\n     * @returns {PromisePool}\n     */\n    withTaskTimeout(timeout) {\n        this.meta.taskTimeout = timeout;\n        return this;\n    }\n    /**\n     * Returns the number of concurrently processed tasks.\n     *\n     * @returns {Number}\n     */\n    concurrency() {\n        return this.meta.concurrency;\n    }\n    /**\n     * Assign whether to keep corresponding results between source items and resulting tasks.\n     */\n    useCorrespondingResults(shouldResultsCorrespond) {\n        this.meta.shouldResultsCorrespond = shouldResultsCorrespond;\n        return this;\n    }\n    /**\n     * Determine whether to keep corresponding results between source items and resulting tasks.\n     */\n    shouldUseCorrespondingResults() {\n        return this.meta.shouldResultsCorrespond;\n    }\n    /**\n     * Returns the task timeout in milliseconds.\n     */\n    taskTimeout() {\n        return this.meta.taskTimeout;\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {Array} items\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    for(items) {\n        this.meta.items = items;\n        return this;\n    }\n    /**\n     * Returns the list of items to process.\n     *\n     * @returns {T[] | Iterable<T> | AsyncIterable<T>}\n     */\n    items() {\n        return this.meta.items;\n    }\n    /**\n     * Returns the number of items to process, or `NaN` if items are not an array.\n     *\n     * @returns {Number}\n     */\n    itemsCount() {\n        const items = this.items();\n        return Array.isArray(items) ? items.length : NaN;\n    }\n    /**\n     * Returns the list of active tasks.\n     *\n     * @returns {Array}\n     */\n    tasks() {\n        return this.meta.tasks;\n    }\n    /**\n     * Returns the number of currently active tasks.\n     *\n     * @returns {Number}\n     *\n     * @deprecated use the `activeTasksCount()` method (plural naming) instead\n     */\n    activeTaskCount() {\n        return this.activeTasksCount();\n    }\n    /**\n     * Returns the number of currently active tasks.\n     *\n     * @returns {Number}\n     */\n    activeTasksCount() {\n        return this.tasks().length;\n    }\n    /**\n     * Returns the list of processed items.\n     *\n     * @returns {T[]}\n     */\n    processedItems() {\n        return this.meta.processedItems;\n    }\n    /**\n     * Returns the number of processed items.\n     *\n     * @returns {Number}\n     */\n    processedCount() {\n        return this.processedItems().length;\n    }\n    /**\n     * Returns the percentage progress of items that have been processed, or `NaN` if items is not an array.\n     */\n    processedPercentage() {\n        return (this.processedCount() / this.itemsCount()) * 100;\n    }\n    /**\n     * Returns the list of results.\n     *\n     * @returns {R[]}\n     */\n    results() {\n        return this.meta.results;\n    }\n    /**\n     * Returns the list of errors.\n     *\n     * @returns {Array<PromisePoolError<T>>}\n     */\n    errors() {\n        return this.meta.errors;\n    }\n    /**\n     * Set the handler that is applied to each item.\n     *\n     * @param {Function} action\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    withHandler(action) {\n        this.handler = action;\n        return this;\n    }\n    /**\n     * Determine whether a custom error handle is available.\n     *\n     * @returns {Boolean}\n     */\n    hasErrorHandler() {\n        return !!this.errorHandler;\n    }\n    /**\n     * Set the error handler function to execute when an error occurs.\n     *\n     * @param {Function} errorHandler\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    handleError(handler) {\n        this.errorHandler = handler;\n        return this;\n    }\n    /**\n     * Set the handler function to execute when started a task.\n     *\n     * @param {Function} handler\n     *\n     * @returns {this}\n     */\n    onTaskStarted(handlers) {\n        this.onTaskStartedHandlers = handlers;\n        return this;\n    }\n    /**\n      * Assign the given callback `handler` function to run when a task finished.\n     *\n     * @param {OnProgressCallback<T>} handlers\n     *\n     * @returns {this}\n     */\n    onTaskFinished(handlers) {\n        this.onTaskFinishedHandlers = handlers;\n        return this;\n    }\n    /**\n     * Determines whether the number of active tasks is greater or equal to the concurrency limit.\n     *\n     * @returns {Boolean}\n     */\n    hasReachedConcurrencyLimit() {\n        return this.activeTasksCount() >= this.concurrency();\n    }\n    /**\n     * Stop a promise pool processing.\n     */\n    stop() {\n        this.markAsStopped();\n        throw new stop_the_promise_pool_error_1.StopThePromisePoolError();\n    }\n    /**\n     * Mark the promise pool as stopped.\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    markAsStopped() {\n        this.meta.stopped = true;\n        return this;\n    }\n    /**\n     * Determine whether the pool is stopped.\n     *\n     * @returns {Boolean}\n     */\n    isStopped() {\n        return this.meta.stopped;\n    }\n    /**\n     * Start processing the promise pool.\n     *\n     * @returns {ReturnValue}\n     */\n    async start() {\n        return await this\n            .validateInputs()\n            .prepareResultsArray()\n            .process();\n    }\n    /**\n     * Determine whether the pool should stop.\n     *\n     * @returns {PromisePoolExecutor}\n     *\n     * @throws\n     */\n    validateInputs() {\n        if (typeof this.handler !== 'function') {\n            throw validation_error_1.ValidationError.createFrom('The first parameter for the .process(fn) method must be a function');\n        }\n        const timeout = this.taskTimeout();\n        if (!(timeout == null || (typeof timeout === 'number' && timeout >= 0))) {\n            throw validation_error_1.ValidationError.createFrom(`\"timeout\" must be undefined or a number. A number must be 0 or up. Received \"${String(timeout)}\" (${typeof timeout})`);\n        }\n        if (!this.areItemsValid()) {\n            throw validation_error_1.ValidationError.createFrom(`\"items\" must be an array, an iterable or an async iterable. Received \"${typeof this.items()}\"`);\n        }\n        if (this.errorHandler && typeof this.errorHandler !== 'function') {\n            throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received \"${typeof this.errorHandler}\"`);\n        }\n        this.onTaskStartedHandlers.forEach(handler => {\n            if (handler && typeof handler !== 'function') {\n                throw validation_error_1.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received \"${typeof handler}\"`);\n            }\n        });\n        this.onTaskFinishedHandlers.forEach(handler => {\n            if (handler && typeof handler !== 'function') {\n                throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received \"${typeof handler}\"`);\n            }\n        });\n        return this;\n    }\n    areItemsValid() {\n        const items = this.items();\n        if (Array.isArray(items))\n            return true;\n        if (typeof items[Symbol.iterator] === 'function')\n            return true;\n        if (typeof items[Symbol.asyncIterator] === 'function')\n            return true;\n        return false;\n    }\n    /**\n     * Prefill the results array with `notRun` symbol values if results should correspond.\n     */\n    prepareResultsArray() {\n        const items = this.items();\n        if (!Array.isArray(items))\n            return this;\n        if (!this.shouldUseCorrespondingResults())\n            return this;\n        this.meta.results = Array(items.length).fill(promise_pool_1.PromisePool.notRun);\n        return this;\n    }\n    /**\n     * Starts processing the promise pool by iterating over the items\n     * and running each item through the async `callback` function.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Promise}\n     */\n    async process() {\n        let index = 0;\n        for await (const item of this.items()) {\n            if (this.isStopped()) {\n                break;\n            }\n            if (this.shouldUseCorrespondingResults()) {\n                this.results()[index] = promise_pool_1.PromisePool.notRun;\n            }\n            this.startProcessing(item, index);\n            index += 1;\n            // don't consume the next item from iterable\n            // until there's a free slot for a new task\n            await this.waitForProcessingSlot();\n        }\n        return await this.drained();\n    }\n    /**\n     * Wait for one of the active tasks to finish processing.\n     */\n    async waitForProcessingSlot() {\n        /**\n         * We’re using a while loop here because it’s possible to decrease the pool’s\n         * concurrency at runtime. We need to wait for as many tasks as needed to\n         * finish processing before moving on to process the remaining tasks.\n         */\n        while (this.hasReachedConcurrencyLimit()) {\n            await this.waitForActiveTaskToFinish();\n        }\n    }\n    /**\n     * Wait for the next, currently active task to finish processing.\n     */\n    async waitForActiveTaskToFinish() {\n        await Promise.race(this.tasks());\n    }\n    /**\n     * Create a processing function for the given `item`.\n     *\n     * @param {T} item\n     * @param {number} index\n     */\n    startProcessing(item, index) {\n        const task = this.createTaskFor(item, index)\n            .then(result => {\n            this.save(result, index).removeActive(task);\n        })\n            .catch(async (error) => {\n            await this.handleErrorFor(error, item, index);\n            this.removeActive(task);\n        })\n            .finally(() => {\n            this.processedItems().push(item);\n            this.runOnTaskFinishedHandlers(item);\n        });\n        this.tasks().push(task);\n        this.runOnTaskStartedHandlers(item);\n    }\n    /**\n     * Ensures a returned promise for the processing of the given `item`.\n     *\n     * @param {T} item\n     * @param {number} index\n     *\n     * @returns {*}\n     */\n    async createTaskFor(item, index) {\n        if (this.taskTimeout() === undefined) {\n            return this.handler(item, index, this);\n        }\n        const [timer, canceller] = this.createTaskTimeout(item);\n        return Promise.race([\n            this.handler(item, index, this),\n            timer(),\n        ]).finally(canceller);\n    }\n    /**\n     * Returns a tuple of a timer function and a canceller function that\n     * times-out after the configured task timeout.\n     */\n    createTaskTimeout(item) {\n        let timerId;\n        const timer = async () => new Promise((_resolve, reject) => {\n            timerId = setTimeout(() => {\n                reject(new promise_pool_error_1.PromisePoolError(`Task in promise pool timed out after ${this.taskTimeout()}ms`, item));\n            }, this.taskTimeout());\n        });\n        const canceller = () => clearTimeout(timerId);\n        return [timer, canceller];\n    }\n    /**\n     * Save the given calculation `result`, possibly at the provided `position`.\n     *\n     * @param {*} result\n     * @param {number} position\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    save(result, position) {\n        this.shouldUseCorrespondingResults()\n            ? this.results()[position] = result\n            : this.results().push(result);\n        return this;\n    }\n    /**\n     * Remove the given `task` from the list of active tasks.\n     *\n     * @param {Promise} task\n     */\n    removeActive(task) {\n        this.tasks().splice(this.tasks().indexOf(task), 1);\n        return this;\n    }\n    /**\n     * Create and save an error for the the given `item`.\n     *\n     * @param {Error} error\n     * @param {T} item\n     * @param {number} index\n     */\n    async handleErrorFor(error, item, index) {\n        if (this.shouldUseCorrespondingResults()) {\n            this.results()[index] = promise_pool_1.PromisePool.failed;\n        }\n        if (this.isStoppingThePoolError(error)) {\n            return;\n        }\n        if (this.isValidationError(error)) {\n            this.markAsStopped();\n            throw error;\n        }\n        this.hasErrorHandler()\n            ? await this.runErrorHandlerFor(error, item)\n            : this.saveErrorFor(error, item);\n    }\n    /**\n     * Determine whether the given `error` is a `StopThePromisePoolError` instance.\n     *\n     * @param {Error} error\n     *\n     * @returns {Boolean}\n     */\n    isStoppingThePoolError(error) {\n        return error instanceof stop_the_promise_pool_error_1.StopThePromisePoolError;\n    }\n    /**\n     * Determine whether the given `error` is a `ValidationError` instance.\n     *\n     * @param {Error} error\n     *\n     * @returns {Boolean}\n     */\n    isValidationError(error) {\n        return error instanceof validation_error_1.ValidationError;\n    }\n    /**\n     * Run the user’s error handler, if available.\n     *\n     * @param {Error} processingError\n     * @param {T} item\n     */\n    async runErrorHandlerFor(processingError, item) {\n        try {\n            await this.errorHandler?.(processingError, item, this);\n        }\n        catch (error) {\n            this.rethrowIfNotStoppingThePool(error);\n        }\n    }\n    /**\n     * Run the onTaskStarted handlers.\n     */\n    runOnTaskStartedHandlers(item) {\n        this.onTaskStartedHandlers.forEach(handler => {\n            handler(item, this);\n        });\n    }\n    /**\n     * Run the onTaskFinished handlers.\n     */\n    runOnTaskFinishedHandlers(item) {\n        this.onTaskFinishedHandlers.forEach(handler => {\n            handler(item, this);\n        });\n    }\n    /**\n     * Rethrow the given `error` if it’s not an instance of `StopThePromisePoolError`.\n     *\n     * @param {Error} error\n     */\n    rethrowIfNotStoppingThePool(error) {\n        if (this.isStoppingThePoolError(error)) {\n            return;\n        }\n        throw error;\n    }\n    /**\n     * Create and save an error for the the given `item`.\n     *\n     * @param {T} item\n     */\n    saveErrorFor(error, item) {\n        this.errors().push(promise_pool_error_1.PromisePoolError.createFrom(error, item));\n    }\n    /**\n     * Wait for all active tasks to finish. Once all the tasks finished\n     * processing, returns an object containing the results and errors.\n     *\n     * @returns {Object}\n     */\n    async drained() {\n        await this.drainActiveTasks();\n        return {\n            errors: this.errors(),\n            results: this.results()\n        };\n    }\n    /**\n     * Wait for all of the active tasks to finish processing.\n     */\n    async drainActiveTasks() {\n        await Promise.all(this.tasks());\n    }\n}\nexports.PromisePoolExecutor = PromisePoolExecutor;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePool = void 0;\nconst promise_pool_executor_1 = require(\"./promise-pool-executor\");\nclass PromisePool {\n    /**\n     * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.\n     *\n     * @param {Object} options\n     */\n    constructor(items) {\n        this.timeout = undefined;\n        this.concurrency = 10;\n        this.items = items ?? [];\n        this.errorHandler = undefined;\n        this.onTaskStartedHandlers = [];\n        this.onTaskFinishedHandlers = [];\n        this.shouldResultsCorrespond = false;\n    }\n    /**\n     * Set the number of tasks to process concurrently in the promise pool.\n     *\n     * @param {Integer} concurrency\n     *\n     * @returns {PromisePool}\n     */\n    withConcurrency(concurrency) {\n        this.concurrency = concurrency;\n        return this;\n    }\n    /**\n     * Set the number of tasks to process concurrently in the promise pool.\n     *\n     * @param {Number} concurrency\n     *\n     * @returns {PromisePool}\n     */\n    static withConcurrency(concurrency) {\n        return new this().withConcurrency(concurrency);\n    }\n    /**\n     * Set the timeout in milliseconds for the pool handler.\n     *\n     * @param {Number} timeout\n     *\n     * @returns {PromisePool}\n     */\n    withTaskTimeout(timeout) {\n        this.timeout = timeout;\n        return this;\n    }\n    /**\n     * Set the timeout in milliseconds for the pool handler.\n     *\n     * @param {Number} timeout\n     *\n     * @returns {PromisePool}\n     */\n    static withTaskTimeout(timeout) {\n        return new this().withTaskTimeout(timeout);\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {SomeIterable<ItemType>} items\n     *\n     * @returns {PromisePool}\n     */\n    for(items) {\n        const pool = new PromisePool(items).withConcurrency(this.concurrency);\n        if (typeof this.errorHandler === 'function') {\n            pool.handleError(this.errorHandler);\n        }\n        return typeof this.timeout === 'number'\n            ? pool.withTaskTimeout(this.timeout)\n            : pool;\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {T[] | Iterable<T> | AsyncIterable<T>} items\n     *\n     * @returns {PromisePool}\n     */\n    static for(items) {\n        return new this().for(items);\n    }\n    /**\n     * Set the error handler function to execute when an error occurs.\n     *\n     * @param {ErrorHandler<T>} handler\n     *\n     * @returns {PromisePool}\n     */\n    handleError(handler) {\n        this.errorHandler = handler;\n        return this;\n    }\n    /**\n     * Assign the given callback `handler` function to run when a task starts.\n     *\n     * @param {OnProgressCallback<T>} handler\n     *\n     * @returns {PromisePool}\n     */\n    onTaskStarted(handler) {\n        this.onTaskStartedHandlers.push(handler);\n        return this;\n    }\n    /**\n     * Assign the given callback `handler` function to run when a task finished.\n     *\n     * @param {OnProgressCallback<T>} handler\n     *\n     * @returns {PromisePool}\n     */\n    onTaskFinished(handler) {\n        this.onTaskFinishedHandlers.push(handler);\n        return this;\n    }\n    /**\n     * Assign whether to keep corresponding results between source items and resulting tasks.\n     */\n    useCorrespondingResults() {\n        this.shouldResultsCorrespond = true;\n        return this;\n    }\n    /**\n     * Starts processing the promise pool by iterating over the items\n     * and running each item through the async `callback` function.\n     *\n     * @param {ProcessHandler} The async processing function receiving each item from the `items` array.\n     *\n     * @returns Promise<{ results, errors }>\n     */\n    async process(callback) {\n        return new promise_pool_executor_1.PromisePoolExecutor()\n            .useConcurrency(this.concurrency)\n            .useCorrespondingResults(this.shouldResultsCorrespond)\n            .withTaskTimeout(this.timeout)\n            .withHandler(callback)\n            .handleError(this.errorHandler)\n            .onTaskStarted(this.onTaskStartedHandlers)\n            .onTaskFinished(this.onTaskFinishedHandlers)\n            .for(this.items)\n            .start();\n    }\n}\nexports.PromisePool = PromisePool;\nPromisePool.notRun = Symbol('notRun');\nPromisePool.failed = Symbol('failed');\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StopThePromisePoolError = void 0;\nclass StopThePromisePoolError extends Error {\n}\nexports.StopThePromisePoolError = StopThePromisePoolError;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidationError = void 0;\nclass ValidationError extends Error {\n    /**\n     * Create a new instance for the given `message`.\n     *\n     * @param message  The error message\n     */\n    constructor(message) {\n        super(message);\n        if (Error.captureStackTrace && typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    /**\n     * Returns a validation error with the given `message`.\n     */\n    static createFrom(message) {\n        return new this(message);\n    }\n}\nexports.ValidationError = ValidationError;\n"],"names":["Object","defineProperty","exports","value","__createBinding","this","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","promise_pool_1","require","PromisePool","PromisePoolError","Error","constructor","error","item","super","raw","name","message","messageFrom","captureStackTrace","createFrom","toString","PromisePoolExecutor","validation_error_1","promise_pool_error_1","stop_the_promise_pool_error_1","meta","tasks","items","errors","results","stopped","concurrency","shouldResultsCorrespond","processedItems","taskTimeout","handler","errorHandler","onTaskStartedHandlers","onTaskFinishedHandlers","useConcurrency","isValidConcurrency","ValidationError","withTaskTimeout","timeout","useCorrespondingResults","shouldUseCorrespondingResults","for","itemsCount","Array","isArray","length","NaN","activeTaskCount","activeTasksCount","processedCount","processedPercentage","withHandler","action","hasErrorHandler","handleError","onTaskStarted","handlers","onTaskFinished","hasReachedConcurrencyLimit","stop","markAsStopped","StopThePromisePoolError","isStopped","start","validateInputs","prepareResultsArray","process","String","areItemsValid","forEach","Symbol","iterator","asyncIterator","fill","notRun","index","startProcessing","waitForProcessingSlot","drained","waitForActiveTaskToFinish","Promise","race","task","createTaskFor","then","result","save","removeActive","catch","async","handleErrorFor","finally","push","runOnTaskFinishedHandlers","runOnTaskStartedHandlers","timer","canceller","createTaskTimeout","timerId","_resolve","reject","setTimeout","clearTimeout","position","splice","indexOf","failed","isStoppingThePoolError","isValidationError","runErrorHandlerFor","saveErrorFor","processingError","rethrowIfNotStoppingThePool","drainActiveTasks","all","promise_pool_executor_1","withConcurrency","pool","callback"],"sourceRoot":""}